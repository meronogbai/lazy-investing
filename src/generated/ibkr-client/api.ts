/* tslint:disable */
/* eslint-disable */
/**
 * Client Portal Web API
 * Client Poral Web API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * account information
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * The account identification value
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * The account number
     * @type {string}
     * @memberof Account
     */
    'accountId'?: string;
    /**
     * The accountAlias
     * @type {string}
     * @memberof Account
     */
    'accountVan'?: string;
    /**
     * Title of the account
     * @type {string}
     * @memberof Account
     */
    'accountTitle'?: string;
    /**
     * Whichever value is not null in this priority
     * @type {string}
     * @memberof Account
     */
    'displayName'?: AccountDisplayNameEnum;
    /**
     * User customizable account alias. Refer to [Configure Account Alias](https://guides.interactivebrokers.com/cp/cp.htm#am/settings/accountalias.htm) for details.
     * @type {string}
     * @memberof Account
     */
    'accountAlias'?: string;
    /**
     * When the account was opened in unix time.
     * @type {number}
     * @memberof Account
     */
    'accountStatus'?: number;
    /**
     * Base currency of the account.
     * @type {string}
     * @memberof Account
     */
    'currency'?: AccountCurrencyEnum;
    /**
     * Account Type
     * @type {string}
     * @memberof Account
     */
    'type'?: AccountTypeEnum;
    /**
     * UNI - Deprecated property
     * @type {string}
     * @memberof Account
     */
    'tradingType'?: string;
    /**
     * If an account is a sub-account to a Financial Advisor.
     * @type {boolean}
     * @memberof Account
     */
    'faclient'?: boolean;
    /**
     * Status of the Account   * O = Open   * P or N = Pending   * A = Abandoned   * R = Rejected   * C = Closed 
     * @type {string}
     * @memberof Account
     */
    'clearingStatus'?: AccountClearingStatusEnum;
    /**
     * Is a Covestor Account
     * @type {boolean}
     * @memberof Account
     */
    'covestor'?: boolean;
    /**
     * 
     * @type {AccountParent}
     * @memberof Account
     */
    'parent'?: AccountParent;
    /**
     * Formatted \"accountId - accountAlias\"
     * @type {string}
     * @memberof Account
     */
    'desc'?: string;
}

export const AccountDisplayNameEnum = {
    AccountTitle: 'accountTitle',
    AccountVan: 'accountVan',
    AccountId: 'accountId'
} as const;

export type AccountDisplayNameEnum = typeof AccountDisplayNameEnum[keyof typeof AccountDisplayNameEnum];
export const AccountCurrencyEnum = {
    Aud: 'AUD',
    Gbp: 'GBP',
    Cad: 'CAD',
    Cnh: 'CNH',
    Czk: 'CZK',
    Dkk: 'DKK',
    Eur: 'EUR',
    Hkd: 'HKD',
    Huf: 'HUF',
    Inr: 'INR',
    Ils: 'ILS',
    Jpy: 'JPY',
    Mxn: 'MXN',
    Nok: 'NOK',
    Nzd: 'NZD',
    Pln: 'PLN',
    Rub: 'RUB',
    Sgd: 'SGD',
    Sek: 'SEK',
    Chf: 'CHF',
    Usd: 'USD'
} as const;

export type AccountCurrencyEnum = typeof AccountCurrencyEnum[keyof typeof AccountCurrencyEnum];
export const AccountTypeEnum = {
    Individual: 'INDIVIDUAL',
    Joint: 'JOINT',
    Org: 'ORG',
    Trust: 'TRUST',
    Demo: 'DEMO'
} as const;

export type AccountTypeEnum = typeof AccountTypeEnum[keyof typeof AccountTypeEnum];
export const AccountClearingStatusEnum = {
    O: 'O',
    P: 'P',
    N: 'N',
    A: 'A',
    R: 'R',
    C: 'C'
} as const;

export type AccountClearingStatusEnum = typeof AccountClearingStatusEnum[keyof typeof AccountClearingStatusEnum];

/**
 * 
 * @export
 * @interface AccountParent
 */
export interface AccountParent {
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountParent
     */
    'mmc'?: Array<string>;
    /**
     * Account Number for Money Manager Client
     * @type {string}
     * @memberof AccountParent
     */
    'accountId'?: string;
    /**
     * Is MM a Parent Account
     * @type {boolean}
     * @memberof AccountParent
     */
    'isMParent'?: boolean;
    /**
     * Is MM a Child Account
     * @type {boolean}
     * @memberof AccountParent
     */
    'isMChild'?: boolean;
    /**
     * Is a Multiplex Account. These are account models with individual account being parent and managed account being child.
     * @type {boolean}
     * @memberof AccountParent
     */
    'isMultiplex'?: boolean;
}
/**
 * 
 * @export
 * @interface AlertRequest
 */
export interface AlertRequest {
    /**
     * orderId is required when modifying alert. You can get it from /iserver/account/:accountId/alerts 
     * @type {number}
     * @memberof AlertRequest
     */
    'orderId'?: number;
    /**
     * name of alert
     * @type {string}
     * @memberof AlertRequest
     */
    'alertName'?: string;
    /**
     * The message you want to receive via email or text message
     * @type {string}
     * @memberof AlertRequest
     */
    'alertMessage'?: string;
    /**
     * whether alert is repeatable or not, so value can only be 0 or 1, this has to be 1 for MTA alert
     * @type {number}
     * @memberof AlertRequest
     */
    'alertRepeatable'?: number;
    /**
     * email address to receive alert
     * @type {string}
     * @memberof AlertRequest
     */
    'email'?: string;
    /**
     * whether allowing to send email or not, so value can only be 0 or 1, 
     * @type {number}
     * @memberof AlertRequest
     */
    'sendMessage'?: number;
    /**
     * time in force, can only be GTC or GTD
     * @type {string}
     * @memberof AlertRequest
     */
    'tif'?: string;
    /**
     * format, YYYYMMDD-HH:mm:ss, please NOTE this will only work when tif is GTD 
     * @type {string}
     * @memberof AlertRequest
     */
    'expireTime'?: string;
    /**
     * value can only be 0 or 1, set to 1 if the alert can be triggered outside regular trading hours. 
     * @type {number}
     * @memberof AlertRequest
     */
    'outsideRth'?: number;
    /**
     * value can only be 0 or 1, set to 1 to enable the alert only in IBKR mobile 
     * @type {number}
     * @memberof AlertRequest
     */
    'iTWSOrdersOnly'?: number;
    /**
     * value can only be 0 or 1, set to 1 to allow to show alert in pop-ups
     * @type {number}
     * @memberof AlertRequest
     */
    'showPopup'?: number;
    /**
     * for MTA alert only, each user has a unique toolId and it will stay the same, do not send for normal alert 
     * @type {number}
     * @memberof AlertRequest
     */
    'toolId'?: number;
    /**
     * audio message to play when alert is triggered
     * @type {string}
     * @memberof AlertRequest
     */
    'playAudio'?: string;
    /**
     * 
     * @type {Array<AlertRequestConditionsInner>}
     * @memberof AlertRequest
     */
    'conditions'?: Array<AlertRequestConditionsInner>;
}
/**
 * 
 * @export
 * @interface AlertRequestConditionsInner
 */
export interface AlertRequestConditionsInner {
    /**
     * Types: 1-Price, 3-Time, 4-Margin, 5-Trade, 6-Volume, 7: MTA market 8: MTA Position, 9: MTA Acc. Daily PN& 
     * @type {number}
     * @memberof AlertRequestConditionsInner
     */
    'type'?: number;
    /**
     * conid and exchange. Format supports conid or conid@exchange
     * @type {string}
     * @memberof AlertRequestConditionsInner
     */
    'conidex'?: string;
    /**
     * optional, operator for the current condition, can be >= or <=
     * @type {string}
     * @memberof AlertRequestConditionsInner
     */
    'operator'?: string;
    /**
     * optional, only some type of conditions have triggerMethod
     * @type {string}
     * @memberof AlertRequestConditionsInner
     */
    'triggerMethod'?: string;
    /**
     * can not be empty, can pass default value \"*\"
     * @type {string}
     * @memberof AlertRequestConditionsInner
     */
    'value'?: string;
    /**
     * \"a\" means \"AND\", \"o\" means \"OR\", \"n\" means \"END\", the last one condition in the condition array should \"n\" 
     * @type {string}
     * @memberof AlertRequestConditionsInner
     */
    'logicBind'?: string;
    /**
     * only needed for some MTA alert condition
     * @type {string}
     * @memberof AlertRequestConditionsInner
     */
    'timeZone'?: string;
}
/**
 * 
 * @export
 * @interface AlertResponse
 */
export interface AlertResponse {
    /**
     * account id
     * @type {string}
     * @memberof AlertResponse
     */
    'account'?: string;
    /**
     * 
     * @type {number}
     * @memberof AlertResponse
     */
    'order_id'?: number;
    /**
     * name of alert
     * @type {string}
     * @memberof AlertResponse
     */
    'alert_name'?: string;
    /**
     * The message you want to receive via email or text message
     * @type {string}
     * @memberof AlertResponse
     */
    'alert_message'?: string;
    /**
     * whether alert is active or not, so value can only be 0 or 1
     * @type {number}
     * @memberof AlertResponse
     */
    'alert_active'?: number;
    /**
     * whether alert is repeatable or not, so value can only be 0 or 1
     * @type {number}
     * @memberof AlertResponse
     */
    'alert_repeatable'?: number;
    /**
     * email address to receive alert
     * @type {string}
     * @memberof AlertResponse
     */
    'alert_email'?: string;
    /**
     * whether allowing to send email or not, so value can only be 0 or 1, 
     * @type {number}
     * @memberof AlertResponse
     */
    'alert_send_message'?: number;
    /**
     * time in force, can only be GTC or GTD
     * @type {string}
     * @memberof AlertResponse
     */
    'tif'?: string;
    /**
     * format, YYYYMMDD-HH:mm:ss 
     * @type {string}
     * @memberof AlertResponse
     */
    'expire_time'?: string;
    /**
     * status of alert
     * @type {string}
     * @memberof AlertResponse
     */
    'order_status'?: string;
    /**
     * value can only be 0 or 1, set to 1 if the alert can be triggered outside regular trading hours. 
     * @type {number}
     * @memberof AlertResponse
     */
    'outsideRth'?: number;
    /**
     * value can only be 0 or 1, set to 1 to enable the alert only in IBKR mobile 
     * @type {number}
     * @memberof AlertResponse
     */
    'itws_orders_only'?: number;
    /**
     * value can only be 0 or 1, set to 1 to allow to show alert in pop-ups
     * @type {number}
     * @memberof AlertResponse
     */
    'alert_show_popup'?: number;
    /**
     * whether the alert has been triggered
     * @type {boolean}
     * @memberof AlertResponse
     */
    'alert_triggered'?: boolean;
    /**
     * whether the alert can be edited
     * @type {boolean}
     * @memberof AlertResponse
     */
    'order_not_editable'?: boolean;
    /**
     * for MTA alert only, each user has a unique toolId and it will stay the same, do not send for normal alert 
     * @type {number}
     * @memberof AlertResponse
     */
    'tool_id'?: number;
    /**
     * audio message to play when alert is triggered
     * @type {string}
     * @memberof AlertResponse
     */
    'alert_play_audio'?: string;
    /**
     * MTA alert only
     * @type {string}
     * @memberof AlertResponse
     */
    'alert_mta_currency'?: string;
    /**
     * MTA alert only
     * @type {string}
     * @memberof AlertResponse
     */
    'alert_mta_defaults'?: string;
    /**
     * MTA alert only
     * @type {string}
     * @memberof AlertResponse
     */
    'time_zone'?: string;
    /**
     * MTA alert only
     * @type {string}
     * @memberof AlertResponse
     */
    'alert_default_type'?: string;
    /**
     * size of conditions array
     * @type {number}
     * @memberof AlertResponse
     */
    'condition_size'?: number;
    /**
     * whether allowing the condition can be triggered outside of regular trading hours, 1 means allow
     * @type {number}
     * @memberof AlertResponse
     */
    'condition_outside_rth'?: number;
    /**
     * 
     * @type {Array<AlertResponseConditionsInner>}
     * @memberof AlertResponse
     */
    'conditions'?: Array<AlertResponseConditionsInner>;
}
/**
 * 
 * @export
 * @interface AlertResponseConditionsInner
 */
export interface AlertResponseConditionsInner {
    /**
     * Types: 1-Price, 3-Time, 4-Margin, 5-Trade, 6-Volume, 7: MTA market 8: MTA Position, 9: MTA Acc. Daily PN& 
     * @type {number}
     * @memberof AlertResponseConditionsInner
     */
    'condition_type'?: number;
    /**
     * conid and exchange. Format supports conid or conid@exchange
     * @type {string}
     * @memberof AlertResponseConditionsInner
     */
    'conidex'?: string;
    /**
     * Format contract name
     * @type {string}
     * @memberof AlertResponseConditionsInner
     */
    'contract_description_1'?: string;
    /**
     * optional, operator for the current condition   * >= Greater than or equal to   * <= Less than or equal to 
     * @type {string}
     * @memberof AlertResponseConditionsInner
     */
    'condition_operator'?: string;
    /**
     * optional, only some type of conditions have triggerMethod
     * @type {string}
     * @memberof AlertResponseConditionsInner
     */
    'condition_trigger_method'?: string;
    /**
     * can not be empty, can pass default value \"*\"
     * @type {string}
     * @memberof AlertResponseConditionsInner
     */
    'condition_value'?: string;
    /**
     * Condition array should end with \"n\"   * a - AND   * o - OR   * n - END 
     * @type {string}
     * @memberof AlertResponseConditionsInner
     */
    'condition_logic_bind'?: string;
    /**
     * only needed for some MTA alert condition
     * @type {string}
     * @memberof AlertResponseConditionsInner
     */
    'condition_time_zone'?: string;
}
/**
 * allocation
 * @export
 * @interface AllocationInner
 */
export interface AllocationInner {
    /**
     * 
     * @type {AllocationInnerAssetClass}
     * @memberof AllocationInner
     */
    'assetClass'?: AllocationInnerAssetClass;
    /**
     * 
     * @type {AllocationInnerSector}
     * @memberof AllocationInner
     */
    'sector'?: AllocationInnerSector;
    /**
     * 
     * @type {AllocationInnerGroup}
     * @memberof AllocationInner
     */
    'group'?: AllocationInnerGroup;
}
/**
 * portfolio allocation by asset class
 * @export
 * @interface AllocationInnerAssetClass
 */
export interface AllocationInnerAssetClass {
    /**
     * 
     * @type {AllocationInnerAssetClassLong}
     * @memberof AllocationInnerAssetClass
     */
    'long'?: AllocationInnerAssetClassLong;
    /**
     * 
     * @type {AllocationInnerAssetClassShort}
     * @memberof AllocationInnerAssetClass
     */
    'short'?: AllocationInnerAssetClassShort;
}
/**
 * long positions allocation
 * @export
 * @interface AllocationInnerAssetClassLong
 */
export interface AllocationInnerAssetClassLong {
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerAssetClassLong
     */
    'STK'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerAssetClassLong
     */
    'OPT'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerAssetClassLong
     */
    'FUT'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerAssetClassLong
     */
    'WAR'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerAssetClassLong
     */
    'BOND'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerAssetClassLong
     */
    'CASH'?: number;
}
/**
 * short positions allocation
 * @export
 * @interface AllocationInnerAssetClassShort
 */
export interface AllocationInnerAssetClassShort {
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerAssetClassShort
     */
    'STK'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerAssetClassShort
     */
    'OPT'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerAssetClassShort
     */
    'FUT'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerAssetClassShort
     */
    'WAR'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerAssetClassShort
     */
    'BOND'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerAssetClassShort
     */
    'CASH'?: number;
}
/**
 * portfolio allocation by group
 * @export
 * @interface AllocationInnerGroup
 */
export interface AllocationInnerGroup {
    /**
     * 
     * @type {AllocationInnerGroupLong}
     * @memberof AllocationInnerGroup
     */
    'long'?: AllocationInnerGroupLong;
    /**
     * 
     * @type {AllocationInnerGroupShort}
     * @memberof AllocationInnerGroup
     */
    'short'?: AllocationInnerGroupShort;
}
/**
 * long positions allocation
 * @export
 * @interface AllocationInnerGroupLong
 */
export interface AllocationInnerGroupLong {
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerGroupLong
     */
    'Computers'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerGroupLong
     */
    'Semiconductors'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerGroupLong
     */
    'Others'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerGroupLong
     */
    'Chemicals'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerGroupLong
     */
    'Apparel'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerGroupLong
     */
    'Communications'?: number;
}
/**
 * short positions allocation
 * @export
 * @interface AllocationInnerGroupShort
 */
export interface AllocationInnerGroupShort {
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerGroupShort
     */
    'Banks'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerGroupShort
     */
    'Airlines'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerGroupShort
     */
    'Internet'?: number;
}
/**
 * portfolio allocation by sector
 * @export
 * @interface AllocationInnerSector
 */
export interface AllocationInnerSector {
    /**
     * 
     * @type {AllocationInnerSectorLong}
     * @memberof AllocationInnerSector
     */
    'long'?: AllocationInnerSectorLong;
    /**
     * 
     * @type {AllocationInnerSectorShort}
     * @memberof AllocationInnerSector
     */
    'short'?: AllocationInnerSectorShort;
}
/**
 * long positions allocation
 * @export
 * @interface AllocationInnerSectorLong
 */
export interface AllocationInnerSectorLong {
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerSectorLong
     */
    'Others'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerSectorLong
     */
    'Utilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerSectorLong
     */
    'Energy'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerSectorLong
     */
    'Technology'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerSectorLong
     */
    'Financial'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerSectorLong
     */
    'Communications'?: number;
}
/**
 * short positions allocation
 * @export
 * @interface AllocationInnerSectorShort
 */
export interface AllocationInnerSectorShort {
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerSectorShort
     */
    'Industrial'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerSectorShort
     */
    'Consumer'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocationInnerSectorShort
     */
    'Diversified'?: number;
}
/**
 * 
 * @export
 * @interface AuthStatus
 */
export interface AuthStatus {
    /**
     * Brokerage session is authenticated
     * @type {boolean}
     * @memberof AuthStatus
     */
    'authenticated'?: boolean;
    /**
     * Connected to backend
     * @type {boolean}
     * @memberof AuthStatus
     */
    'connected'?: boolean;
    /**
     * Brokerage session is competing, e.g. user is logged in to IBKR Mobile, WebTrader, TWS or other trading platforms.
     * @type {boolean}
     * @memberof AuthStatus
     */
    'competing'?: boolean;
    /**
     * Authentication failed, why.
     * @type {string}
     * @memberof AuthStatus
     */
    'fail'?: string;
    /**
     * System messages that may affect trading
     * @type {string}
     * @memberof AuthStatus
     */
    'message'?: string;
    /**
     * Prompt messages that may affect trading or the account
     * @type {Array<string>}
     * @memberof AuthStatus
     */
    'prompts'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CalendarRequest
 */
export interface CalendarRequest {
    /**
     * 
     * @type {CalendarRequestDate}
     * @memberof CalendarRequest
     */
    'date'?: CalendarRequestDate;
    /**
     * 
     * @type {CalendarRequestFilters}
     * @memberof CalendarRequest
     */
    'filters'?: CalendarRequestFilters;
}
/**
 * 
 * @export
 * @interface CalendarRequestDate
 */
export interface CalendarRequestDate {
    /**
     * start date of a period. for example 20180808-0400
     * @type {string}
     * @memberof CalendarRequestDate
     */
    'start'?: string;
    /**
     * end date of a period. for example 20180808-0400
     * @type {string}
     * @memberof CalendarRequestDate
     */
    'end'?: string;
}
/**
 * 
 * @export
 * @interface CalendarRequestFilters
 */
export interface CalendarRequestFilters {
    /**
     * value can be \'true\' or \'false\'.
     * @type {string}
     * @memberof CalendarRequestFilters
     */
    'recently_held'?: string;
    /**
     * value can be \'true\' or \'false\'.
     * @type {string}
     * @memberof CalendarRequestFilters
     */
    'corporate_earnings'?: string;
    /**
     * value can be \'true\' or \'false\'.
     * @type {string}
     * @memberof CalendarRequestFilters
     */
    'DivExDates'?: string;
    /**
     * value can be \'true\' or \'false\'.
     * @type {string}
     * @memberof CalendarRequestFilters
     */
    'ipo'?: string;
    /**
     * value can be \'true\' or \'false\'.
     * @type {string}
     * @memberof CalendarRequestFilters
     */
    'splits'?: string;
    /**
     * value can be \'true\' or \'false\'.
     * @type {string}
     * @memberof CalendarRequestFilters
     */
    'corporate_events'?: string;
    /**
     * value can be \'true\' or \'false\'.
     * @type {string}
     * @memberof CalendarRequestFilters
     */
    'economic_events'?: string;
    /**
     * value can be \'true\' or \'false\'.
     * @type {string}
     * @memberof CalendarRequestFilters
     */
    'option_show_monthly'?: string;
    /**
     * value can be \'true\' or \'false\'.
     * @type {string}
     * @memberof CalendarRequestFilters
     */
    'option_show_weekly'?: string;
    /**
     * default is \'All\'.
     * @type {string}
     * @memberof CalendarRequestFilters
     */
    'country'?: string;
    /**
     * default is \'250\'.
     * @type {string}
     * @memberof CalendarRequestFilters
     */
    'limit'?: string;
    /**
     * default is \'50\'.
     * @type {string}
     * @memberof CalendarRequestFilters
     */
    'limit_region'?: string;
}
/**
 * 
 * @export
 * @interface CcpAccountGet200Response
 */
export interface CcpAccountGet200Response {
    /**
     * The primary or parent account.
     * @type {string}
     * @memberof CcpAccountGet200Response
     */
    'mainAcct'?: string;
    /**
     * List of tradeable or Sub Accounts
     * @type {Array<CcpAccountGet200ResponseAcctListInner>}
     * @memberof CcpAccountGet200Response
     */
    'acctList'?: Array<CcpAccountGet200ResponseAcctListInner>;
}
/**
 * 
 * @export
 * @interface CcpAccountGet200ResponseAcctListInner
 */
export interface CcpAccountGet200ResponseAcctListInner {
    /**
     * For multi-account structures each trading account will numbered from 0 to ...
     * @type {string}
     * @memberof CcpAccountGet200ResponseAcctListInner
     */
    '0'?: string;
}
/**
 * 
 * @export
 * @interface CcpAuthInitPost200Response
 */
export interface CcpAuthInitPost200Response {
    /**
     * Challenge in hex format
     * @type {object}
     * @memberof CcpAuthInitPost200Response
     */
    'challenge'?: object;
}
/**
 * 
 * @export
 * @interface CcpAuthResponsePost200Response
 */
export interface CcpAuthResponsePost200Response {
    /**
     * If sso authentication completed
     * @type {boolean}
     * @memberof CcpAuthResponsePost200Response
     */
    'passed'?: boolean;
    /**
     * If connection is authenticated
     * @type {boolean}
     * @memberof CcpAuthResponsePost200Response
     */
    'authenticated'?: boolean;
    /**
     * Connected to CCP session
     * @type {boolean}
     * @memberof CcpAuthResponsePost200Response
     */
    'connected'?: boolean;
    /**
     * If user already has an existing brokerage session running.
     * @type {boolean}
     * @memberof CcpAuthResponsePost200Response
     */
    'competing'?: boolean;
}
/**
 * 
 * @export
 * @interface CcpAuthResponsePostRequest
 */
export interface CcpAuthResponsePostRequest {
    /**
     * 
     * @type {string}
     * @memberof CcpAuthResponsePostRequest
     */
    'response'?: string;
}
/**
 * 
 * @export
 * @interface CcpOrdersGet200Response
 */
export interface CcpOrdersGet200Response {
    /**
     * 
     * @type {Array<OrderData>}
     * @memberof CcpOrdersGet200Response
     */
    'orders'?: Array<OrderData>;
}
/**
 * 
 * @export
 * @interface CcpStatusGet200Response
 */
export interface CcpStatusGet200Response {
    /**
     * Login session is authenticated to the CCP.
     * @type {boolean}
     * @memberof CcpStatusGet200Response
     */
    'authenticated'?: boolean;
    /**
     * Login session is connected
     * @type {boolean}
     * @memberof CcpStatusGet200Response
     */
    'connected'?: boolean;
    /**
     * server name
     * @type {string}
     * @memberof CcpStatusGet200Response
     */
    'name'?: string;
}
/**
 * Contains all details of the contract, including rules you can use when placing orders
 * @export
 * @interface Contract
 */
export interface Contract {
    /**
     * true means you can trade outside RTH(regular trading hours)
     * @type {boolean}
     * @memberof Contract
     */
    'r_t_h'?: boolean;
    /**
     * same as that in request
     * @type {string}
     * @memberof Contract
     */
    'con_id'?: string;
    /**
     * Contracts company name
     * @type {string}
     * @memberof Contract
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'exchange'?: string;
    /**
     * for exmple FB
     * @type {string}
     * @memberof Contract
     */
    'local_symbol'?: string;
    /**
     * for example STK
     * @type {string}
     * @memberof Contract
     */
    'instrument_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'companyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'industry'?: string;
    /**
     * 
     * @type {ContractRules}
     * @memberof Contract
     */
    'rules'?: ContractRules;
}
/**
 * 
 * @export
 * @interface ContractRules
 */
export interface ContractRules {
    /**
     * 
     * @type {Array<string>}
     * @memberof ContractRules
     */
    'orderTypes'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContractRules
     */
    'orderTypesOutside'?: Array<string>;
    /**
     * default quantity you can use to place an order
     * @type {number}
     * @memberof ContractRules
     */
    'defaultSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContractRules
     */
    'sizeIncrement'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContractRules
     */
    'tifTypes'?: Array<string>;
    /**
     * default limit price you can use to prefill your order
     * @type {number}
     * @memberof ContractRules
     */
    'limitPrice'?: number;
    /**
     * default stop price you can use to prefill your order
     * @type {number}
     * @memberof ContractRules
     */
    'stopprice'?: number;
    /**
     * if you can preview the order or not with the whatif endpoint
     * @type {boolean}
     * @memberof ContractRules
     */
    'preview'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ContractRules
     */
    'displaySize'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractRules
     */
    'increment'?: string;
}
/**
 * 
 * @export
 * @interface EventsInner
 */
export interface EventsInner {
    /**
     * 
     * @type {string}
     * @memberof EventsInner
     */
    'index_date_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsInner
     */
    'event_type'?: string;
    /**
     * will be different for different event types
     * @type {object}
     * @memberof EventsInner
     */
    'data'?: object;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventsInner
     */
    'conids'?: Array<string>;
    /**
     * for exmple 20180817T040000+0000
     * @type {string}
     * @memberof EventsInner
     */
    'index_date'?: string;
    /**
     * for example RSE
     * @type {string}
     * @memberof EventsInner
     */
    'source'?: string;
    /**
     * for example 11662135
     * @type {string}
     * @memberof EventsInner
     */
    'event_key'?: string;
    /**
     * 
     * @type {object}
     * @memberof EventsInner
     */
    'tooltips'?: object;
    /**
     * 
     * @type {string}
     * @memberof EventsInner
     */
    'status'?: string;
}
/**
 * future contract information
 * @export
 * @interface FuturesInner
 */
export interface FuturesInner {
    /**
     * 
     * @type {string}
     * @memberof FuturesInner
     */
    'symbol'?: string;
    /**
     * conid of the future contract
     * @type {number}
     * @memberof FuturesInner
     */
    'conid'?: number;
    /**
     * 
     * @type {number}
     * @memberof FuturesInner
     */
    'underlyingConid'?: number;
    /**
     * 
     * @type {string}
     * @memberof FuturesInner
     */
    'expirationDate'?: string;
    /**
     * last trading day
     * @type {string}
     * @memberof FuturesInner
     */
    'ltd'?: string;
}
/**
 * 
 * @export
 * @interface FyiDeliveryoptionsDevicePostRequest
 */
export interface FyiDeliveryoptionsDevicePostRequest {
    /**
     * 
     * @type {string}
     * @memberof FyiDeliveryoptionsDevicePostRequest
     */
    'devicename'?: string;
    /**
     * 
     * @type {string}
     * @memberof FyiDeliveryoptionsDevicePostRequest
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FyiDeliveryoptionsDevicePostRequest
     */
    'uiName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FyiDeliveryoptionsDevicePostRequest
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface FyiDeliveryoptionsGet200Response
 */
export interface FyiDeliveryoptionsGet200Response {
    /**
     * Email option is enabled or not 0-off, 1-on.
     * @type {number}
     * @memberof FyiDeliveryoptionsGet200Response
     */
    'M'?: number;
    /**
     * 
     * @type {Array<FyiDeliveryoptionsGet200ResponseEInner>}
     * @memberof FyiDeliveryoptionsGet200Response
     */
    'E'?: Array<FyiDeliveryoptionsGet200ResponseEInner>;
}
/**
 * device
 * @export
 * @interface FyiDeliveryoptionsGet200ResponseEInner
 */
export interface FyiDeliveryoptionsGet200ResponseEInner {
    /**
     * device name
     * @type {string}
     * @memberof FyiDeliveryoptionsGet200ResponseEInner
     */
    'NM'?: string;
    /**
     * device id
     * @type {string}
     * @memberof FyiDeliveryoptionsGet200ResponseEInner
     */
    'I'?: string;
    /**
     * unique device id
     * @type {string}
     * @memberof FyiDeliveryoptionsGet200ResponseEInner
     */
    'UI'?: string;
    /**
     * device is enabled or not 0-true, 1-false.
     * @type {string}
     * @memberof FyiDeliveryoptionsGet200ResponseEInner
     */
    'A'?: string;
}
/**
 * 
 * @export
 * @interface FyiDisclaimerTypecodeGet200Response
 */
export interface FyiDisclaimerTypecodeGet200Response {
    /**
     * disclaimer message
     * @type {string}
     * @memberof FyiDisclaimerTypecodeGet200Response
     */
    'DT'?: string;
    /**
     * fyi code
     * @type {string}
     * @memberof FyiDisclaimerTypecodeGet200Response
     */
    'FC'?: string;
}
/**
 * 
 * @export
 * @interface FyiDisclaimerTypecodePut200Response
 */
export interface FyiDisclaimerTypecodePut200Response {
    /**
     * 
     * @type {number}
     * @memberof FyiDisclaimerTypecodePut200Response
     */
    'T'?: number;
    /**
     * 
     * @type {number}
     * @memberof FyiDisclaimerTypecodePut200Response
     */
    'V'?: number;
}
/**
 * 
 * @export
 * @interface FyiSettingsGet200ResponseInner
 */
export interface FyiSettingsGet200ResponseInner {
    /**
     * optional, if A doesn\'t exist, it means user can\'t toggle this option. 0-off, 1-on.
     * @type {number}
     * @memberof FyiSettingsGet200ResponseInner
     */
    'A'?: number;
    /**
     * fyi code
     * @type {string}
     * @memberof FyiSettingsGet200ResponseInner
     */
    'FC'?: string;
    /**
     * disclaimer read, 1 = yes, = 0 no.
     * @type {number}
     * @memberof FyiSettingsGet200ResponseInner
     */
    'H'?: number;
    /**
     * detailed description
     * @type {string}
     * @memberof FyiSettingsGet200ResponseInner
     */
    'FD'?: string;
    /**
     * title
     * @type {string}
     * @memberof FyiSettingsGet200ResponseInner
     */
    'FN'?: string;
}
/**
 * 
 * @export
 * @interface FyiSettingsTypecodePostRequest
 */
export interface FyiSettingsTypecodePostRequest {
    /**
     * 
     * @type {boolean}
     * @memberof FyiSettingsTypecodePostRequest
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface FyiUnreadnumberGet200Response
 */
export interface FyiUnreadnumberGet200Response {
    /**
     * unread number
     * @type {number}
     * @memberof FyiUnreadnumberGet200Response
     */
    'BN'?: number;
}
/**
 * 
 * @export
 * @interface HistoryData
 */
export interface HistoryData {
    /**
     * Underlying symbol
     * @type {string}
     * @memberof HistoryData
     */
    'symbol'?: string;
    /**
     * companyName
     * @type {string}
     * @memberof HistoryData
     */
    'text'?: string;
    /**
     * priceFactor is price increment obtained from display rule
     * @type {number}
     * @memberof HistoryData
     */
    'priceFactor'?: number;
    /**
     * start date time in the format YYYYMMDD-HH:mm:ss
     * @type {string}
     * @memberof HistoryData
     */
    'startTime'?: string;
    /**
     * High value during this time series with format %h/%v/%t. %h is the high price (scaled by priceFactor), %v is volume (volume factor will always be 100 (reported volume = actual volume/100)) and %t is minutes from start time of the chart 
     * @type {string}
     * @memberof HistoryData
     */
    'high'?: string;
    /**
     * Low value during this time series with format %l/%v/%t. %l is the low price (scaled by priceFactor), %v is volume (volume factor will always be 100 (reported volume = actual volume/100)) and %t is minutes from start time of the chart 
     * @type {string}
     * @memberof HistoryData
     */
    'low'?: string;
    /**
     * The duration for the historical data request
     * @type {string}
     * @memberof HistoryData
     */
    'timePeriod'?: string;
    /**
     * The number of seconds in a bar
     * @type {number}
     * @memberof HistoryData
     */
    'barLength'?: number;
    /**
     * Market Data Availability. The field may contain two chars. The first char is the primary code: S = Streaming, R = Realtime, D = Delayed, Z = Frozen, Y = Frozen Delayed. The second char is the secondary code: P = Snapshot Available, p = Consolidated. 
     * @type {string}
     * @memberof HistoryData
     */
    'mdAvailability'?: string;
    /**
     * The time it takes, in milliseconds, to process the historical data request
     * @type {number}
     * @memberof HistoryData
     */
    'mktDataDelay'?: number;
    /**
     * The historical data returned includes outside of regular trading hours 
     * @type {boolean}
     * @memberof HistoryData
     */
    'outsideRth'?: boolean;
    /**
     * The number of seconds in the trading day
     * @type {number}
     * @memberof HistoryData
     */
    'tradingDayDuration'?: number;
    /**
     * 
     * @type {number}
     * @memberof HistoryData
     */
    'volumeFactor'?: number;
    /**
     * 
     * @type {number}
     * @memberof HistoryData
     */
    'priceDisplayRule'?: number;
    /**
     * 
     * @type {string}
     * @memberof HistoryData
     */
    'priceDisplayValue'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HistoryData
     */
    'negativeCapable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof HistoryData
     */
    'messageVersion'?: number;
    /**
     * 
     * @type {Array<HistoryDataDataInner>}
     * @memberof HistoryData
     */
    'data'?: Array<HistoryDataDataInner>;
    /**
     * total number of points
     * @type {number}
     * @memberof HistoryData
     */
    'points'?: number;
    /**
     * 
     * @type {number}
     * @memberof HistoryData
     */
    'travelTime'?: number;
}
/**
 * 
 * @export
 * @interface HistoryDataDataInner
 */
export interface HistoryDataDataInner {
    /**
     * open price
     * @type {number}
     * @memberof HistoryDataDataInner
     */
    'o'?: number;
    /**
     * close price
     * @type {number}
     * @memberof HistoryDataDataInner
     */
    'c'?: number;
    /**
     * high price
     * @type {number}
     * @memberof HistoryDataDataInner
     */
    'h'?: number;
    /**
     * low price
     * @type {number}
     * @memberof HistoryDataDataInner
     */
    'l'?: number;
    /**
     * volume
     * @type {number}
     * @memberof HistoryDataDataInner
     */
    'v'?: number;
    /**
     * unix time stamp
     * @type {number}
     * @memberof HistoryDataDataInner
     */
    't'?: number;
}
/**
 * 
 * @export
 * @interface HistoryResult
 */
export interface HistoryResult {
    /**
     * 
     * @type {HistoryResultBars}
     * @memberof HistoryResult
     */
    'bars'?: HistoryResultBars;
}
/**
 * 
 * @export
 * @interface HistoryResultBars
 */
export interface HistoryResultBars {
    /**
     * First price returned for bar value.
     * @type {number}
     * @memberof HistoryResultBars
     */
    'open'?: number;
    /**
     * Start Time in the format YYYYMMDD.
     * @type {string}
     * @memberof HistoryResultBars
     */
    'startTime'?: string;
    /**
     * Start Time Value - Formatted in unix time in ms.
     * @type {number}
     * @memberof HistoryResultBars
     */
    'startTimeVal'?: number;
    /**
     * End Time in the format YYYYMMDD.
     * @type {string}
     * @memberof HistoryResultBars
     */
    'endTime'?: string;
    /**
     * End Time Value - Formatted in unix time in ms.
     * @type {number}
     * @memberof HistoryResultBars
     */
    'endTimeVal'?: number;
    /**
     * total number of data points.
     * @type {number}
     * @memberof HistoryResultBars
     */
    'points'?: number;
    /**
     * 
     * @type {Array<HistoryResultBarsDataInner>}
     * @memberof HistoryResultBars
     */
    'data'?: Array<HistoryResultBarsDataInner>;
    /**
     * If 0 then data is returned in real time. Otherwise will return the number of seconds history data is delayed.
     * @type {number}
     * @memberof HistoryResultBars
     */
    'mktDataDelay'?: number;
}
/**
 * 
 * @export
 * @interface HistoryResultBarsDataInner
 */
export interface HistoryResultBarsDataInner {
    /**
     * Time - Formatted in unix time in ms.
     * @type {number}
     * @memberof HistoryResultBarsDataInner
     */
    't'?: number;
    /**
     * Open - First price returned for bar value.
     * @type {number}
     * @memberof HistoryResultBarsDataInner
     */
    'o'?: number;
    /**
     * Close - Last price returned for bar value.
     * @type {number}
     * @memberof HistoryResultBarsDataInner
     */
    'c'?: number;
    /**
     * High - High price returned for bar value.
     * @type {number}
     * @memberof HistoryResultBarsDataInner
     */
    'h'?: number;
    /**
     * Low - Last price returned for bar value.
     * @type {number}
     * @memberof HistoryResultBarsDataInner
     */
    'l'?: number;
    /**
     * Volume - Traded volume for bar value.
     * @type {number}
     * @memberof HistoryResultBarsDataInner
     */
    'v'?: number;
}
/**
 * 
 * @export
 * @interface HmdsScannerPostRequest
 */
export interface HmdsScannerPostRequest {
    /**
     * 
     * @type {string}
     * @memberof HmdsScannerPostRequest
     */
    'instrument'?: string;
    /**
     * 
     * @type {string}
     * @memberof HmdsScannerPostRequest
     */
    'locations'?: string;
    /**
     * 
     * @type {string}
     * @memberof HmdsScannerPostRequest
     */
    'scanCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof HmdsScannerPostRequest
     */
    'secType'?: string;
    /**
     * 
     * @type {Array<HmdsScannerPostRequestFiltersInner>}
     * @memberof HmdsScannerPostRequest
     */
    'filters'?: Array<HmdsScannerPostRequestFiltersInner>;
}
/**
 * 
 * @export
 * @interface HmdsScannerPostRequestFiltersInner
 */
export interface HmdsScannerPostRequestFiltersInner {
    /**
     * 
     * @type {string}
     * @memberof HmdsScannerPostRequestFiltersInner
     */
    'code'?: string;
    /**
     * Value can be either an integer, double, boolean or a string depending upon the type of filter specified in the code section
     * @type {object}
     * @memberof HmdsScannerPostRequestFiltersInner
     */
    'value'?: object;
}
/**
 * 
 * @export
 * @interface IndsInner
 */
export interface IndsInner {
    /**
     * 
     * @type {number}
     * @memberof IndsInner
     */
    'conid'?: number;
}
/**
 * 
 * @export
 * @interface IserverAccountAccountIdAlertActivatePost200Response
 */
export interface IserverAccountAccountIdAlertActivatePost200Response {
    /**
     * 
     * @type {number}
     * @memberof IserverAccountAccountIdAlertActivatePost200Response
     */
    'request_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof IserverAccountAccountIdAlertActivatePost200Response
     */
    'order_id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IserverAccountAccountIdAlertActivatePost200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdAlertActivatePost200Response
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdAlertActivatePost200Response
     */
    'order_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdAlertActivatePost200Response
     */
    'failure_list'?: string;
}
/**
 * 
 * @export
 * @interface IserverAccountAccountIdAlertActivatePostRequest
 */
export interface IserverAccountAccountIdAlertActivatePostRequest {
    /**
     * alert id(order id)
     * @type {number}
     * @memberof IserverAccountAccountIdAlertActivatePostRequest
     */
    'alertId'?: number;
    /**
     * 1 to activate, 0 to deactivate
     * @type {number}
     * @memberof IserverAccountAccountIdAlertActivatePostRequest
     */
    'alertActive'?: number;
}
/**
 * 
 * @export
 * @interface IserverAccountAccountIdAlertPost200Response
 */
export interface IserverAccountAccountIdAlertPost200Response {
    /**
     * 
     * @type {number}
     * @memberof IserverAccountAccountIdAlertPost200Response
     */
    'request_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof IserverAccountAccountIdAlertPost200Response
     */
    'order_id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IserverAccountAccountIdAlertPost200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdAlertPost200Response
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdAlertPost200Response
     */
    'order_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdAlertPost200Response
     */
    'warning_message'?: string;
}
/**
 * 
 * @export
 * @interface IserverAccountAccountIdAlertsGet200ResponseInner
 */
export interface IserverAccountAccountIdAlertsGet200ResponseInner {
    /**
     * 
     * @type {number}
     * @memberof IserverAccountAccountIdAlertsGet200ResponseInner
     */
    'order_id'?: number;
    /**
     * account id
     * @type {string}
     * @memberof IserverAccountAccountIdAlertsGet200ResponseInner
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdAlertsGet200ResponseInner
     */
    'alert_name'?: string;
    /**
     * Value can only be 0 or 1, 1 means active
     * @type {number}
     * @memberof IserverAccountAccountIdAlertsGet200ResponseInner
     */
    'alert_active'?: number;
    /**
     * format, YYYYMMDD-HH:mm:ss, the time when you created the alert 
     * @type {string}
     * @memberof IserverAccountAccountIdAlertsGet200ResponseInner
     */
    'order_time'?: string;
    /**
     * whether the alert has been triggered or not
     * @type {boolean}
     * @memberof IserverAccountAccountIdAlertsGet200ResponseInner
     */
    'alert_triggered'?: boolean;
    /**
     * whether the alert can be repeatable or not, value can be 1 or 0. 1 means true
     * @type {number}
     * @memberof IserverAccountAccountIdAlertsGet200ResponseInner
     */
    'alert_repeatable'?: number;
}
/**
 * 
 * @export
 * @interface IserverAccountAccountIdOrderOrderIdDelete200Response
 */
export interface IserverAccountAccountIdOrderOrderIdDelete200Response {
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdOrderOrderIdDelete200Response
     */
    'order_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdOrderOrderIdDelete200Response
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof IserverAccountAccountIdOrderOrderIdDelete200Response
     */
    'conid'?: number;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdOrderOrderIdDelete200Response
     */
    'account'?: string;
}
/**
 * 
 * @export
 * @interface IserverAccountAccountIdOrderOrderIdPost200ResponseInner
 */
export interface IserverAccountAccountIdOrderOrderIdPost200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdOrderOrderIdPost200ResponseInner
     */
    'order_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdOrderOrderIdPost200ResponseInner
     */
    'local_order_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdOrderOrderIdPost200ResponseInner
     */
    'order_status'?: string;
}
/**
 * 
 * @export
 * @interface IserverAccountAccountIdOrderPost200ResponseInner
 */
export interface IserverAccountAccountIdOrderPost200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdOrderPost200ResponseInner
     */
    'id'?: string;
    /**
     * Please note here, if the message is a question, you have to reply to question in order to submit the order successfully. See more in the \"/iserver/reply/{replyid}\" endpoint. 
     * @type {Array<string>}
     * @memberof IserverAccountAccountIdOrderPost200ResponseInner
     */
    'message'?: Array<string>;
}
/**
 * 
 * @export
 * @interface IserverAccountAccountIdOrderWhatifPost200Response
 */
export interface IserverAccountAccountIdOrderWhatifPost200Response {
    /**
     * 
     * @type {IserverAccountAccountIdOrderWhatifPost200ResponseAmount}
     * @memberof IserverAccountAccountIdOrderWhatifPost200Response
     */
    'amount'?: IserverAccountAccountIdOrderWhatifPost200ResponseAmount;
    /**
     * 
     * @type {IserverAccountAccountIdOrderWhatifPost200ResponseEquity}
     * @memberof IserverAccountAccountIdOrderWhatifPost200Response
     */
    'equity'?: IserverAccountAccountIdOrderWhatifPost200ResponseEquity;
    /**
     * 
     * @type {IserverAccountAccountIdOrderWhatifPost200ResponseEquity}
     * @memberof IserverAccountAccountIdOrderWhatifPost200Response
     */
    'initial'?: IserverAccountAccountIdOrderWhatifPost200ResponseEquity;
    /**
     * 
     * @type {IserverAccountAccountIdOrderWhatifPost200ResponseEquity}
     * @memberof IserverAccountAccountIdOrderWhatifPost200Response
     */
    'maintenance'?: IserverAccountAccountIdOrderWhatifPost200ResponseEquity;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdOrderWhatifPost200Response
     */
    'warn'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdOrderWhatifPost200Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface IserverAccountAccountIdOrderWhatifPost200ResponseAmount
 */
export interface IserverAccountAccountIdOrderWhatifPost200ResponseAmount {
    /**
     * for example 23,000 USD
     * @type {string}
     * @memberof IserverAccountAccountIdOrderWhatifPost200ResponseAmount
     */
    'amount'?: string;
    /**
     * for example 1.1 ... 1.2 USD
     * @type {string}
     * @memberof IserverAccountAccountIdOrderWhatifPost200ResponseAmount
     */
    'commission'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdOrderWhatifPost200ResponseAmount
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface IserverAccountAccountIdOrderWhatifPost200ResponseEquity
 */
export interface IserverAccountAccountIdOrderWhatifPost200ResponseEquity {
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdOrderWhatifPost200ResponseEquity
     */
    'current'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdOrderWhatifPost200ResponseEquity
     */
    'change'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountAccountIdOrderWhatifPost200ResponseEquity
     */
    'after'?: string;
}
/**
 * 
 * @export
 * @interface IserverAccountAccountIdOrdersPostRequest
 */
export interface IserverAccountAccountIdOrdersPostRequest {
    /**
     * Notes for bracket orders: 1. Children orders will not have its own \"cOID\", so please donot pass \"cOID\" parameter in child order.Instead, they will have a \"parentId\" which must be equal to \"cOID\" of parent. 2. When you cancel a parent order, it will cancel all bracket orders, when you cancel one child order, it will also cancel its sibling order. 
     * @type {Array<OrderRequest>}
     * @memberof IserverAccountAccountIdOrdersPostRequest
     */
    'orders'?: Array<OrderRequest>;
}
/**
 * 
 * @export
 * @interface IserverAccountOrdersGet200Response
 */
export interface IserverAccountOrdersGet200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof IserverAccountOrdersGet200Response
     */
    'filters'?: Array<IserverAccountOrdersGet200ResponseFiltersEnum>;
    /**
     * 
     * @type {Array<IserverAccountOrdersGet200ResponseOrdersInner>}
     * @memberof IserverAccountOrdersGet200Response
     */
    'orders'?: Array<IserverAccountOrdersGet200ResponseOrdersInner>;
    /**
     * If live order update is a snapshot
     * @type {boolean}
     * @memberof IserverAccountOrdersGet200Response
     */
    'snapshot'?: boolean;
}

export const IserverAccountOrdersGet200ResponseFiltersEnum = {
    Inactive: 'inactive',
    PendingSubmit: 'pending_submit',
    PreSubmitted: 'pre_submitted',
    Submitted: 'submitted',
    Filled: 'filled',
    PendingCancel: 'pending_cancel',
    Cancelled: 'cancelled',
    WarnState: 'warn_state',
    SortByTime: 'sort_by_time'
} as const;

export type IserverAccountOrdersGet200ResponseFiltersEnum = typeof IserverAccountOrdersGet200ResponseFiltersEnum[keyof typeof IserverAccountOrdersGet200ResponseFiltersEnum];

/**
 * 
 * @export
 * @interface IserverAccountOrdersGet200ResponseOrdersInner
 */
export interface IserverAccountOrdersGet200ResponseOrdersInner {
    /**
     * Account number
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'acct'?: string;
    /**
     * conid and exchange. Format supports conid or conid@exchange
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'conidex'?: string;
    /**
     * Contract identifier
     * @type {number}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'conid'?: number;
    /**
     * Order identifier
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'orderId'?: string;
    /**
     * Cash currency
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'cashCcy'?: string;
    /**
     * Quantity outstanding and total quantity concatenated with forward slash separator
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'sizeAndFills'?: string;
    /**
     * Order description
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'orderDesc'?: string;
    /**
     * Formatted ticker description
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'description1'?: string;
    /**
     * Underlying symbol
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'ticker'?: string;
    /**
     * Asset class
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'secType'?: string;
    /**
     * Listing Exchange
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'listingExchange'?: string;
    /**
     * Quantity remaining
     * @type {number}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'remainingQuantity'?: number;
    /**
     * Quantity filled
     * @type {number}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'filledQuantity'?: number;
    /**
     * Company Name
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'companyName'?: string;
    /**
     * Status of the order
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'status'?: string;
    /**
     * Original order type
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'origOrderType'?: string;
    /**
     * Supports Tax Optimization with 0 for no and 1 for yes
     * @type {number}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'supportsTaxOpt'?: number;
    /**
     * Last status update in format YYMMDDhhmms based in GMT
     * @type {number}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'lastExecutionTime'?: number;
    /**
     * Last status update unix time in ms
     * @type {number}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'lastExecutionTime_r'?: number;
    /**
     * Order type
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'orderType'?: string;
    /**
     * Order reference
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'order_ref'?: string;
    /**
     * The side of the market of the order.  * BUY: Buy contract near posted ask price  * SELL: Sell contract near posted bid price  * ASSN: Option Assignment, if BUYSELL=BUY and OptionType=PUT or BUYSELL=SELL and OptionType=CALL  * EXER: Option Exercise, if BUYSELL=SELL and OptionType=PUT or BUYSELL=BUY and OptionType=CALL 
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'side'?: IserverAccountOrdersGet200ResponseOrdersInnerSideEnum;
    /**
     * Time in force
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'timeInForce'?: string;
    /**
     * Price of order
     * @type {number}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'price'?: number;
    /**
     * Background color in hex format
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'bgColor'?: string;
    /**
     * Foreground color in hex format
     * @type {string}
     * @memberof IserverAccountOrdersGet200ResponseOrdersInner
     */
    'fgColor'?: string;
}

export const IserverAccountOrdersGet200ResponseOrdersInnerSideEnum = {
    Buy: 'BUY',
    Sell: 'SELL',
    Assn: 'ASSN',
    Exer: 'EXER'
} as const;

export type IserverAccountOrdersGet200ResponseOrdersInnerSideEnum = typeof IserverAccountOrdersGet200ResponseOrdersInnerSideEnum[keyof typeof IserverAccountOrdersGet200ResponseOrdersInnerSideEnum];

/**
 * 
 * @export
 * @interface IserverAccountPnlPartitionedGet200Response
 */
export interface IserverAccountPnlPartitionedGet200Response {
    /**
     * 
     * @type {object}
     * @memberof IserverAccountPnlPartitionedGet200Response
     */
    'acctId'?: object;
}
/**
 * 
 * @export
 * @interface IserverAccountPost200Response
 */
export interface IserverAccountPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof IserverAccountPost200Response
     */
    'set'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountPost200Response
     */
    'acctId'?: string;
}
/**
 * 
 * @export
 * @interface IserverAccountsGet200Response
 */
export interface IserverAccountsGet200Response {
    /**
     * Unique account id
     * @type {Array<string>}
     * @memberof IserverAccountsGet200Response
     */
    'accounts'?: Array<string>;
    /**
     * Account Id and its alias
     * @type {object}
     * @memberof IserverAccountsGet200Response
     */
    'aliases'?: object;
    /**
     * 
     * @type {string}
     * @memberof IserverAccountsGet200Response
     */
    'selectedAccount'?: string;
}
/**
 * 
 * @export
 * @interface IserverContractConidAlgosGet200ResponseInner
 */
export interface IserverContractConidAlgosGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof IserverContractConidAlgosGet200ResponseInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverContractConidAlgosGet200ResponseInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverContractConidAlgosGet200ResponseInner
     */
    'id'?: string;
    /**
     * 
     * @type {Array<IserverContractConidAlgosGet200ResponseInnerParametersInner>}
     * @memberof IserverContractConidAlgosGet200ResponseInner
     */
    'parameters'?: Array<IserverContractConidAlgosGet200ResponseInnerParametersInner>;
}
/**
 * 
 * @export
 * @interface IserverContractConidAlgosGet200ResponseInnerParametersInner
 */
export interface IserverContractConidAlgosGet200ResponseInnerParametersInner {
    /**
     * The algo parameter
     * @type {string}
     * @memberof IserverContractConidAlgosGet200ResponseInnerParametersInner
     */
    'id': string;
    /**
     * If true a value must be entered.
     * @type {boolean}
     * @memberof IserverContractConidAlgosGet200ResponseInnerParametersInner
     */
    'required'?: boolean;
    /**
     * Descriptive name of the parameter.
     * @type {string}
     * @memberof IserverContractConidAlgosGet200ResponseInnerParametersInner
     */
    'name'?: string;
    /**
     * Format of the parameter.
     * @type {string}
     * @memberof IserverContractConidAlgosGet200ResponseInnerParametersInner
     */
    'valueClassName': IserverContractConidAlgosGet200ResponseInnerParametersInnerValueClassNameEnum;
    /**
     * Smallest value, only applies to parameters with valueClassName=Double.
     * @type {number}
     * @memberof IserverContractConidAlgosGet200ResponseInnerParametersInner
     */
    'minValue'?: number;
    /**
     * Largest value, only applies to parameters with valueClassName=Double.
     * @type {number}
     * @memberof IserverContractConidAlgosGet200ResponseInnerParametersInner
     */
    'maxValue'?: number;
    /**
     * User configured preset for this parameter.
     * @type {boolean}
     * @memberof IserverContractConidAlgosGet200ResponseInnerParametersInner
     */
    'defaultValue'?: boolean;
    /**
     * The list of choices
     * @type {string}
     * @memberof IserverContractConidAlgosGet200ResponseInnerParametersInner
     */
    'legalStrings'?: string;
    /**
     * Detailed description of the parameter.
     * @type {string}
     * @memberof IserverContractConidAlgosGet200ResponseInnerParametersInner
     */
    'description'?: string;
    /**
     * The order in UI, used when building dynamic UI so that more important parameters are presented first.
     * @type {number}
     * @memberof IserverContractConidAlgosGet200ResponseInnerParametersInner
     */
    'guiRank'?: number;
    /**
     * If true, must specify parameter using market rule format. Only applies to parameters with valueClassName=Double.
     * @type {boolean}
     * @memberof IserverContractConidAlgosGet200ResponseInnerParametersInner
     */
    'priceMarketRule'?: boolean;
    /**
     * The rules that UI should apply to algo parameters depending on chosen order type:  * MKT:speedUp:=:no - hide SpeedUp param when MKT is chosen for order type.  * LMT:strategyType:<>:empty - strategyType param cannot be empty when LMT is chosen for order type.  * MKT:strategyType:=:Marketable - set strategyType param to Marketable and disable (no other choice) when MKT is chosen for order type. 
     * @type {string}
     * @memberof IserverContractConidAlgosGet200ResponseInnerParametersInner
     */
    'enabledConditions'?: IserverContractConidAlgosGet200ResponseInnerParametersInnerEnabledConditionsEnum;
}

export const IserverContractConidAlgosGet200ResponseInnerParametersInnerValueClassNameEnum = {
    Double: 'double',
    String: 'string',
    Time: 'time',
    Boolean: 'boolean'
} as const;

export type IserverContractConidAlgosGet200ResponseInnerParametersInnerValueClassNameEnum = typeof IserverContractConidAlgosGet200ResponseInnerParametersInnerValueClassNameEnum[keyof typeof IserverContractConidAlgosGet200ResponseInnerParametersInnerValueClassNameEnum];
export const IserverContractConidAlgosGet200ResponseInnerParametersInnerEnabledConditionsEnum = {
    MkTspeedUpno: 'MKT:speedUp:=:no',
    LmTstrategyTypeempty: 'LMT:strategyType:<>:empty',
    MkTstrategyTypeMarketable: 'MKT:strategyType:=:Marketable'
} as const;

export type IserverContractConidAlgosGet200ResponseInnerParametersInnerEnabledConditionsEnum = typeof IserverContractConidAlgosGet200ResponseInnerParametersInnerEnabledConditionsEnum[keyof typeof IserverContractConidAlgosGet200ResponseInnerParametersInnerEnabledConditionsEnum];

/**
 * 
 * @export
 * @interface IserverContractConidInfoAndRulesGet200Response
 */
export interface IserverContractConidInfoAndRulesGet200Response {
    /**
     * Classification of Financial Instrument codes
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'cfi_code'?: string;
    /**
     * Underlying symbol
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'cusip'?: string;
    /**
     * Expiration Date in the format YYYYMMDD
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'expiry_full'?: number;
    /**
     * IBKRs contract identifier
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'con_id'?: number;
    /**
     * Date on which the underlying transaction settles if the option is exercised
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'maturity_date'?: number;
    /**
     * Specific group of companies or businesses.
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'industry'?: string;
    /**
     * Asset Class of the contract
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'instrument_type'?: string;
    /**
     * Designation of the contract
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'trading_class'?: string;
    /**
     * Comma separated list of exchanges or trading venues
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'valid_exchanges'?: string;
    /**
     * Allowed to sell shares that you own
     * @type {boolean}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'allow_sell_long'?: boolean;
    /**
     * Supports zero commission trades
     * @type {boolean}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'is_zero_commission_security'?: boolean;
    /**
     * Contracts symbol from primary exchange. For options it is the OCC symbol.
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'local_symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'classifier'?: string;
    /**
     * Currency contract trades in
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'currency'?: string;
    /**
     * Formatted contract parameters
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'text'?: string;
    /**
     * IBKRs contract identifier for the underlying instrument
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'underlying_con_id'?: number;
    /**
     * Provides trading outside of Regular Trading Hours
     * @type {boolean}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'r_t_h'?: boolean;
    /**
     * numerical value of each point of price movement
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'multiplier'?: string;
    /**
     * fixed price at which the owner of the option buys or sells the underlying
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'strike'?: string;
    /**
     * Put or Call of the option
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'right'?: string;
    /**
     * Legal entity for underlying contract
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'underlying_issuer'?: string;
    /**
     * Month the contract must be satisfied by making or accepting delivery
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'contract_month'?: string;
    /**
     * Contracts company name
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'company_name'?: string;
    /**
     * Support IBKRs SMART routing
     * @type {boolean}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'smart_available'?: boolean;
    /**
     * Primary Exchange, Routing or Trading Venue
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'exchange'?: string;
    /**
     * 
     * @type {Array<IserverContractConidInfoAndRulesGet200ResponseRulesInner>}
     * @memberof IserverContractConidInfoAndRulesGet200Response
     */
    'rules'?: Array<IserverContractConidInfoAndRulesGet200ResponseRulesInner>;
}
/**
 * 
 * @export
 * @interface IserverContractConidInfoAndRulesGet200ResponseRulesInner
 */
export interface IserverContractConidInfoAndRulesGet200ResponseRulesInner {
    /**
     * Contract supports algo orders
     * @type {boolean}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'algoEligible'?: boolean;
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerCanTradeAcctIdsInner>}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'canTradeAcctIds'?: Array<IserverContractRulesPost200ResponseRulesInnerCanTradeAcctIdsInner>;
    /**
     * Returns a description on any errors with order presets
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'error'?: string;
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerOrderTypesInner>}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'orderTypes'?: Array<IserverContractRulesPost200ResponseRulesInnerOrderTypesInner>;
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerIbalgoTypesInner>}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'ibalgoTypes'?: Array<IserverContractRulesPost200ResponseRulesInnerIbalgoTypesInner>;
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerFraqTypesInner>}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'fraqTypes'?: Array<IserverContractRulesPost200ResponseRulesInnerFraqTypesInner>;
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerCqtTypesInner>}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'cqtTypes'?: Array<IserverContractRulesPost200ResponseRulesInnerCqtTypesInner>;
    /**
     * If object returned will provide the defaults based on user settings
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInner>}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'orderDefaults'?: Array<IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInner>;
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerOrderTypesOutsideInner>}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'orderTypesOutside'?: Array<IserverContractRulesPost200ResponseRulesInnerOrderTypesOutsideInner>;
    /**
     * Default quantity
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'defaultSize'?: number;
    /**
     * cash value
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'cashSize'?: number;
    /**
     * increment quantity value
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'sizeIncrement'?: number;
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerTifTypesInner>}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'tifTypes'?: Array<IserverContractRulesPost200ResponseRulesInnerTifTypesInner>;
    /**
     * Default time in force value
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'defaultTIF'?: string;
    /**
     * Limit price
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'limitPrice'?: number;
    /**
     * Stop price
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'stopprice'?: number;
    /**
     * Order origin designation for US securities options and Options Clearing Corporation
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'orderOrigination'?: number;
    /**
     * order preview required
     * @type {boolean}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'preview'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'displaySize'?: number;
    /**
     * decimal places for fractional order size
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'fraqInt'?: number;
    /**
     * Cash currency for the contract
     * @type {string}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'cashCcy'?: string;
    /**
     * Increment value for cash quantity
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'cashQtyIncr'?: number;
    /**
     * Price Magnifier
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'priceMagnifier'?: number;
    /**
     * trading negative price support
     * @type {boolean}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'negativeCapable'?: boolean;
    /**
     * Price increment value
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'increment'?: number;
    /**
     * Number of digits for price increment
     * @type {number}
     * @memberof IserverContractConidInfoAndRulesGet200ResponseRulesInner
     */
    'incrementDigits'?: number;
}
/**
 * 
 * @export
 * @interface IserverContractRulesPost200Response
 */
export interface IserverContractRulesPost200Response {
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInner>}
     * @memberof IserverContractRulesPost200Response
     */
    'rules'?: Array<IserverContractRulesPost200ResponseRulesInner>;
}
/**
 * 
 * @export
 * @interface IserverContractRulesPost200ResponseRulesInner
 */
export interface IserverContractRulesPost200ResponseRulesInner {
    /**
     * 
     * @type {boolean}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'algoEligible'?: boolean;
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerCanTradeAcctIdsInner>}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'canTradeAcctIds'?: Array<IserverContractRulesPost200ResponseRulesInnerCanTradeAcctIdsInner>;
    /**
     * Returns a description on any errors with order presets
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'error'?: string;
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerOrderTypesInner>}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'orderTypes'?: Array<IserverContractRulesPost200ResponseRulesInnerOrderTypesInner>;
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerIbalgoTypesInner>}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'ibalgoTypes'?: Array<IserverContractRulesPost200ResponseRulesInnerIbalgoTypesInner>;
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerFraqTypesInner>}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'fraqTypes'?: Array<IserverContractRulesPost200ResponseRulesInnerFraqTypesInner>;
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerCqtTypesInner>}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'cqtTypes'?: Array<IserverContractRulesPost200ResponseRulesInnerCqtTypesInner>;
    /**
     * If object returned will provide the defaults based on user settings
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInner>}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'orderDefaults'?: Array<IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInner>;
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerOrderTypesOutsideInner>}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'orderTypesOutside'?: Array<IserverContractRulesPost200ResponseRulesInnerOrderTypesOutsideInner>;
    /**
     * Default quantity
     * @type {number}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'defaultSize'?: number;
    /**
     * cash value
     * @type {number}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'cashSize'?: number;
    /**
     * increment quantity value
     * @type {number}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'sizeIncrement'?: number;
    /**
     * 
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerTifTypesInner>}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'tifTypes'?: Array<IserverContractRulesPost200ResponseRulesInnerTifTypesInner>;
    /**
     * Default time in force value
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'defaultTIF'?: string;
    /**
     * Limit price
     * @type {number}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'limitPrice'?: number;
    /**
     * Stop price
     * @type {number}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'stopprice'?: number;
    /**
     * Order origin designation for US securities options and Options Clearing Corporation
     * @type {number}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'orderOrigination'?: number;
    /**
     * order preview required
     * @type {boolean}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'preview'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'displaySize'?: number;
    /**
     * decimal places for fractional order size
     * @type {number}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'fraqInt'?: number;
    /**
     * Cash currency for the contract
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'cashCcy'?: string;
    /**
     * Increment value for cash quantity
     * @type {number}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'cashQtyIncr'?: number;
    /**
     * Price Magnifier
     * @type {number}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'priceMagnifier'?: number;
    /**
     * trading negative price support
     * @type {boolean}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'negativeCapable'?: boolean;
    /**
     * Price increment value
     * @type {number}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'increment'?: number;
    /**
     * Number of digits for price increment
     * @type {number}
     * @memberof IserverContractRulesPost200ResponseRulesInner
     */
    'incrementDigits'?: number;
}
/**
 * 
 * @export
 * @interface IserverContractRulesPost200ResponseRulesInnerCanTradeAcctIdsInner
 */
export interface IserverContractRulesPost200ResponseRulesInnerCanTradeAcctIdsInner {
    /**
     * List of Accounts that can be traded
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerCanTradeAcctIdsInner
     */
    '0'?: string;
}
/**
 * 
 * @export
 * @interface IserverContractRulesPost200ResponseRulesInnerCqtTypesInner
 */
export interface IserverContractRulesPost200ResponseRulesInnerCqtTypesInner {
    /**
     * order types that support cash quantity trades
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerCqtTypesInner
     */
    '0'?: string;
}
/**
 * 
 * @export
 * @interface IserverContractRulesPost200ResponseRulesInnerFraqTypesInner
 */
export interface IserverContractRulesPost200ResponseRulesInnerFraqTypesInner {
    /**
     * order types that support fractional trades
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerFraqTypesInner
     */
    '0'?: string;
}
/**
 * 
 * @export
 * @interface IserverContractRulesPost200ResponseRulesInnerIbalgoTypesInner
 */
export interface IserverContractRulesPost200ResponseRulesInnerIbalgoTypesInner {
    /**
     * order types that support IB Algos
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerIbalgoTypesInner
     */
    '0'?: string;
}
/**
 * 
 * @export
 * @interface IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInner
 */
export interface IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInner {
    /**
     * orderType
     * @type {Array<IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInnerStringInner>}
     * @memberof IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInner
     */
    'string'?: Array<IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInnerStringInner>;
}
/**
 * 
 * @export
 * @interface IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInnerStringInner
 */
export interface IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInnerStringInner {
    /**
     * Outside of Regular Trading Hours
     * @type {boolean}
     * @memberof IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInnerStringInner
     */
    'ORTH'?: boolean;
    /**
     * Stop Price value
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInnerStringInner
     */
    'SP'?: string;
    /**
     * Limit Price value
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInnerStringInner
     */
    'LP'?: string;
    /**
     * Price Cap value
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInnerStringInner
     */
    'PC'?: string;
    /**
     * Trailing amount value
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInnerStringInner
     */
    'TA'?: string;
    /**
     * Trailing unit
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInnerStringInner
     */
    'TU'?: string;
    /**
     * Releative offset amount
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInnerStringInner
     */
    'ROA'?: string;
    /**
     * Relative offset percent
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInnerStringInner
     */
    'ROP'?: string;
    /**
     * Touch trigger price
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInnerStringInner
     */
    'TT'?: string;
    /**
     * Use Net Price for Bonds
     * @type {boolean}
     * @memberof IserverContractRulesPost200ResponseRulesInnerOrderDefaultsInnerStringInner
     */
    'UNP'?: boolean;
}
/**
 * 
 * @export
 * @interface IserverContractRulesPost200ResponseRulesInnerOrderTypesInner
 */
export interface IserverContractRulesPost200ResponseRulesInnerOrderTypesInner {
    /**
     * list of available order types
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerOrderTypesInner
     */
    '0'?: string;
}
/**
 * 
 * @export
 * @interface IserverContractRulesPost200ResponseRulesInnerOrderTypesOutsideInner
 */
export interface IserverContractRulesPost200ResponseRulesInnerOrderTypesOutsideInner {
    /**
     * order types that support outside of regular trading hours
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerOrderTypesOutsideInner
     */
    '0'?: string;
}
/**
 * 
 * @export
 * @interface IserverContractRulesPost200ResponseRulesInnerTifTypesInner
 */
export interface IserverContractRulesPost200ResponseRulesInnerTifTypesInner {
    /**
     * Time in Force values, formatted with o for supporting Outside regular trading hours and a for Algo trading
     * @type {string}
     * @memberof IserverContractRulesPost200ResponseRulesInnerTifTypesInner
     */
    '0'?: string;
}
/**
 * 
 * @export
 * @interface IserverContractRulesPostRequest
 */
export interface IserverContractRulesPostRequest {
    /**
     * IBKR contract identifier
     * @type {string}
     * @memberof IserverContractRulesPostRequest
     */
    'conid': string;
    /**
     * Side of the market rules apply too. Set to **true** for Buy Orders, set to **false** for Sell Orders
     * @type {boolean}
     * @memberof IserverContractRulesPostRequest
     */
    'isBuy': boolean;
}
/**
 * 
 * @export
 * @interface IserverMarketdataConidUnsubscribeGet200Response
 */
export interface IserverMarketdataConidUnsubscribeGet200Response {
    /**
     * success means market data was cancelled.
     * @type {string}
     * @memberof IserverMarketdataConidUnsubscribeGet200Response
     */
    'confirmed'?: string;
}
/**
 * 
 * @export
 * @interface IserverMarketdataSnapshotGet200ResponseInner
 */
export interface IserverMarketdataSnapshotGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    'server_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    'conid'?: number;
    /**
     * 
     * @type {number}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '_updated'?: number;
    /**
     * Last Price - The last price at which the contract traded. May contain one of the following prefixes:   * C - Previous day\'s closing price.   * H - Trading has halted. 
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '31'?: string;
    /**
     * Symbol
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '55'?: string;
    /**
     * Text
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '58'?: string;
    /**
     * High - Current day high price
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '70'?: string;
    /**
     * Low - Current day low price
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '71'?: string;
    /**
     * Market Value - The current market value of  your position in the security. Market Value is calculated with real time market data (even when not subscribed to market data).
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '73'?: string;
    /**
     * Avg Price - The average price of the position.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '74'?: string;
    /**
     * Unrealized PnL - Unrealized profit or loss. Unrealized PnL is calculated with real time market data (even when not subscribed to market data).
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '75'?: string;
    /**
     * Formatted position
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '76'?: string;
    /**
     * Formatted Unrealized PnL
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '77'?: string;
    /**
     * Daily PnL - Your profit or loss of the day since prior close. Daily PnL is calculated with real time market data (even when not subscribed to market data).
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '78'?: string;
    /**
     * Realized PnL - Realized profit or loss. Realized PnL is calculated with real time market data (even when not subscribed to market data).
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '79'?: string;
    /**
     * Unrealized PnL % - Unrealized profit or loss expressed in percentage.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '80'?: string;
    /**
     * Change - The difference between the last price and the close on the previous trading day
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '82'?: string;
    /**
     * Change % - The difference between the last price and the close on the previous trading day in percentage.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '83'?: string;
    /**
     * Bid Price - The highest-priced bid on the contract.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '84'?: string;
    /**
     * Ask Size - The number of contracts or shares offered at the ask price. For US stocks, the number displayed is divided by 100.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '85'?: string;
    /**
     * Ask Price - The lowest-priced offer on the contract.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '86'?: string;
    /**
     * Volume - Volume for the day, formatted with \'K\' for thousands or \'M\' for millions. For higher precision volume refer to field 7762.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '87'?: string;
    /**
     * Raw Volume - Volume for the day, provided in long form without formatted with K/M. This field value is deprecated, for high precision volume refer to field 7762.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '87_raw (deprecated)'?: string;
    /**
     * Bid Size - The number of contracts or shares bid for at the bid price. For US stocks, the number displayed is divided by 100.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '88'?: string;
    /**
     * Exchange
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '6004'?: string;
    /**
     * Conid - Contract identifier from IBKR\'s database.
     * @type {number}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '6008'?: number;
    /**
     * SecType - The asset class of the instrument.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '6070'?: string;
    /**
     * Months
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '6072'?: string;
    /**
     * Regular Expiry
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '6073'?: string;
    /**
     * Marker for market data delivery method (similar to request id)
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '6119'?: string;
    /**
     * Underlying Conid. Use /trsrv/secdef to get more information about the security
     * @type {number}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '6457'?: number;
    /**
     * Service Params.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '6508'?: string;
    /**
     * Market Data Availability. The field may contain three chars. First char defines: R = RealTime, D = Delayed, Z = Frozen, Y = Frozen Delayed, N = Not Subscribed. Second char defines: P = Snapshot, p = Consolidated. Third char defines: B = Book   * RealTime - Data is relayed back in real time without delay, market data subscription(s) are required.   * Delayed - Data is relayed back 15-20 min delayed.    * Frozen - Last recorded data at market close, relayed back in real time.   * Frozen Delayed - Last recorded data at market close, relayed back delayed.   * Not Subscribed - User does not have the required market data subscription(s) to relay back either real time or delayed data.   * Snapshot - Snapshot request is available for contract.   * Consolidated - Market data is aggregated across multiple exchanges or venues.   * Book - Top of the book data is available for contract. 
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '6509'?: string;
    /**
     * Company name
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7051'?: string;
    /**
     * Ask Exch - Displays the exchange(s) offering the SMART price. A=AMEX, C=CBOE, I=ISE, X=PHLX, N=PSE, B=BOX, Q=NASDAQOM, Z=BATS, W=CBOE2, T=NASDAQBX, M=MIAX, H=GEMINI, E=EDGX, J=MERCURY 
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7057'?: string;
    /**
     * Last Exch - Displays the exchange(s) offering the SMART price. A=AMEX, C=CBOE, I=ISE, X=PHLX, N=PSE, B=BOX, Q=NASDAQOM, Z=BATS, W=CBOE2, T=NASDAQBX, M=MIAX, H=GEMINI, E=EDGX, J=MERCURY 
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7058'?: string;
    /**
     * Last Size - The number of unites traded at the last price
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7059'?: string;
    /**
     * Bid Exch - Displays the exchange(s) offering the SMART price. A=AMEX, C=CBOE, I=ISE, X=PHLX, N=PSE, B=BOX, Q=NASDAQOM, Z=BATS, W=CBOE2, T=NASDAQBX, M=MIAX, H=GEMINI, E=EDGX, J=MERCURY 
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7068'?: string;
    /**
     * Implied Vol./Hist. Vol % - The ratio of the implied volatility over the historical volatility, expressed as a percentage.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7084'?: string;
    /**
     * Put/Call Interest - Put option open interest/call option open interest for the trading day.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7085'?: string;
    /**
     * Put/Call Volume - Put option volume/call option volume for the trading day.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7086'?: string;
    /**
     * Hist. Vol. % - 30-day real-time historical volatility.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7087'?: string;
    /**
     * Hist. Vol. Close % - Shows the historical volatility based on previous close price.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7088'?: string;
    /**
     * Opt. Volume - Option Volume
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7089'?: string;
    /**
     * Conid + Exchange
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7094'?: string;
    /**
     * canBeTraded - If contract is a trade-able instrument. Returns 1(true) or 0(false).
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7184'?: string;
    /**
     * Contract Description
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7219'?: string;
    /**
     * Contract Description
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7220'?: string;
    /**
     * Listing Exchange
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7221'?: string;
    /**
     * Industry - Displays the type of industry under which the underlying company can be categorized.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7280'?: string;
    /**
     * Category - Displays a more detailed level of description within the industry under which the underlying company can be categorized.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7281'?: string;
    /**
     * Average Volume - The average daily trading volume over 90 days.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7282'?: string;
    /**
     * Option Implied Vol. % - A prediction of how volatile an underlying will be in the future. At the market volatility estimated for a maturity thirty calendar days forward of the current trading day, and based on option prices from two consecutive expiration months. To query the Implied Vol. % of a specific strike refer to field 7633. 
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7283'?: string;
    /**
     * Historic Volume (30d)
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7284'?: string;
    /**
     * Put/Call Ratio
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7285'?: string;
    /**
     * Dividend Amount - Displays the amount of the next dividend.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7286'?: string;
    /**
     * Dividend Yield % - This value is the toal of the expected dividend payments over the next twelve months per share divided by the Current Price and is expressed as a percentage. For derivatives, this displays the total of the expected dividend payments over the expiry date. 
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7287'?: string;
    /**
     * Ex-date of the dividend
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7288'?: string;
    /**
     * Market Cap
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7289'?: string;
    /**
     * P/E
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7290'?: string;
    /**
     * EPS
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7291'?: string;
    /**
     * Cost Basis - Your current position in this security multiplied by the average price and multiplier.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7292'?: string;
    /**
     * 52 Week High - The highest price for the past 52 weeks.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7293'?: string;
    /**
     * 52 Week Low - The lowest price for the past 52 weeks.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7294'?: string;
    /**
     * Open - Today\'s opening price.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7295'?: string;
    /**
     * Close - Today\'s closing price.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7296'?: string;
    /**
     * Delta - The ratio of the change in the price of the option to the corresponding change in the price of the underlying.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7308'?: string;
    /**
     * Gamma - The rate of change for the delta with respect to the underlying asset\'s price.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7309'?: string;
    /**
     * Theta - A measure of the rate of decline the value of an option due to the passage of time.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7310'?: string;
    /**
     * Vega - The amount that the price of an option changes compared to a 1% change in the volatility.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7311'?: string;
    /**
     * Opt. Volume Change % - Today\'s option volume as a percentage of the average option volume.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7607'?: string;
    /**
     * Implied Vol. % - The implied volatility for the specific strike of the option in percentage. To query the Option Implied Vol. % from the underlying refer to field 7283.  
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7633'?: string;
    /**
     * Mark - The mark price is, the ask price if ask is less than last price, the bid price if bid is more than the last price, otherwise it\'s equal to last price.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7635'?: string;
    /**
     * Shortable Shares - Number of shares available for shorting.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7636'?: string;
    /**
     * Fee Rate - Interest rate charged on borrowed shares.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7637'?: string;
    /**
     * Option Open Interest
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7638'?: string;
    /**
     * % of Mark Value - Displays the market value of the contract as a percentage of the total market value of the account. Mark Value is calculated with real time market data (even when not subscribed to market data). 
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7639'?: string;
    /**
     * Shortable - Describes the level of difficulty with which the security can be sold short.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7644'?: string;
    /**
     * Morningstar Rating - Displays Morningstar Rating provided value. Requires [Morningstar](https://www.interactivebrokers.com/en/index.php?f=14262) subscription.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7655'?: string;
    /**
     * Dividends - This value is the total of the expected dividend payments over the next twelve months per share.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7671'?: string;
    /**
     * Dividends TTM - This value is the total of the expected dividend payments over the last twelve months per share.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7672'?: string;
    /**
     * EMA(200) - Exponential moving average (N=200).
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7674'?: string;
    /**
     * EMA(100) - Exponential moving average (N=100).
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7675'?: string;
    /**
     * EMA(50) - Exponential moving average (N=50).
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7676'?: string;
    /**
     * EMA(20) - Exponential moving average (N=20).
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7677'?: string;
    /**
     * Price/EMA(200) - Price to Exponential moving average (N=200) ratio -1, displayed in percents.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7678'?: string;
    /**
     * Price/EMA(100) - Price to Exponential moving average (N=100) ratio -1, displayed in percents.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7679'?: string;
    /**
     * Price/EMA(50) - Price to Exponential moving average (N=50) ratio -1, displayed in percents.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7680'?: string;
    /**
     * Price/EMA(20) - Price to Exponential moving average (N=20) ratio -1, displayed in percents.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7681'?: string;
    /**
     * Change Since Open - The difference between the last price and the open price.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7682'?: string;
    /**
     * Upcoming Event - Shows the next major company event. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7683'?: string;
    /**
     * Upcoming Event Date - The date of the next major company event. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7684'?: string;
    /**
     * Upcoming Analyst Meeting - The date and time of the next scheduled analyst meeting. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7685'?: string;
    /**
     * Upcoming Earnings - The date and time of the next scheduled earnings/earnings call event. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7686'?: string;
    /**
     * Upcoming Misc Event - The date and time of the next shareholder meeting, presentation or other event. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7687'?: string;
    /**
     * Recent Analyst Meeting - The date and time of the most recent analyst meeting. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7688'?: string;
    /**
     * Recent Earnings - The date and time of the most recent earnings/earning call event. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7689'?: string;
    /**
     * Recent Misc Event - The date and time of the most recent shareholder meeting, presentation or other event. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7690'?: string;
    /**
     * Probability of Max Return - Customer implied probability of maximum potential gain.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7694'?: string;
    /**
     * Break Even - Break even points
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7695'?: string;
    /**
     * SPX Delta - Beta Weighted Delta is calculated using the formula; Delta x dollar adjusted beta, where adjusted beta is adjusted by the ratio of the close price.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7696'?: string;
    /**
     * Futures Open Interest - Total number of outstanding futures contracts
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7697'?: string;
    /**
     * Last Yield - Implied yield of the bond if it is purchased at the current last price. Last yield is calculated using the Last price on all possible call dates. It is assumed that prepayment occurs if the bond has call or put provisions and the issuer can offer a lower coupon rate based on current market rates. The yield to worst will be the lowest of the yield to maturity or yield to call (if the bond has prepayment provisions). Yield to worse may be the same as yield to maturity but never higher. 
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7698'?: string;
    /**
     * Bid Yield - Implied yield of the bond if it is purchased at the current bid price. Bid yield is calculated using the Ask on all possible call dates. It is assumed that prepayment occurs if the bond has call or put provisions and the issuer can offer a lower coupon rate based on current market rates. The yield to worst will be the lowest of the yield to maturity or yield to call (if the bond has prepayment provisions). Yield to worse may be the same as yield to maturity but never higher. 
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7699'?: string;
    /**
     * Probability of Max Return - Customer implied probability of maximum potential gain.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7700'?: string;
    /**
     * Probability of Max Loss - Customer implied probability of maximum potential loss.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7702'?: string;
    /**
     * Profit Probability - Customer implied probability of any gain.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7703'?: string;
    /**
     * Organization Type
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7704'?: string;
    /**
     * Debt Class
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7705'?: string;
    /**
     * Ratings - Ratings issued for bond contract.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7706'?: string;
    /**
     * Bond State Code
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7707'?: string;
    /**
     * Bond Type
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7708'?: string;
    /**
     * Last Trading Date
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7714'?: string;
    /**
     * Issue Date
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7715'?: string;
    /**
     * Beta - Beta is against standard index.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7718'?: string;
    /**
     * Ask Yield - Implied yield of the bond if it is purchased at the current offer. Ask yield is calculated using the Bid on all possible call dates. It is assumed that prepayment occurs if the bond has call or put provisions and the issuer can offer a lower coupon rate based on current market rates. The yield to worst will be the lowest of the yield to maturity or yield to call (if the bond has prepayment provisions). Yield to worse may be the same as yield to maturity but never higher. 
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7720'?: string;
    /**
     * Prior Close - Yesterday\'s closing price
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7741'?: string;
    /**
     * Volume Long - High precision volume for the day. For formatted volume refer to field 87.
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7762'?: string;
    /**
     * hasTradingPermissions - if user has trading permissions for specified contract. Returns 1(true) or 0(false).
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet200ResponseInner
     */
    '7768'?: string;
}
/**
 * 
 * @export
 * @interface IserverMarketdataSnapshotGet400Response
 */
export interface IserverMarketdataSnapshotGet400Response {
    /**
     * 
     * @type {string}
     * @memberof IserverMarketdataSnapshotGet400Response
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof IserverMarketdataSnapshotGet400Response
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface IserverMarketdataUnsubscribeallGet200Response
 */
export interface IserverMarketdataUnsubscribeallGet200Response {
    /**
     * true means market data is cancelled, false means it is not.
     * @type {boolean}
     * @memberof IserverMarketdataUnsubscribeallGet200Response
     */
    'confirmed'?: boolean;
}
/**
 * 
 * @export
 * @interface IserverReplyReplyidPost200ResponseInner
 */
export interface IserverReplyReplyidPost200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof IserverReplyReplyidPost200ResponseInner
     */
    'order_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverReplyReplyidPost200ResponseInner
     */
    'order_status'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverReplyReplyidPost200ResponseInner
     */
    'local_order_id'?: string;
}
/**
 * 
 * @export
 * @interface IserverReplyReplyidPost400Response
 */
export interface IserverReplyReplyidPost400Response {
    /**
     * for example-order not confirmed
     * @type {string}
     * @memberof IserverReplyReplyidPost400Response
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof IserverReplyReplyidPost400Response
     */
    'statusCode'?: number;
}
/**
 * 
 * @export
 * @interface IserverReplyReplyidPostRequest
 */
export interface IserverReplyReplyidPostRequest {
    /**
     * answer to question, true means yes, false means no
     * @type {boolean}
     * @memberof IserverReplyReplyidPostRequest
     */
    'confirmed'?: boolean;
}
/**
 * 
 * @export
 * @interface IserverScannerParamsGet200Response
 */
export interface IserverScannerParamsGet200Response {
    /**
     * 
     * @type {Array<IserverScannerParamsGet200ResponseScanTypeListInner>}
     * @memberof IserverScannerParamsGet200Response
     */
    'scan_type_list'?: Array<IserverScannerParamsGet200ResponseScanTypeListInner>;
    /**
     * 
     * @type {Array<IserverScannerParamsGet200ResponseInstrumentListInner>}
     * @memberof IserverScannerParamsGet200Response
     */
    'instrument_list'?: Array<IserverScannerParamsGet200ResponseInstrumentListInner>;
    /**
     * 
     * @type {Array<IserverScannerParamsGet200ResponseFilterListInner>}
     * @memberof IserverScannerParamsGet200Response
     */
    'filter_list'?: Array<IserverScannerParamsGet200ResponseFilterListInner>;
    /**
     * 
     * @type {Array<IserverScannerParamsGet200ResponseLocationTreeInner>}
     * @memberof IserverScannerParamsGet200Response
     */
    'location_tree'?: Array<IserverScannerParamsGet200ResponseLocationTreeInner>;
}
/**
 * 
 * @export
 * @interface IserverScannerParamsGet200ResponseFilterListInner
 */
export interface IserverScannerParamsGet200ResponseFilterListInner {
    /**
     * 
     * @type {string}
     * @memberof IserverScannerParamsGet200ResponseFilterListInner
     */
    'group'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverScannerParamsGet200ResponseFilterListInner
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverScannerParamsGet200ResponseFilterListInner
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverScannerParamsGet200ResponseFilterListInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface IserverScannerParamsGet200ResponseInstrumentListInner
 */
export interface IserverScannerParamsGet200ResponseInstrumentListInner {
    /**
     * 
     * @type {string}
     * @memberof IserverScannerParamsGet200ResponseInstrumentListInner
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverScannerParamsGet200ResponseInstrumentListInner
     */
    'type'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IserverScannerParamsGet200ResponseInstrumentListInner
     */
    'filters'?: Array<string>;
}
/**
 * 
 * @export
 * @interface IserverScannerParamsGet200ResponseLocationTreeInner
 */
export interface IserverScannerParamsGet200ResponseLocationTreeInner {
    /**
     * 
     * @type {string}
     * @memberof IserverScannerParamsGet200ResponseLocationTreeInner
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverScannerParamsGet200ResponseLocationTreeInner
     */
    'type'?: string;
    /**
     * 
     * @type {Array<IserverScannerParamsGet200ResponseLocationTreeInnerLocationsInner>}
     * @memberof IserverScannerParamsGet200ResponseLocationTreeInner
     */
    'locations'?: Array<IserverScannerParamsGet200ResponseLocationTreeInnerLocationsInner>;
}
/**
 * 
 * @export
 * @interface IserverScannerParamsGet200ResponseLocationTreeInnerLocationsInner
 */
export interface IserverScannerParamsGet200ResponseLocationTreeInnerLocationsInner {
    /**
     * 
     * @type {string}
     * @memberof IserverScannerParamsGet200ResponseLocationTreeInnerLocationsInner
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverScannerParamsGet200ResponseLocationTreeInnerLocationsInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface IserverScannerParamsGet200ResponseScanTypeListInner
 */
export interface IserverScannerParamsGet200ResponseScanTypeListInner {
    /**
     * 
     * @type {string}
     * @memberof IserverScannerParamsGet200ResponseScanTypeListInner
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverScannerParamsGet200ResponseScanTypeListInner
     */
    'code'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IserverScannerParamsGet200ResponseScanTypeListInner
     */
    'instruments'?: Array<string>;
}
/**
 * 
 * @export
 * @interface IserverScannerRunPost200ResponseInner
 */
export interface IserverScannerRunPost200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof IserverScannerRunPost200ResponseInner
     */
    'server_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverScannerRunPost200ResponseInner
     */
    'column_name'?: string;
    /**
     * Underlying symbol
     * @type {string}
     * @memberof IserverScannerRunPost200ResponseInner
     */
    'symbol'?: string;
    /**
     * conid and exchange. Format supports conid or conid@exchange
     * @type {string}
     * @memberof IserverScannerRunPost200ResponseInner
     */
    'conidex'?: string;
    /**
     * 
     * @type {number}
     * @memberof IserverScannerRunPost200ResponseInner
     */
    'con_id'?: number;
    /**
     * List of available chart periods
     * @type {string}
     * @memberof IserverScannerRunPost200ResponseInner
     */
    'available_chart_periods'?: string;
    /**
     * Contracts company name
     * @type {string}
     * @memberof IserverScannerRunPost200ResponseInner
     */
    'company_name'?: string;
    /**
     * Format contract name
     * @type {string}
     * @memberof IserverScannerRunPost200ResponseInner
     */
    'contract_description_1'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverScannerRunPost200ResponseInner
     */
    'listing_exchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverScannerRunPost200ResponseInner
     */
    'sec_type'?: string;
}
/**
 * 
 * @export
 * @interface IserverSecdefSearchPost200ResponseInner
 */
export interface IserverSecdefSearchPost200ResponseInner {
    /**
     * Contract Identifier
     * @type {number}
     * @memberof IserverSecdefSearchPost200ResponseInner
     */
    'conid'?: number;
    /**
     * Company Name - Exchange
     * @type {string}
     * @memberof IserverSecdefSearchPost200ResponseInner
     */
    'companyHeader'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverSecdefSearchPost200ResponseInner
     */
    'companyName'?: string;
    /**
     * Underlying symbol
     * @type {string}
     * @memberof IserverSecdefSearchPost200ResponseInner
     */
    'symbol'?: string;
    /**
     * Exchange
     * @type {string}
     * @memberof IserverSecdefSearchPost200ResponseInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof IserverSecdefSearchPost200ResponseInner
     */
    'restricted'?: string;
    /**
     * List of Future Option expirations in YYYMMDD format separated by semicolon
     * @type {string}
     * @memberof IserverSecdefSearchPost200ResponseInner
     */
    'fop'?: string;
    /**
     * List of Option expirations in YYYYMMDD format separated by semicolon
     * @type {string}
     * @memberof IserverSecdefSearchPost200ResponseInner
     */
    'opt'?: string;
    /**
     * List of Warrant expirations in YYYYMMDD format separated by semicolon
     * @type {string}
     * @memberof IserverSecdefSearchPost200ResponseInner
     */
    'war'?: string;
    /**
     * 
     * @type {Array<IserverSecdefSearchPost200ResponseInnerSectionsInner>}
     * @memberof IserverSecdefSearchPost200ResponseInner
     */
    'sections'?: Array<IserverSecdefSearchPost200ResponseInnerSectionsInner>;
}
/**
 * 
 * @export
 * @interface IserverSecdefSearchPost200ResponseInnerSectionsInner
 */
export interface IserverSecdefSearchPost200ResponseInnerSectionsInner {
    /**
     * Asset Class
     * @type {string}
     * @memberof IserverSecdefSearchPost200ResponseInnerSectionsInner
     */
    'secType'?: string;
    /**
     * List of expiration month(s) and year(s) in MMMYY format separated by semicolon
     * @type {string}
     * @memberof IserverSecdefSearchPost200ResponseInnerSectionsInner
     */
    'months'?: string;
    /**
     * Underlying symbol
     * @type {string}
     * @memberof IserverSecdefSearchPost200ResponseInnerSectionsInner
     */
    'symbol'?: string;
    /**
     * Listing Exchange
     * @type {string}
     * @memberof IserverSecdefSearchPost200ResponseInnerSectionsInner
     */
    'exchange'?: string;
    /**
     * For combo\'s defines the asset class for each leg
     * @type {string}
     * @memberof IserverSecdefSearchPost200ResponseInnerSectionsInner
     */
    'legSecType'?: string;
}
/**
 * 
 * @export
 * @interface IserverSecdefSearchPostRequest
 */
export interface IserverSecdefSearchPostRequest {
    /**
     * symbol or name to be searched
     * @type {string}
     * @memberof IserverSecdefSearchPostRequest
     */
    'symbol': string;
    /**
     * should be true if the search is to be performed by name. false by default.
     * @type {boolean}
     * @memberof IserverSecdefSearchPostRequest
     */
    'name'?: boolean;
    /**
     * If search is done by name, only the assets provided in this field will be returned. Currently, only STK is supported.
     * @type {string}
     * @memberof IserverSecdefSearchPostRequest
     */
    'secType'?: string;
}
/**
 * 
 * @export
 * @interface IserverSecdefStrikesGet200Response
 */
export interface IserverSecdefStrikesGet200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof IserverSecdefStrikesGet200Response
     */
    'call'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IserverSecdefStrikesGet200Response
     */
    'put'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Ledger
 */
export interface Ledger {
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'commoditymarketvalue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'futuremarketvalue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'settledcash'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'exchangerate'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'sessionid'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'cashbalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'corporatebondsmarketvalue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'warrantsmarketvalue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'netliquidationvalue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'interest'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'unrealizedpnl'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'stockmarketvalue'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'moneyfunds'?: number;
    /**
     * 
     * @type {string}
     * @memberof Ledger
     */
    'currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'realizedpnl'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'funds'?: number;
    /**
     * 
     * @type {string}
     * @memberof Ledger
     */
    'acctcode'?: string;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'issueroptionsmarketvalue'?: number;
    /**
     * 
     * @type {string}
     * @memberof Ledger
     */
    'key'?: string;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'timestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof Ledger
     */
    'severity'?: number;
}
/**
 * 
 * @export
 * @interface LogoutPost200Response
 */
export interface LogoutPost200Response {
    /**
     * true means username is still logged in, false means it is not
     * @type {boolean}
     * @memberof LogoutPost200Response
     */
    'confirmed'?: boolean;
}
/**
 * 
 * @export
 * @interface MarketData
 */
export interface MarketData {
    /**
     * Last Price - The last price at which the contract traded. May contain one of the following prefixes:   * C - Previous day\'s closing price.   * H - Trading has halted. 
     * @type {string}
     * @memberof MarketData
     */
    '31'?: string;
    /**
     * High - Current day high price
     * @type {number}
     * @memberof MarketData
     */
    '70'?: number;
    /**
     * Low - Current day low price
     * @type {number}
     * @memberof MarketData
     */
    '71'?: number;
    /**
     * Change - The difference between the last price and the close on the previous trading day
     * @type {string}
     * @memberof MarketData
     */
    '82'?: string;
    /**
     * Change % - The difference between the last price and the close on the previous trading day in percentage.
     * @type {number}
     * @memberof MarketData
     */
    '83'?: number;
    /**
     * Bid Price - The highest-priced bid on the contract.
     * @type {string}
     * @memberof MarketData
     */
    '84'?: string;
    /**
     * Ask Size - The number of contracts or shares offered at the ask price. For US stocks, the number displayed is divided by 100.
     * @type {string}
     * @memberof MarketData
     */
    '85'?: string;
    /**
     * Ask Price - The lowest-priced offer on the contract.
     * @type {string}
     * @memberof MarketData
     */
    '86'?: string;
    /**
     * Volume - Volume for the day, formatted with \'K\' for thousands or \'M\' for millions. For higher precision volume refer to field 7762.
     * @type {string}
     * @memberof MarketData
     */
    '87'?: string;
    /**
     * Bid Size - The number of contracts or shares bid for at the bid price. For US stocks, the number displayed is divided by 100.
     * @type {string}
     * @memberof MarketData
     */
    '88'?: string;
    /**
     * Market Data Availability. The field may contain three chars. First char defines: R = RealTime, D = Delayed, Z = Frozen, Y = Frozen Delayed, N = Not Subscribed. Second char defines: P = Snapshot, p = Consolidated. Third char defines: B = Book   * RealTime - Data is relayed back in real time without delay, market data subscription(s) are required.   * Delayed - Data is relayed back 15-20 min delayed.   * Frozen - Last recorded data at market close, relayed back in real time.   * Frozen Delayed - Last recorded data at market close, relayed back delayed.   * Not Subscribed - User does not have the required market data subscription(s) to relay back either real time or delayed data.   * Snapshot - Snapshot request is available for contract.   * Consolidated - Market data is aggregated across multiple exchanges or venues.   * Book - Top of the book data is available for contract. 
     * @type {string}
     * @memberof MarketData
     */
    '6509'?: string;
    /**
     * Ask Exch - Displays the exchange(s) offering the SMART price. A=AMEX, C=CBOE, I=ISE, X=PHLX, N=PSE, B=BOX, Q=NASDAQOM, Z=BATS, W=CBOE2, T=NASDAQBX, M=MIAX, H=GEMINI, E=EDGX, J=MERCURY
     * @type {string}
     * @memberof MarketData
     */
    '7057'?: string;
    /**
     * Last Exch - Displays the exchange(s) offering the SMART price. A=AMEX, C=CBOE, I=ISE, X=PHLX, N=PSE, B=BOX, Q=NASDAQOM, Z=BATS, W=CBOE2, T=NASDAQBX, M=MIAX, H=GEMINI, E=EDGX, J=MERCURY
     * @type {string}
     * @memberof MarketData
     */
    '7058'?: string;
    /**
     * Last Size - The number of unites traded at the last price
     * @type {number}
     * @memberof MarketData
     */
    '7059'?: number;
    /**
     * Bid Exch - Displays the exchange(s) offering the SMART price. A=AMEX, C=CBOE, I=ISE, X=PHLX, N=PSE, B=BOX, Q=NASDAQOM, Z=BATS, W=CBOE2, T=NASDAQBX, M=MIAX, H=GEMINI, E=EDGX, J=MERCURY
     * @type {string}
     * @memberof MarketData
     */
    '7068'?: string;
    /**
     * IV Rank
     * @type {string}
     * @memberof MarketData
     */
    '7195'?: string;
    /**
     * IV Rank
     * @type {string}
     * @memberof MarketData
     */
    '7196'?: string;
    /**
     * IV Rank
     * @type {string}
     * @memberof MarketData
     */
    '7197'?: string;
    /**
     * IV Percentile
     * @type {string}
     * @memberof MarketData
     */
    '7198'?: string;
    /**
     * IV Percentile
     * @type {string}
     * @memberof MarketData
     */
    '7199'?: string;
    /**
     * IV Percentile
     * @type {string}
     * @memberof MarketData
     */
    '7200'?: string;
    /**
     * IV High Low
     * @type {string}
     * @memberof MarketData
     */
    '7201'?: string;
    /**
     * IV High Low
     * @type {string}
     * @memberof MarketData
     */
    '7202'?: string;
    /**
     * IV High Low
     * @type {string}
     * @memberof MarketData
     */
    '7203'?: string;
    /**
     * IV High Low
     * @type {string}
     * @memberof MarketData
     */
    '7204'?: string;
    /**
     * IV High Low
     * @type {string}
     * @memberof MarketData
     */
    '7205'?: string;
    /**
     * IV High Low
     * @type {string}
     * @memberof MarketData
     */
    '7206'?: string;
    /**
     * HV Rank
     * @type {string}
     * @memberof MarketData
     */
    '7207'?: string;
    /**
     * HV Rank
     * @type {string}
     * @memberof MarketData
     */
    '7208'?: string;
    /**
     * HV Rank
     * @type {string}
     * @memberof MarketData
     */
    '7209'?: string;
    /**
     * HV Percentile
     * @type {string}
     * @memberof MarketData
     */
    '7210'?: string;
    /**
     * HV Percentile
     * @type {string}
     * @memberof MarketData
     */
    '7211'?: string;
    /**
     * HV Percentile
     * @type {string}
     * @memberof MarketData
     */
    '7212'?: string;
    /**
     * HV High Low
     * @type {string}
     * @memberof MarketData
     */
    '7245'?: string;
    /**
     * HV High Low
     * @type {string}
     * @memberof MarketData
     */
    '7246'?: string;
    /**
     * HV High Low
     * @type {string}
     * @memberof MarketData
     */
    '7247'?: string;
    /**
     * HV High Low
     * @type {string}
     * @memberof MarketData
     */
    '7248'?: string;
    /**
     * HV High Low
     * @type {string}
     * @memberof MarketData
     */
    '7249'?: string;
    /**
     * HV High Low
     * @type {string}
     * @memberof MarketData
     */
    '7263'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7264'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7265'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7266'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7267'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7268'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7269'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7271'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7272'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7273'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7274'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7275'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7276'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7277'?: string;
    /**
     * Average Volume - The average daily trading volume over 90 days.
     * @type {string}
     * @memberof MarketData
     */
    '7282'?: string;
    /**
     * Option Implied Vol. % - A prediction of how volatile an underlying will be in the future. At the market volatility estimated for a maturity thirty calendar days forward of the current trading day, and based on option prices from two consecutive expiration months.      
     * @type {string}
     * @memberof MarketData
     */
    '7283'?: string;
    /**
     * Historic Volume (30d)
     * @type {string}
     * @memberof MarketData
     */
    '7284'?: string;
    /**
     * Dividend Amount - Displays the amount of the next dividend.
     * @type {number}
     * @memberof MarketData
     */
    '7286'?: number;
    /**
     * Dividend Yield % - This value is the toal of the expected dividend payments over the next twelve months per share divided by the Current Price and is expressed as a percentage. For derivatives, this displays the total of the expected dividend payments over the expiry date. 
     * @type {string}
     * @memberof MarketData
     */
    '7287'?: string;
    /**
     * Ex-date of the dividend
     * @type {string}
     * @memberof MarketData
     */
    '7288'?: string;
    /**
     * Market Cap
     * @type {string}
     * @memberof MarketData
     */
    '7289'?: string;
    /**
     * P/E
     * @type {string}
     * @memberof MarketData
     */
    '7290'?: string;
    /**
     * 52 Week High - The highest price for the past 52 weeks.
     * @type {string}
     * @memberof MarketData
     */
    '7293'?: string;
    /**
     * 52 Week Low - The lowest price for the past 52 weeks.
     * @type {string}
     * @memberof MarketData
     */
    '7294'?: string;
    /**
     * Open - Today\'s opening price.
     * @type {number}
     * @memberof MarketData
     */
    '7295'?: number;
    /**
     * Close - Today\'s closing price.
     * @type {number}
     * @memberof MarketData
     */
    '7296'?: number;
    /**
     * Reuters Fundamentals
     * @type {string}
     * @memberof MarketData
     */
    '7331'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7370'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7371'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7372'?: string;
    /**
     * Mark - The mark price is, the ask price if ask is less than last price, the bid price if bid is more than the last price, otherwise it\'s equal to last price
     * @type {string}
     * @memberof MarketData
     */
    '7635'?: string;
    /**
     * shortable invetory
     * @type {number}
     * @memberof MarketData
     */
    '7636'?: number;
    /**
     * Fee rebate rate
     * @type {string}
     * @memberof MarketData
     */
    '7637'?: string;
    /**
     * Shortable - Describes the level of difficulty with which the security can be sold short.
     * @type {string}
     * @memberof MarketData
     */
    '7644'?: string;
    /**
     * EMA(200) - Exponential moving average (N=200).
     * @type {string}
     * @memberof MarketData
     */
    '7674'?: string;
    /**
     * EMA(100) - Exponential moving average (N=100).
     * @type {string}
     * @memberof MarketData
     */
    '7675'?: string;
    /**
     * EMA(50) - Exponential moving average (N=50).
     * @type {string}
     * @memberof MarketData
     */
    '7676'?: string;
    /**
     * EMA(20) - Exponential moving average (N=20).
     * @type {string}
     * @memberof MarketData
     */
    '7677'?: string;
    /**
     * Price/EMA(20) - Price to Exponential moving average (N=20) ratio -1, displayed in percents.
     * @type {string}
     * @memberof MarketData
     */
    '7681'?: string;
    /**
     * Last Yield - Implied yield of the bond if it is purchased at the current last price. Last yield is calculated using the Last price on all possible call dates. It is assumed that prepayment occurs if the bond has call or put provisions and the issuer can offer a lower coupon rate based on current market rates. The yield to worst will be the lowest of the yield to maturity or yield to call (if the bond has prepayment provisions). Yield to worse may be the same as yield to maturity but never higher. 
     * @type {string}
     * @memberof MarketData
     */
    '7698'?: string;
    /**
     * Bid Yield - Implied yield of the bond if it is purchased at the current bid price. Bid yield is calculated using the Ask on all possible call dates. It is assumed that prepayment occurs if the bond has call or put provisions and the issuer can offer a lower coupon rate based on current market rates. The yield to worst will be the lowest of the yield to maturity or yield to call (if the bond has prepayment provisions). Yield to worse may be the same as yield to maturity but never higher. 
     * @type {string}
     * @memberof MarketData
     */
    '7699'?: string;
    /**
     * Beta - Beta is against standard index.
     * @type {string}
     * @memberof MarketData
     */
    '7718'?: string;
    /**
     * Ask Yield - Implied yield of the bond if it is purchased at the current offer. Ask yield is calculated using the Bid on all possible call dates. It is assumed that prepayment occurs if the bond has call or put provisions and the issuer can offer a lower coupon rate based on current market rates. The yield to worst will be the lowest of the yield to maturity or yield to call (if the bond has prepayment provisions). Yield to worse may be the same as yield to maturity but never higher. 
     * @type {string}
     * @memberof MarketData
     */
    '7720'?: string;
    /**
     * Reuters Fundamentals
     * @type {string}
     * @memberof MarketData
     */
    '7743'?: string;
    /**
     * ESG
     * @type {string}
     * @memberof MarketData
     */
    '7761'?: string;
    /**
     * 26 Week High - The highest price for the past 26 weeks.
     * @type {string}
     * @memberof MarketData
     */
    '7992'?: string;
    /**
     * 26 Week Low - The lowest price for the past 26 weeks.
     * @type {string}
     * @memberof MarketData
     */
    '7993'?: string;
    /**
     * 13 Week High - The highest price for the past 13 weeks.
     * @type {string}
     * @memberof MarketData
     */
    '7994'?: string;
    /**
     * 13 Week Low - The lowest price for the past 13 weeks.
     * @type {string}
     * @memberof MarketData
     */
    '7995'?: string;
    /**
     * IBKR Contract identifier
     * @type {number}
     * @memberof MarketData
     */
    'conid'?: number;
    /**
     * minimum price increment
     * @type {number}
     * @memberof MarketData
     */
    'minTick'?: number;
    /**
     * Color for Best Bid/Offer Exchange in hex code
     * @type {string}
     * @memberof MarketData
     */
    'BboExchange'?: string;
    /**
     * If market data field values return delayed
     * @type {boolean}
     * @memberof MarketData
     */
    'HasDelayed'?: boolean;
    /**
     * minimum size increment
     * @type {number}
     * @memberof MarketData
     */
    'sizeMinTick'?: number;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    'BestEligible'?: number;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    'BestBidExch'?: number;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    'BestAskExch'?: number;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    'PreOpenBid'?: number;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    'LastAttribs'?: number;
    /**
     * Base time stamp for last update in format YYYYMMDD
     * @type {number}
     * @memberof MarketData
     */
    'TimestampBase'?: number;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    'TimestampDelta'?: number;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    'LastExch'?: number;
    /**
     * 
     * @type {number}
     * @memberof MarketData
     */
    'CloseAttribs'?: number;
}
/**
 * 
 * @export
 * @interface ModifyOrder
 */
export interface ModifyOrder {
    /**
     * 
     * @type {string}
     * @memberof ModifyOrder
     */
    'acctId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModifyOrder
     */
    'conid'?: number;
    /**
     * for example LMT
     * @type {string}
     * @memberof ModifyOrder
     */
    'orderType'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModifyOrder
     */
    'outsideRTH'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModifyOrder
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModifyOrder
     */
    'auxPrice'?: number;
    /**
     * SELL or BUY
     * @type {string}
     * @memberof ModifyOrder
     */
    'side'?: string;
    /**
     * optional, not required
     * @type {string}
     * @memberof ModifyOrder
     */
    'listingExchange'?: string;
    /**
     * The ticker symbol of the original place order
     * @type {string}
     * @memberof ModifyOrder
     */
    'ticker'?: string;
    /**
     * Specify a time in force to change how long your order will continue to work in the market
     * @type {string}
     * @memberof ModifyOrder
     */
    'tif'?: string;
    /**
     * usually integer, for some special cases can be float numbers
     * @type {number}
     * @memberof ModifyOrder
     */
    'quantity'?: number;
    /**
     * Set to true if you want to pause a working order. For details refer to the [TWS Users\' Guide:](https://guides.interactivebrokers.com/tws/twsguide.html#usersguidebook/getstarted/pause_execution.htm) 
     * @type {boolean}
     * @memberof ModifyOrder
     */
    'deactivated'?: boolean;
}
/**
 * notification
 * @export
 * @interface NotificationsInner
 */
export interface NotificationsInner {
    /**
     * notification date
     * @type {string}
     * @memberof NotificationsInner
     */
    'D'?: string;
    /**
     * unique way to reference this notification
     * @type {string}
     * @memberof NotificationsInner
     */
    'ID'?: string;
    /**
     * FYI code, we can use it to find whether the disclaimer is accepted or not in settings
     * @type {string}
     * @memberof NotificationsInner
     */
    'FC'?: string;
    /**
     * content of notification
     * @type {string}
     * @memberof NotificationsInner
     */
    'MD'?: string;
    /**
     * title of notification
     * @type {string}
     * @memberof NotificationsInner
     */
    'MS'?: string;
    /**
     * 0-unread, 1-read
     * @type {string}
     * @memberof NotificationsInner
     */
    'R'?: string;
}
/**
 * contains all the order related info
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * account id
     * @type {string}
     * @memberof Order
     */
    'acct'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'conid'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'orderDesc'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'description1'?: string;
    /**
     * for example FB
     * @type {string}
     * @memberof Order
     */
    'ticker'?: string;
    /**
     * for example STK
     * @type {string}
     * @memberof Order
     */
    'secType'?: string;
    /**
     * for example NASDAQ.NMS
     * @type {string}
     * @memberof Order
     */
    'listingExchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'remainingQuantity'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'filledQuantity'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'companyName'?: string;
    /**
     * * PendingSubmit - Indicates the order was sent, but confirmation has not been received that it has been received by the destination.                   Occurs most commonly if an exchange is closed. * PendingCancel - Indicates that a request has been sent to cancel an order but confirmation has not been received of its cancellation. * PreSubmitted - Indicates that a simulated order type has been accepted by the IBKR system and that this order has yet to be elected.                  The order is held in the IBKR system until the election criteria are met. At that time the order is transmitted to the order destination as specified. * Submitted - Indicates that the order has been accepted at the order destination and is working. * Cancelled - Indicates that the balance of the order has been confirmed cancelled by the IB system.               This could occur unexpectedly when IB or the destination has rejected the order. * Filled - Indicates that the order has been completely filled. * Inactive - Indicates the order is not working, for instance if the order was invalid and triggered an error message,              or if the order was to short a security and shares have not yet been located. 
     * @type {string}
     * @memberof Order
     */
    'status'?: string;
    /**
     * for example Limit
     * @type {string}
     * @memberof Order
     */
    'origOrderType'?: string;
    /**
     * BUY or SELL
     * @type {string}
     * @memberof Order
     */
    'side'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'price'?: number;
    /**
     * back-ground color
     * @type {string}
     * @memberof Order
     */
    'bgColor'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'fgColor'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'orderId'?: number;
    /**
     * Only exists in child order of bracket
     * @type {number}
     * @memberof Order
     */
    'parentId'?: number;
    /**
     * User defined string used to identify the order. Value is set using \"cOID\" field while placing an order.
     * @type {string}
     * @memberof Order
     */
    'order_ref'?: string;
}
/**
 * 
 * @export
 * @interface OrderData
 */
export interface OrderData {
    /**
     * 
     * @type {string}
     * @memberof OrderData
     */
    'clientOrderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderData
     */
    'execId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderData
     */
    'execType'?: OrderDataExecTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderData
     */
    'orderType'?: OrderDataOrderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderData
     */
    'orderStatus'?: OrderDataOrderStatusEnum;
    /**
     * Underlying symbol for contract
     * @type {string}
     * @memberof OrderData
     */
    'symbol'?: string;
    /**
     * Quantity of active order
     * @type {string}
     * @memberof OrderData
     */
    'orderQty'?: string;
    /**
     * Price of active order
     * @type {string}
     * @memberof OrderData
     */
    'price'?: string;
    /**
     * Quantity of the last partial fill
     * @type {string}
     * @memberof OrderData
     */
    'lastShares'?: string;
    /**
     * Price of the last partial fill
     * @type {string}
     * @memberof OrderData
     */
    'lastPrice'?: string;
    /**
     * Cumulative fill quantity
     * @type {string}
     * @memberof OrderData
     */
    'cumQty'?: string;
    /**
     * Remaining quantity to be filled
     * @type {string}
     * @memberof OrderData
     */
    'leavesQty'?: string;
    /**
     * Average fill price
     * @type {string}
     * @memberof OrderData
     */
    'avgPrice'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderData
     */
    'side'?: OrderDataSideEnum;
    /**
     * Order identifier
     * @type {string}
     * @memberof OrderData
     */
    'orderId'?: string;
    /**
     * Account number
     * @type {string}
     * @memberof OrderData
     */
    'account'?: string;
    /**
     * Contracts asset class
     * @type {string}
     * @memberof OrderData
     */
    'secType'?: OrderDataSecTypeEnum;
    /**
     * Time of transaction in GMT, format YYYYMMDD-hh:m:ss
     * @type {string}
     * @memberof OrderData
     */
    'txTime'?: string;
    /**
     * Time of receipt in GMT, format YYYYMMDD-hh:mm:ss
     * @type {string}
     * @memberof OrderData
     */
    'rcptTime'?: string;
    /**
     * Time in Force
     * @type {string}
     * @memberof OrderData
     */
    'tif'?: OrderDataTifEnum;
    /**
     * Contract identifier from IBKR\'s database.
     * @type {string}
     * @memberof OrderData
     */
    'conid'?: string;
    /**
     * Trading currency
     * @type {string}
     * @memberof OrderData
     */
    'currency'?: string;
    /**
     * Exchange or venue
     * @type {string}
     * @memberof OrderData
     */
    'exchange'?: string;
    /**
     * Listing Exchange
     * @type {string}
     * @memberof OrderData
     */
    'listingExchange'?: string;
    /**
     * error message
     * @type {number}
     * @memberof OrderData
     */
    'text'?: number;
    /**
     * 
     * @type {OrderDataWarnings}
     * @memberof OrderData
     */
    'warnings'?: OrderDataWarnings;
    /**
     * Commission currency
     * @type {string}
     * @memberof OrderData
     */
    'commCurr'?: string;
    /**
     * Commissions
     * @type {string}
     * @memberof OrderData
     */
    'comms'?: string;
    /**
     * Realized PnL
     * @type {string}
     * @memberof OrderData
     */
    'realizedPnl'?: string;
}

export const OrderDataExecTypeEnum = {
    _1Invalid: '-1 \"Invalid\"',
    _0New: '0 \"New\"',
    _1PartiallyFilled: '1 \"Partially Filled\"',
    _2Filled: '2 \"Filled\"',
    _3DoneForTheDay: '3 \"Done for the Day\"',
    _4Canceled: '4 \"Canceled\"',
    _5Replaced: '5 \"Replaced\"',
    _6PendingCancel: '6 \"Pending Cancel\"',
    _7Stopped: '7 \"Stopped\"',
    _8Rejected: '8 \"Rejected\"',
    _9Suspended: '9 \"Suspended\"',
    APendingNew: 'A \"Pending New\"',
    BCalculated: 'B \"Calculated\"',
    CExpired: 'C \"Expired\"',
    DRestated: 'D \"Restated\"',
    EPendingReplace: 'E \"Pending Replace\"',
    FTrade: 'F \"Trade\"',
    GTradeCorrect: 'G \"Trade Correct\"',
    HTradeCancel: 'H \"Trade Cancel\"',
    IOrderStatus: 'I \"Order Status\"'
} as const;

export type OrderDataExecTypeEnum = typeof OrderDataExecTypeEnum[keyof typeof OrderDataExecTypeEnum];
export const OrderDataOrderTypeEnum = {
    _1Market: '1 \"Market\"',
    _2Limit: '2 \"Limit\"',
    _3Stop: '3 \"Stop\"',
    _4StopLimit: '4 \"Stop Limit\"',
    _5MarketOnClose: '5 \"Market on Close\"',
    _6WithOrWithout: '6 \"With or Without\"',
    _7LimitOrBetter: '7 \"Limit or Better\"',
    _8LimitWithOrWithout: '8 \"Limit With or Without\"',
    _9OnBasis: '9 \"On Basis\"',
    AOnClose: 'A \"On Close\"',
    BLimitOnClose: 'B \"Limit On Close\"',
    CForexMarket: 'C \"Forex Market\"',
    DPreviouslyQuoted: 'D \"Previously Quoted\"',
    EPreviouslyIndicated: 'E \"Previously Indicated\"',
    FForexLimit: 'F \"Forex Limit\"',
    GForexSwap: 'G \"Forex Swap\"',
    HForexPreviouslyQuoted: 'H \"Forex Previously Quoted\"',
    IFunari: 'I \"Funari\"',
    KMarketToLimit: 'K \"Market To Limit\"',
    PPegged: 'P \"Pegged\"'
} as const;

export type OrderDataOrderTypeEnum = typeof OrderDataOrderTypeEnum[keyof typeof OrderDataOrderTypeEnum];
export const OrderDataOrderStatusEnum = {
    _1InvalidOrderStatus: '-1 \"Invalid Order Status\"',
    _0New: '0 \"New\"',
    _1PartiallyFilled: '1 \"Partially Filled\"',
    _2Filled: '2 \"Filled\"',
    _3DoneForTheDay: '3 \"Done for the Day\"',
    _4Canceled: '4 \"Canceled\"',
    _5Replaced: '5 \"Replaced\"',
    _6PendingCancel: '6 \"Pending Cancel\"',
    _7Stopped: '7 \"Stopped\"',
    _8Rejected: '8 \"Rejected\"',
    _9Suspended: '9 \"Suspended\"',
    APendingNew: 'A \"Pending New\"',
    BCalculated: 'B \"Calculated\"',
    CExpired: 'C \"Expired\"',
    DRestated: 'D \"Restated\"',
    EPendingReplace: 'E \"Pending Replace\"'
} as const;

export type OrderDataOrderStatusEnum = typeof OrderDataOrderStatusEnum[keyof typeof OrderDataOrderStatusEnum];
export const OrderDataSideEnum = {
    _1Buy: '1 \"Buy\"',
    _2Sell: '2 \"Sell\"',
    _3BuyMinus: '3 \"Buy Minus\"',
    _4SellPlus: '4 \"Sell Plus\"',
    _5SellShort: '5 \"Sell Short\"',
    _6SellShortExempt: '6 \"Sell Short Exempt\"'
} as const;

export type OrderDataSideEnum = typeof OrderDataSideEnum[keyof typeof OrderDataSideEnum];
export const OrderDataSecTypeEnum = {
    CsStock: 'CS \"Stock\"',
    CashForex: 'CASH \"Forex\"',
    CfdContractForDifference: 'CFD \"Contract for Difference\"',
    FutFuture: 'FUT \"Future\"',
    OptOption: 'OPT \"Option\"'
} as const;

export type OrderDataSecTypeEnum = typeof OrderDataSecTypeEnum[keyof typeof OrderDataSecTypeEnum];
export const OrderDataTifEnum = {
    _0Day: '0 \"Day\"',
    _1Gtc: '1 \"GTC\"',
    _2AtTheOpening: '2 \"At the Opening\"'
} as const;

export type OrderDataTifEnum = typeof OrderDataTifEnum[keyof typeof OrderDataTifEnum];

/**
 * 
 * @export
 * @interface OrderDataWarnings
 */
export interface OrderDataWarnings {
    /**
     * 
     * @type {string}
     * @memberof OrderDataWarnings
     */
    'PRICECAP'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDataWarnings
     */
    'TIME'?: string;
}
/**
 * 
 * @export
 * @interface OrderRequest
 */
export interface OrderRequest {
    /**
     * acctId is optional. It should be one of the accounts returned by /iserver/accounts. If not passed, the first one in the list is selected. 
     * @type {string}
     * @memberof OrderRequest
     */
    'acctId'?: string;
    /**
     * conid is the identifier of the security you want to trade, you can find the conid with /iserver/secdef/search. 
     * @type {number}
     * @memberof OrderRequest
     */
    'conid'?: number;
    /**
     * Conid and Exchange - Can be used instead of conid when specifying the contract identifier of a security. 
     * @type {string}
     * @memberof OrderRequest
     */
    'conidex'?: string;
    /**
     * The contract-identifier (conid) and security type (type) specified as a concatenated value, conid:type
     * @type {string}
     * @memberof OrderRequest
     */
    'secType'?: string;
    /**
     * Customer Order ID. An arbitrary string that can be used to identify the order, e.g \"my-fb-order\". The value must be unique for a 24h span. Please do not set this value for child orders when placing a bracket order. 
     * @type {string}
     * @memberof OrderRequest
     */
    'cOID'?: string;
    /**
     * Only specify for child orders when placing bracket orders. The parentId for the child order(s) must be equal to the cOId (customer order id) of the parent. 
     * @type {string}
     * @memberof OrderRequest
     */
    'parentId'?: string;
    /**
     * The order-type determines what type of order you want to send.   * LMT - A limit order is an order to buy or sell at the specified price or better.   * MKT - A market order is an order to buy or sell at the markets current NBBO.   * STP - A stop order becomes a market order once the specified stop price is attained or penetrated.   * STOP_LIMIT - A stop limit order becomes a limit order once the specified stop price is attained or penetrated.   * MIDPRICE - A MidPrice order attempts to fill at the current midpoint of the NBBO or better.   * TRAIL - A sell trailing stop order sets the stop price at a fixed amount below the market price with an attached \"trailing\" amount. See more details here: https://ndcdyn.interactivebrokers.com/en/index.php?f=605   * TRAILLMT - A trailing stop limit order is designed to allow an investor to specify a limit on the maximum possible loss, without setting a limit on the maximum possible gain.     See more details here: https://ndcdyn.interactivebrokers.com/en/index.php?f=606 
     * @type {string}
     * @memberof OrderRequest
     */
    'orderType'?: string;
    /**
     * listingExchange is optional. By default we use \"SMART\" routing. Possible values are available via the endpoint: /iserver/contract/{conid}/info, see **valid_exchange** e.g: SMART,AMEX,NYSE,CBOE,ISE,CHX,ARCA,ISLAND,DRCTEDGE,BEX,BATS,EDGEA,CSFBALGO,JE FFALGO,BYX,IEX,FOXRIVER,TPLUS1,NYSENAT,PSX 
     * @type {string}
     * @memberof OrderRequest
     */
    'listingExchange'?: string;
    /**
     * set to true if you want to place a single group orders(OCA) 
     * @type {boolean}
     * @memberof OrderRequest
     */
    'isSingleGroup'?: boolean;
    /**
     * set to true if the order can be executed outside regular trading hours. 
     * @type {boolean}
     * @memberof OrderRequest
     */
    'outsideRTH'?: boolean;
    /**
     * optional if order is LMT, or STOP_LIMIT, this is the limit price. For STP|TRAIL this is the stop price. For MIDPRICE this is the option price cap. 
     * @type {number}
     * @memberof OrderRequest
     */
    'price'?: number;
    /**
     * optional if order is STOP_LIMIT|TRAILLMT, this is the stop price. You must specify both price and auxPrice for STOP_LIMIT|TRAILLMT orders. 
     * @type {object}
     * @memberof OrderRequest
     */
    'auxPrice'?: object;
    /**
     * SELL or BUY
     * @type {string}
     * @memberof OrderRequest
     */
    'side'?: string;
    /**
     * This is the  underlying symbol for the contract. 
     * @type {string}
     * @memberof OrderRequest
     */
    'ticker'?: string;
    /**
     * The Time-In-Force determines how long the order remains active on the market.   * GTC - use Good-Till-Cancel for orders to remain active until it executes or cancelled.   * OPG - use Open-Price-Guarantee for Limit-On-Open (LOO) or Market-On-Open (MOO) orders.   * DAY - if not executed a Day order will automatically cancel at the end of the markets regular trading hours.   * IOC - any portion of an Immediate-or-Cancel order that is not filled as soon as it becomes available in the market is cancelled. 
     * @type {string}
     * @memberof OrderRequest
     */
    'tif'?: string;
    /**
     * optional if order is TRAIL, or TRAILLMT. When trailingType is amt, this is the trailing amount, when trailingType is %, it means percentage. You must specify both trailingType and trailingAmt for TRAIL and TRAILLMT order 
     * @type {number}
     * @memberof OrderRequest
     */
    'trailingAmt'?: number;
    /**
     * This is the trailing type for trailing amount. We only support two types here: amt or %. You must specify both trailingType and trailingAmt for TRAIL and TRAILLMT order 
     * @type {string}
     * @memberof OrderRequest
     */
    'trailingType'?: string;
    /**
     * Custom order reference 
     * @type {string}
     * @memberof OrderRequest
     */
    'referrer'?: string;
    /**
     * Usually integer, for some special cases such as fractional orders can specify as a float, e.g. quantity = 0.001. In some special cases quantity is not specified, such as when using \'cashQty\' or \'fxQty\'. 
     * @type {number}
     * @memberof OrderRequest
     */
    'quantity'?: number;
    /**
     * Cash Quantity - used to specify the monetary value of an order instead of the number of shares. When using \'cashQty\' don\'t specify \'quantity\' Orders that express size using a monetary value, e.g. cash quantity can result in fractional shares and are provided on a non-guaranteed basis. The system simulates the order by canceling it once the specified amount is spent (for buy orders) or collected (for sell orders). In addition to the monetary value, the order uses a maximum size that is calculated using the Cash Quantity Estimated Factor, which can be modified in Order Presets.   
     * @type {number}
     * @memberof OrderRequest
     */
    'cashQty'?: number;
    /**
     * double number, this is the cash quantity field which can only be used for Currency Conversion Orders. When using \'fxQty\' don\'t specify \'quantity\'. 
     * @type {number}
     * @memberof OrderRequest
     */
    'fxQty'?: number;
    /**
     * If true, the system will use the Price Management Algo to submit the order. https://www.interactivebrokers.com/en/index.php?f=43423 
     * @type {boolean}
     * @memberof OrderRequest
     */
    'useAdaptive'?: boolean;
    /**
     * set to true if the order is a FX conversion order 
     * @type {boolean}
     * @memberof OrderRequest
     */
    'isCcyConv'?: boolean;
    /**
     * Set the allocation method when placing an order using an FA account for a group Possible allocation methods are \"NetLiquidity\", \"AvailableEquity\", \"EqualQuantity\" and \"PctChange\". 
     * @type {string}
     * @memberof OrderRequest
     */
    'allocationMethod'?: string;
    /**
     * Specify which IB Algo algorithm to use for this order. 
     * @type {string}
     * @memberof OrderRequest
     */
    'strategy'?: string;
    /**
     * The IB Algo parameters for the specified algorithm. 
     * @type {object}
     * @memberof OrderRequest
     */
    'strategyParameters'?: object;
}
/**
 * contains all the details of an order
 * @export
 * @interface OrderStatus
 */
export interface OrderStatus {
    /**
     * order sub-type
     * @type {string}
     * @memberof OrderStatus
     */
    'sub_type'?: string;
    /**
     * order request id
     * @type {string}
     * @memberof OrderStatus
     */
    'request_id'?: string;
    /**
     * system generated order id, unique per account
     * @type {number}
     * @memberof OrderStatus
     */
    'order_id'?: number;
    /**
     * conid and exchange. Format supports conid or conid@exchange
     * @type {string}
     * @memberof OrderStatus
     */
    'conidex'?: string;
    /**
     * Underlying symbol
     * @type {string}
     * @memberof OrderStatus
     */
    'symbol'?: string;
    /**
     * The side of the market of the order.   * B - Buy contract near posted ask price   * S - Sell contract near posted bid price   * X - Option expired 
     * @type {string}
     * @memberof OrderStatus
     */
    'side'?: OrderStatusSideEnum;
    /**
     * Format contract name
     * @type {string}
     * @memberof OrderStatus
     */
    'contract_description_1'?: string;
    /**
     * Trading Exchange or Venue
     * @type {string}
     * @memberof OrderStatus
     */
    'listing_exchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderStatus
     */
    'option_acct'?: string;
    /**
     * Contracts company name
     * @type {string}
     * @memberof OrderStatus
     */
    'company_name'?: string;
    /**
     * Quantity updated
     * @type {string}
     * @memberof OrderStatus
     */
    'size'?: string;
    /**
     * Total quantity
     * @type {string}
     * @memberof OrderStatus
     */
    'total_size'?: string;
    /**
     * Contract traded currency
     * @type {string}
     * @memberof OrderStatus
     */
    'currency'?: string;
    /**
     * account id
     * @type {string}
     * @memberof OrderStatus
     */
    'account'?: string;
    /**
     * Types of orders
     * @type {string}
     * @memberof OrderStatus
     */
    'order_type'?: string;
    /**
     * Limit price
     * @type {string}
     * @memberof OrderStatus
     */
    'limit_price'?: string;
    /**
     * Stop price
     * @type {string}
     * @memberof OrderStatus
     */
    'stop_price'?: string;
    /**
     * Cumulative fill
     * @type {string}
     * @memberof OrderStatus
     */
    'cum_fill'?: string;
    /**
     * *  PendingSubmit - Indicates the order was sent, but confirmation has not been received that it has been received by the destination.                    Occurs most commonly if an exchange is closed. *  PendingCancel - Indicates that a request has been sent to cancel an order but confirmation has not been received of its cancellation. *  PreSubmitted - Indicates that a simulated order type has been accepted by the IBKR system and that this order has yet to be elected.                   The order is held in the IBKR system until the election criteria are met. At that time the order is transmitted to the order destination as specified. *  Submitted - Indicates that the order has been accepted at the order destination and is working. *  Cancelled - Indicates that the balance of the order has been confirmed cancelled by the IB system.                This could occur unexpectedly when IB or the destination has rejected the order. *  Filled - Indicates that the order has been completely filled. *  Inactive - Indicates the order is not working, for instance if the order was invalid and triggered an error message,               or if the order was to short a security and shares have not yet been located. 
     * @type {string}
     * @memberof OrderStatus
     */
    'order_status'?: string;
    /**
     * Description of the order status
     * @type {string}
     * @memberof OrderStatus
     */
    'order_status_description'?: string;
    /**
     * Time-in-Force - length of time order will continue working before it is canceled.
     * @type {string}
     * @memberof OrderStatus
     */
    'tif'?: string;
    /**
     * Foreground color in hex format
     * @type {string}
     * @memberof OrderStatus
     */
    'fg_color'?: string;
    /**
     * Background color in hex format
     * @type {string}
     * @memberof OrderStatus
     */
    'bg_color'?: string;
    /**
     * If true not allowed to modify order
     * @type {boolean}
     * @memberof OrderStatus
     */
    'order_not_editable'?: boolean;
    /**
     * Fields that can be edited in escaped unicode characters
     * @type {string}
     * @memberof OrderStatus
     */
    'editable_fields'?: string;
    /**
     * If true not allowed to cancel order
     * @type {boolean}
     * @memberof OrderStatus
     */
    'cannot_cancel_order'?: boolean;
    /**
     * If true order trades outside regular trading hours
     * @type {boolean}
     * @memberof OrderStatus
     */
    'outside_rth'?: boolean;
    /**
     * If true order is de-activated
     * @type {boolean}
     * @memberof OrderStatus
     */
    'deactivate_order'?: boolean;
    /**
     * If true price management algo is enabled, refer to https://www.interactivebrokers.com/en/index.php?f=43423
     * @type {boolean}
     * @memberof OrderStatus
     */
    'use_price_mgmt_algo'?: boolean;
    /**
     * Asset class
     * @type {string}
     * @memberof OrderStatus
     */
    'sec_type'?: string;
    /**
     * List of available chart periods
     * @type {string}
     * @memberof OrderStatus
     */
    'available_chart_periods'?: string;
    /**
     * Format description of order
     * @type {string}
     * @memberof OrderStatus
     */
    'order_description'?: string;
    /**
     * order_description with the symbol
     * @type {string}
     * @memberof OrderStatus
     */
    'order_description_with_contract'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderStatus
     */
    'alert_active'?: number;
    /**
     * type of the child order
     * @type {string}
     * @memberof OrderStatus
     */
    'child_order_type'?: string;
    /**
     * Format fillQuantity\\totalQuantity
     * @type {string}
     * @memberof OrderStatus
     */
    'size_and_fills'?: string;
    /**
     * Position display price
     * @type {string}
     * @memberof OrderStatus
     */
    'exit_strategy_display_price'?: string;
    /**
     * Position description to display on chart
     * @type {string}
     * @memberof OrderStatus
     */
    'exit_strategy_chart_description'?: string;
    /**
     * * 1: If your account has position or order for contract * 0: If your account has no position or order for contract 
     * @type {string}
     * @memberof OrderStatus
     */
    'exit_strategy_tool_availability'?: OrderStatusExitStrategyToolAvailabilityEnum;
    /**
     * Returns true if contract supports duplicate/opposite side order.
     * @type {boolean}
     * @memberof OrderStatus
     */
    'allowed_duplicate_opposite'?: boolean;
    /**
     * Time of status update in unix time
     * @type {string}
     * @memberof OrderStatus
     */
    'order_time'?: string;
    /**
     * only exists for oca orders, oca orders in same group will have same id
     * @type {string}
     * @memberof OrderStatus
     */
    'oca_group_id'?: string;
}

export const OrderStatusSideEnum = {
    B: 'B',
    S: 'S',
    X: 'X'
} as const;

export type OrderStatusSideEnum = typeof OrderStatusSideEnum[keyof typeof OrderStatusSideEnum];
export const OrderStatusExitStrategyToolAvailabilityEnum = {
    _1: '1',
    _0: '0'
} as const;

export type OrderStatusExitStrategyToolAvailabilityEnum = typeof OrderStatusExitStrategyToolAvailabilityEnum[keyof typeof OrderStatusExitStrategyToolAvailabilityEnum];

/**
 * 
 * @export
 * @interface PaPerformancePostRequest
 */
export interface PaPerformancePostRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof PaPerformancePostRequest
     */
    'acctIds'?: Array<string>;
    /**
     * Frequency of cumulative performance data points: \'D\'aily, \'M\'onthly,\'Q\'uarterly. 
     * @type {string}
     * @memberof PaPerformancePostRequest
     */
    'freq'?: PaPerformancePostRequestFreqEnum;
}

export const PaPerformancePostRequestFreqEnum = {
    D: 'D',
    M: 'M',
    Q: 'Q'
} as const;

export type PaPerformancePostRequestFreqEnum = typeof PaPerformancePostRequestFreqEnum[keyof typeof PaPerformancePostRequestFreqEnum];

/**
 * 
 * @export
 * @interface PaSummaryPostRequest
 */
export interface PaSummaryPostRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof PaSummaryPostRequest
     */
    'acctIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PaTransactionsPostRequest
 */
export interface PaTransactionsPostRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof PaTransactionsPostRequest
     */
    'acctIds'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof PaTransactionsPostRequest
     */
    'conids'?: Array<number>;
    /**
     * optional defaults to USD.
     * @type {string}
     * @memberof PaTransactionsPostRequest
     */
    'currency'?: string;
    /**
     * optional, default value is 90
     * @type {number}
     * @memberof PaTransactionsPostRequest
     */
    'days'?: number;
}
/**
 * 
 * @export
 * @interface Performance
 */
export interface Performance {
    /**
     * 
     * @type {string}
     * @memberof Performance
     */
    'id'?: string;
    /**
     * 
     * @type {PerformanceCps}
     * @memberof Performance
     */
    'cps'?: PerformanceCps;
    /**
     * 
     * @type {PerformanceTpps}
     * @memberof Performance
     */
    'tpps'?: PerformanceTpps;
    /**
     * 
     * @type {PerformanceNav}
     * @memberof Performance
     */
    'nav'?: PerformanceNav;
    /**
     * 
     * @type {string}
     * @memberof Performance
     */
    'pm'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Performance
     */
    'included'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Performance
     */
    'currencyType'?: string;
    /**
     * 
     * @type {number}
     * @memberof Performance
     */
    'rc'?: number;
}
/**
 * Cumulative performance data
 * @export
 * @interface PerformanceCps
 */
export interface PerformanceCps {
    /**
     * array of dates, the length should be same as the length of returns inside data.
     * @type {Array<string>}
     * @memberof PerformanceCps
     */
    'dates'?: Array<string>;
    /**
     * D means Day
     * @type {string}
     * @memberof PerformanceCps
     */
    'freq'?: string;
    /**
     * 
     * @type {Array<PerformanceCpsDataInner>}
     * @memberof PerformanceCps
     */
    'data'?: Array<PerformanceCpsDataInner>;
}
/**
 * 
 * @export
 * @interface PerformanceCpsDataInner
 */
export interface PerformanceCpsDataInner {
    /**
     * 
     * @type {string}
     * @memberof PerformanceCpsDataInner
     */
    'id'?: string;
    /**
     * for example-- acctid
     * @type {string}
     * @memberof PerformanceCpsDataInner
     */
    'idType'?: string;
    /**
     * start date-- yyyyMMdd
     * @type {string}
     * @memberof PerformanceCpsDataInner
     */
    'start'?: string;
    /**
     * 
     * @type {string}
     * @memberof PerformanceCpsDataInner
     */
    'baseCurrency'?: string;
    /**
     * each value stands for price change percent of corresponding date in dates array
     * @type {Array<number>}
     * @memberof PerformanceCpsDataInner
     */
    'returns'?: Array<number>;
    /**
     * end date-- yyyyMMdd
     * @type {string}
     * @memberof PerformanceCpsDataInner
     */
    'end'?: string;
}
/**
 * Net asset value data for the account or consolidated accounts. NAV data is not applicable to benchmarks.
 * @export
 * @interface PerformanceNav
 */
export interface PerformanceNav {
    /**
     * array of dates, the length should be same as the length of returns inside data.
     * @type {Array<string>}
     * @memberof PerformanceNav
     */
    'dates'?: Array<string>;
    /**
     * D means Day
     * @type {string}
     * @memberof PerformanceNav
     */
    'freq'?: string;
    /**
     * 
     * @type {Array<PerformanceCpsDataInner>}
     * @memberof PerformanceNav
     */
    'data'?: Array<PerformanceCpsDataInner>;
}
/**
 * Time period performance data
 * @export
 * @interface PerformanceTpps
 */
export interface PerformanceTpps {
    /**
     * array of dates, the length should be same as the length of returns inside data.
     * @type {Array<string>}
     * @memberof PerformanceTpps
     */
    'dates'?: Array<string>;
    /**
     * M means Month
     * @type {string}
     * @memberof PerformanceTpps
     */
    'freq'?: string;
    /**
     * 
     * @type {Array<PerformanceCpsDataInner>}
     * @memberof PerformanceTpps
     */
    'data'?: Array<PerformanceCpsDataInner>;
}
/**
 * 
 * @export
 * @interface PortfolioAccountIdLedgerGet200Response
 */
export interface PortfolioAccountIdLedgerGet200Response {
    /**
     * 
     * @type {Ledger}
     * @memberof PortfolioAccountIdLedgerGet200Response
     */
    'BASE'?: Ledger;
}
/**
 * 
 * @export
 * @interface PortfolioAccountIdSummaryGet200Response
 */
export interface PortfolioAccountIdSummaryGet200Response {
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'accountready'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'accounttype'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'accruedcash'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'accruedcash-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'accruedcash-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'accruedcash-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'accrueddividend'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'accrueddividend-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'accrueddividend-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'accrueddividend-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'availablefunds'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'availablefunds-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'availablefunds-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'availablefunds-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'billable'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'billable-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'billable-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'billable-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'buyingpower'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'cushion'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'daytradesremaining'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'daytradesremainingt+1'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'daytradesremainingt+2'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'daytradesremainingt+3'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'daytradesremainingt+4'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'equitywithloanvalue'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'equitywithloanvalue-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'equitywithloanvalue-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'equitywithloanvalue-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'excessliquidity'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'excessliquidity-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'excessliquidity-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'excessliquidity-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullavailablefunds'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullavailablefunds-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullavailablefunds-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullavailablefunds-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullexcessliquidity'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullexcessliquidity-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullexcessliquidity-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullexcessliquidity-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullinitmarginreq'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullinitmarginreq-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullinitmarginreq-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullinitmarginreq-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullmaintmarginreq'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullmaintmarginreq-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullmaintmarginreq-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'fullmaintmarginreq-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'grosspositionvalue'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'grosspositionvalue-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'grosspositionvalue-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'grosspositionvalue-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'guarantee'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'guarantee-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'guarantee-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'guarantee-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'highestseverity'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'highestseverity-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'highestseverity-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'highestseverity-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'indianstockhaircut'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'indianstockhaircut-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'indianstockhaircut-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'indianstockhaircut-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'initmarginreq'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'initmarginreq-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'initmarginreq-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'initmarginreq-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'leverage'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'leverage-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'leverage-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'leverage-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadavailablefunds'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadavailablefunds-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadavailablefunds-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadavailablefunds-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadexcessliquidity'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadexcessliquidity-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadexcessliquidity-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadexcessliquidity-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadinitmarginreq'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadinitmarginreq-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadinitmarginreq-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadinitmarginreq-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadmaintmarginreq'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadmaintmarginreq-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadmaintmarginreq-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadmaintmarginreq-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'lookaheadnextchange'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'maintmarginreq'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'maintmarginreq-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'maintmarginreq-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'maintmarginreq-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'netliquidation'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'netliquidation-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'netliquidation-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'netliquidation-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'netliquidationuncertainty'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'nlvandmargininreview'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'pasharesvalue'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'pasharesvalue-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'pasharesvalue-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'pasharesvalue-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'postexpirationexcess'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'postexpirationexcess-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'postexpirationexcess-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'postexpirationexcess-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'postexpirationmargin'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'postexpirationmargin-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'postexpirationmargin-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'postexpirationmargin-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'previousdayequitywithloanvalue'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'previousdayequitywithloanvalue-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'previousdayequitywithloanvalue-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'previousdayequitywithloanvalue-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'segmenttitle-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'segmenttitle-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'segmenttitle-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'totalcashvalue'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'totalcashvalue-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'totalcashvalue-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'totalcashvalue-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'totaldebitcardpendingcharges'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'totaldebitcardpendingcharges-c'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'totaldebitcardpendingcharges-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'totaldebitcardpendingcharges-s'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'tradingtype-f'?: Summary;
    /**
     * 
     * @type {Summary}
     * @memberof PortfolioAccountIdSummaryGet200Response
     */
    'tradingtype-s'?: Summary;
}
/**
 * 
 * @export
 * @interface PortfolioPositionsConidGet200Response
 */
export interface PortfolioPositionsConidGet200Response {
    /**
     * 
     * @type {Array<PositionInner>}
     * @memberof PortfolioPositionsConidGet200Response
     */
    'ACCTID'?: Array<PositionInner>;
}
/**
 * 
 * @export
 * @interface PortfolioSubaccounts2Get200Response
 */
export interface PortfolioSubaccounts2Get200Response {
    /**
     * 
     * @type {PortfolioSubaccounts2Get200ResponseMetadata}
     * @memberof PortfolioSubaccounts2Get200Response
     */
    'metadata'?: PortfolioSubaccounts2Get200ResponseMetadata;
    /**
     * 
     * @type {Array<PortfolioSubaccounts2Get200ResponseSubaccountsInner>}
     * @memberof PortfolioSubaccounts2Get200Response
     */
    'subaccounts'?: Array<PortfolioSubaccounts2Get200ResponseSubaccountsInner>;
}
/**
 * 
 * @export
 * @interface PortfolioSubaccounts2Get200ResponseMetadata
 */
export interface PortfolioSubaccounts2Get200ResponseMetadata {
    /**
     * Number of sub-accounts
     * @type {number}
     * @memberof PortfolioSubaccounts2Get200ResponseMetadata
     */
    'total'?: number;
    /**
     * How many sub-accounts are returned for the page requested. A max of 20 per page.
     * @type {number}
     * @memberof PortfolioSubaccounts2Get200ResponseMetadata
     */
    'pageSize'?: number;
    /**
     * Current page number.
     * @type {number}
     * @memberof PortfolioSubaccounts2Get200ResponseMetadata
     */
    'pageNume'?: number;
}
/**
 * Account information
 * @export
 * @interface PortfolioSubaccounts2Get200ResponseSubaccountsInner
 */
export interface PortfolioSubaccounts2Get200ResponseSubaccountsInner {
    /**
     * The account identification value
     * @type {string}
     * @memberof PortfolioSubaccounts2Get200ResponseSubaccountsInner
     */
    'id'?: string;
    /**
     * The account number
     * @type {string}
     * @memberof PortfolioSubaccounts2Get200ResponseSubaccountsInner
     */
    'accountId'?: string;
    /**
     * The accountAlias
     * @type {string}
     * @memberof PortfolioSubaccounts2Get200ResponseSubaccountsInner
     */
    'accountVan'?: string;
    /**
     * Title of the account
     * @type {string}
     * @memberof PortfolioSubaccounts2Get200ResponseSubaccountsInner
     */
    'accountTitle'?: string;
    /**
     * Whichever value is not null in this priority
     * @type {string}
     * @memberof PortfolioSubaccounts2Get200ResponseSubaccountsInner
     */
    'displayName'?: PortfolioSubaccounts2Get200ResponseSubaccountsInnerDisplayNameEnum;
    /**
     * User customizable account alias. Refer to [Configure Account Alias](https://guides.interactivebrokers.com/cp/cp.htm#am/settings/accountalias.htm) for details.
     * @type {string}
     * @memberof PortfolioSubaccounts2Get200ResponseSubaccountsInner
     */
    'accountAlias'?: string;
    /**
     * When the account was opened in unix time.
     * @type {number}
     * @memberof PortfolioSubaccounts2Get200ResponseSubaccountsInner
     */
    'accountStatus'?: number;
    /**
     * Base currency of the account.
     * @type {string}
     * @memberof PortfolioSubaccounts2Get200ResponseSubaccountsInner
     */
    'currency'?: PortfolioSubaccounts2Get200ResponseSubaccountsInnerCurrencyEnum;
    /**
     * Account Type
     * @type {string}
     * @memberof PortfolioSubaccounts2Get200ResponseSubaccountsInner
     */
    'type'?: PortfolioSubaccounts2Get200ResponseSubaccountsInnerTypeEnum;
    /**
     * UNI - Deprecated property
     * @type {string}
     * @memberof PortfolioSubaccounts2Get200ResponseSubaccountsInner
     */
    'tradingType'?: string;
    /**
     * If an account is a sub-account to a Financial Advisor.
     * @type {boolean}
     * @memberof PortfolioSubaccounts2Get200ResponseSubaccountsInner
     */
    'faclient'?: boolean;
    /**
     * Status of the Account   * O = Open   * P or N = Pending   * A = Abandoned   * R = Rejected   * C = Closed   covestor:     type: boolean     description: Is a Covestor Account   parent:     type: object     properties:       mmc:         type: array         items:           type: string           description: Money Manager Client (MMC) Account       accountId:         type: string         description: Account Number for Money Manager Client       isMParent:         type: boolean         description: Is MM a Parent Account       isMChild:         type: boolean         description: Is MM a Child Account       isMultiplex:         type: boolean         description: Is a Multiplex Account. These are account models with individual account being parent and managed account being child.   desc:     type: string     description: Formatted \"accountId - accountAlias\" 
     * @type {string}
     * @memberof PortfolioSubaccounts2Get200ResponseSubaccountsInner
     */
    'clearingStatus'?: PortfolioSubaccounts2Get200ResponseSubaccountsInnerClearingStatusEnum;
}

export const PortfolioSubaccounts2Get200ResponseSubaccountsInnerDisplayNameEnum = {
    AccountTitle: 'accountTitle',
    AccountVan: 'accountVan',
    AccountId: 'accountId'
} as const;

export type PortfolioSubaccounts2Get200ResponseSubaccountsInnerDisplayNameEnum = typeof PortfolioSubaccounts2Get200ResponseSubaccountsInnerDisplayNameEnum[keyof typeof PortfolioSubaccounts2Get200ResponseSubaccountsInnerDisplayNameEnum];
export const PortfolioSubaccounts2Get200ResponseSubaccountsInnerCurrencyEnum = {
    Aud: 'AUD',
    Gbp: 'GBP',
    Cad: 'CAD',
    Cnh: 'CNH',
    Czk: 'CZK',
    Dkk: 'DKK',
    Eur: 'EUR',
    Hkd: 'HKD',
    Huf: 'HUF',
    Inr: 'INR',
    Ils: 'ILS',
    Jpy: 'JPY',
    Mxn: 'MXN',
    Nok: 'NOK',
    Nzd: 'NZD',
    Pln: 'PLN',
    Rub: 'RUB',
    Sgd: 'SGD',
    Sek: 'SEK',
    Chf: 'CHF',
    Usd: 'USD'
} as const;

export type PortfolioSubaccounts2Get200ResponseSubaccountsInnerCurrencyEnum = typeof PortfolioSubaccounts2Get200ResponseSubaccountsInnerCurrencyEnum[keyof typeof PortfolioSubaccounts2Get200ResponseSubaccountsInnerCurrencyEnum];
export const PortfolioSubaccounts2Get200ResponseSubaccountsInnerTypeEnum = {
    Individual: 'INDIVIDUAL',
    Joint: 'JOINT',
    Org: 'ORG',
    Trust: 'TRUST',
    Demo: 'DEMO'
} as const;

export type PortfolioSubaccounts2Get200ResponseSubaccountsInnerTypeEnum = typeof PortfolioSubaccounts2Get200ResponseSubaccountsInnerTypeEnum[keyof typeof PortfolioSubaccounts2Get200ResponseSubaccountsInnerTypeEnum];
export const PortfolioSubaccounts2Get200ResponseSubaccountsInnerClearingStatusEnum = {
    O: 'O',
    P: 'P',
    N: 'N',
    A: 'A',
    R: 'R',
    C: 'C'
} as const;

export type PortfolioSubaccounts2Get200ResponseSubaccountsInnerClearingStatusEnum = typeof PortfolioSubaccounts2Get200ResponseSubaccountsInnerClearingStatusEnum[keyof typeof PortfolioSubaccounts2Get200ResponseSubaccountsInnerClearingStatusEnum];

/**
 * 
 * @export
 * @interface PositionData
 */
export interface PositionData {
    /**
     * Contract identifier from IBKR\'s database.
     * @type {number}
     * @memberof PositionData
     */
    'conid'?: number;
    /**
     * Number of shares or quantity of the position.
     * @type {number}
     * @memberof PositionData
     */
    'position'?: number;
    /**
     * Average cost of the position.
     * @type {number}
     * @memberof PositionData
     */
    'avgCost'?: number;
}
/**
 * Account Information
 * @export
 * @interface PositionInner
 */
export interface PositionInner {
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'acctId'?: string;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'conid'?: number;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'contractDesc'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'assetClass'?: string;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'position'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'mktPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'mktValue'?: number;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'avgCost'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'avgPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'realizedPnl'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'unrealizedPnl'?: number;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'exchs'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'expiry'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'putOrCall'?: string;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'multiplier'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'strike'?: number;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'exerciseStyle'?: string;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'undConid'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PositionInner
     */
    'conExchMap'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'baseMktValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'baseMktPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'baseAvgCost'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'baseAvgPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'baseRealizedPnl'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'baseUnrealizedPnl'?: number;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'lastTradingDay'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'group'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'sector'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'sectorGroup'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'ticker'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'undComp'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'undSym'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'fullName'?: string;
    /**
     * 
     * @type {number}
     * @memberof PositionInner
     */
    'pageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof PositionInner
     */
    'model'?: string;
}
/**
 * 
 * @export
 * @interface ScannerParams
 */
export interface ScannerParams {
    /**
     * Contains an instrument, which to scan for. For example - \"STK\"
     * @type {string}
     * @memberof ScannerParams
     */
    'instrument'?: string;
    /**
     * Specify the scan type to use. For example - \"MOST_ACTIVE_USD\"
     * @type {string}
     * @memberof ScannerParams
     */
    'type'?: string;
    /**
     * Contains location code, where to look for specified instrument. For example - \"STK.US.MAJOR\"
     * @type {string}
     * @memberof ScannerParams
     */
    'location'?: string;
    /**
     * Contains list of filters supported for the scanner
     * @type {Array<ScannerParamsFilterInner>}
     * @memberof ScannerParams
     */
    'filter'?: Array<ScannerParamsFilterInner>;
}
/**
 * Contains list of supported filters. The code of the filter along with user-specified value has to be sued to apply a filter to scanner query. For example - [{\"code\":\"usdVolume\",\"value\":500}]. You can also specify multiple filters - \"filter\":[{\"code\":\"value\"},{\"code\":\"value\"},{\"code\":\"value\"}]
 * @export
 * @interface ScannerParamsFilterInner
 */
export interface ScannerParamsFilterInner {
    /**
     * 
     * @type {string}
     * @memberof ScannerParamsFilterInner
     */
    'code'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScannerParamsFilterInner
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface ScannerResult
 */
export interface ScannerResult {
    /**
     * 
     * @type {number}
     * @memberof ScannerResult
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScannerResult
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScannerResult
     */
    'offset'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScannerResult
     */
    'scanTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScannerResult
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScannerResult
     */
    'position'?: string;
    /**
     * 
     * @type {ScannerResultContracts}
     * @memberof ScannerResult
     */
    'Contracts'?: ScannerResultContracts;
}
/**
 * Contains list of contracts matching the scanner query
 * @export
 * @interface ScannerResultContracts
 */
export interface ScannerResultContracts {
    /**
     * 
     * @type {Array<ScannerResultContractsContractInner>}
     * @memberof ScannerResultContracts
     */
    'Contract'?: Array<ScannerResultContractsContractInner>;
}
/**
 * 
 * @export
 * @interface ScannerResultContractsContractInner
 */
export interface ScannerResultContractsContractInner {
    /**
     * 
     * @type {string}
     * @memberof ScannerResultContractsContractInner
     */
    'inScanTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScannerResultContractsContractInner
     */
    'distance'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScannerResultContractsContractInner
     */
    'contractID'?: number;
}
/**
 * Contains some basic info of contract
 * @export
 * @interface SecdefInfo
 */
export interface SecdefInfo {
    /**
     * IBKR contract identifier
     * @type {number}
     * @memberof SecdefInfo
     */
    'conid'?: number;
    /**
     * Underlying symbol
     * @type {string}
     * @memberof SecdefInfo
     */
    'symbol'?: string;
    /**
     * Security type
     * @type {string}
     * @memberof SecdefInfo
     */
    'secType'?: string;
    /**
     * Primary Exchange, Routing or Trading Venue
     * @type {string}
     * @memberof SecdefInfo
     */
    'exchange'?: string;
    /**
     * Main Trading Venue
     * @type {string}
     * @memberof SecdefInfo
     */
    'listingExchange'?: string;
    /**
     * Put or Call of the option. C = Call Option, P = Put Option
     * @type {string}
     * @memberof SecdefInfo
     */
    'right'?: string;
    /**
     * Set price at which a derivative contract can be bought or sold. The strike price also known as exercise price.
     * @type {number}
     * @memberof SecdefInfo
     */
    'strike'?: number;
    /**
     * Currency the contract trades in
     * @type {string}
     * @memberof SecdefInfo
     */
    'currency'?: string;
    /**
     * Committee on Uniform Securities Identification Procedures number
     * @type {string}
     * @memberof SecdefInfo
     */
    'cusip'?: string;
    /**
     * Annual interest rate paid on a bond
     * @type {string}
     * @memberof SecdefInfo
     */
    'coupon'?: string;
    /**
     * Currency pairs for Forex e.g. EUR.AUD, EUR.CAD, EUR.CHF etc.
     * @type {string}
     * @memberof SecdefInfo
     */
    'desc1'?: string;
    /**
     * Formatted expiration, strike and right
     * @type {string}
     * @memberof SecdefInfo
     */
    'desc2'?: string;
    /**
     * Format YYYYMMDD, the date on which the underlying transaction settles if the option is exercised
     * @type {number}
     * @memberof SecdefInfo
     */
    'maturityDate'?: number;
    /**
     * Multiplier for total premium paid or received for derivative contract.
     * @type {string}
     * @memberof SecdefInfo
     */
    'multiplier'?: string;
    /**
     * Designation of the contract.
     * @type {string}
     * @memberof SecdefInfo
     */
    'tradingClass'?: string;
    /**
     * Comma separated list of exchanges or trading venues.
     * @type {string}
     * @memberof SecdefInfo
     */
    'validExchanges'?: string;
}
/**
 * security definition information.
 * @export
 * @interface SecdefInner
 */
export interface SecdefInner {
    /**
     * IBKR contract identifier.
     * @type {number}
     * @memberof SecdefInner
     */
    'conid'?: number;
    /**
     * Currency contract trades in.
     * @type {string}
     * @memberof SecdefInner
     */
    'currency'?: string;
    /**
     * Defines if a derivative contract has a different currency.
     * @type {boolean}
     * @memberof SecdefInner
     */
    'crossCurrency'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SecdefInner
     */
    'time'?: number;
    /**
     * HTML encoded company description in Chinese.
     * @type {string}
     * @memberof SecdefInner
     */
    'chineseName'?: string;
    /**
     * List of exchanges and venues contract trades.
     * @type {string}
     * @memberof SecdefInner
     */
    'allExchanges'?: string;
    /**
     * Main trading venue.
     * @type {string}
     * @memberof SecdefInner
     */
    'listingExchange'?: string;
    /**
     * Company Name.
     * @type {string}
     * @memberof SecdefInner
     */
    'name'?: string;
    /**
     * Group of financial instruments which have similar financial characteristics and behave similar in the marketplace.
     * @type {string}
     * @memberof SecdefInner
     */
    'assetClass'?: string;
    /**
     * Specific data contract expires.
     * @type {string}
     * @memberof SecdefInner
     */
    'expiry'?: string;
    /**
     * Final day derivative contract can be traded before delivery of the underlying asset or cash settlement.
     * @type {string}
     * @memberof SecdefInner
     */
    'lastTradingDay'?: string;
    /**
     * Potential characteristic of each product.
     * @type {string}
     * @memberof SecdefInner
     */
    'group'?: string;
    /**
     * Defines the right to buy or sell of the underlying security.
     * @type {string}
     * @memberof SecdefInner
     */
    'putOrCall'?: string;
    /**
     * The category of the economy.
     * @type {string}
     * @memberof SecdefInner
     */
    'sector'?: string;
    /**
     * Stock Group contract belongs too.
     * @type {string}
     * @memberof SecdefInner
     */
    'sectorGroup'?: string;
    /**
     * Set price at which a derivative contract can be bought or sold.
     * @type {number}
     * @memberof SecdefInner
     */
    'strike'?: number;
    /**
     * Contract symbol.
     * @type {string}
     * @memberof SecdefInner
     */
    'ticker'?: string;
    /**
     * Underlying contract identifier.
     * @type {number}
     * @memberof SecdefInner
     */
    'undConid'?: number;
    /**
     * Multiplier for total premium paid or received for derivative contract.
     * @type {number}
     * @memberof SecdefInner
     */
    'multiplier'?: number;
    /**
     * Stock type.
     * @type {string}
     * @memberof SecdefInner
     */
    'type'?: string;
    /**
     * Company name for underlying contract.
     * @type {string}
     * @memberof SecdefInner
     */
    'undComp'?: string;
    /**
     * IBKR Symbol for underlying contract.
     * @type {string}
     * @memberof SecdefInner
     */
    'undSym'?: string;
    /**
     * If contract has an option.
     * @type {boolean}
     * @memberof SecdefInner
     */
    'hasOptions'?: boolean;
    /**
     * Formatted company name with underlying symbol, expiration, strike, right.
     * @type {string}
     * @memberof SecdefInner
     */
    'fullName'?: string;
    /**
     * If contract is a US contract. Currently supported for stocks, options and warrants.
     * @type {boolean}
     * @memberof SecdefInner
     */
    'isUS'?: boolean;
    /**
     * 
     * @type {SecdefInnerIncrementRules}
     * @memberof SecdefInner
     */
    'incrementRules'?: SecdefInnerIncrementRules;
}
/**
 * Price increment value contract trades.
 * @export
 * @interface SecdefInnerIncrementRules
 */
export interface SecdefInnerIncrementRules {
    /**
     * The minimum contract price on the market that supports the specified increment.
     * @type {number}
     * @memberof SecdefInnerIncrementRules
     */
    'lowerEdge'?: number;
    /**
     * The minimum increment value for contract price.
     * @type {number}
     * @memberof SecdefInnerIncrementRules
     */
    'increment'?: number;
}
/**
 * 
 * @export
 * @interface SetAccount
 */
export interface SetAccount {
    /**
     * Account ID
     * @type {string}
     * @memberof SetAccount
     */
    'acctId'?: string;
}
/**
 * 
 * @export
 * @interface SsoValidateGet200Response
 */
export interface SsoValidateGet200Response {
    /**
     * 1 for Live, 2 for Paper
     * @type {number}
     * @memberof SsoValidateGet200Response
     */
    'LOGIN_TYPE'?: number;
    /**
     * Username
     * @type {string}
     * @memberof SsoValidateGet200Response
     */
    'USER_NAME'?: string;
    /**
     * User ID
     * @type {number}
     * @memberof SsoValidateGet200Response
     */
    'USER_ID'?: number;
    /**
     * Time in milliseconds until session expires. Caller needs to call the again to re-validate session
     * @type {number}
     * @memberof SsoValidateGet200Response
     */
    'expire'?: number;
    /**
     * true if session was validated; false if not.
     * @type {boolean}
     * @memberof SsoValidateGet200Response
     */
    'RESULT'?: boolean;
    /**
     * Time of session validation
     * @type {number}
     * @memberof SsoValidateGet200Response
     */
    'AUTH_TIME'?: number;
}
/**
 * 
 * @export
 * @interface StatsData
 */
export interface StatsData {
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    'Conid'?: number;
    /**
     * 
     * @type {string}
     * @memberof StatsData
     */
    'Exchange'?: string;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    'V'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    'T'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatsData
     */
    'TT'?: number;
    /**
     * Object, payload depends on event type. See confluence page for IGEvntUpd.
     * @type {string}
     * @memberof StatsData
     */
    'P'?: string;
}
/**
 * future contract information
 * @export
 * @interface StocksInner
 */
export interface StocksInner {
    /**
     * company name
     * @type {string}
     * @memberof StocksInner
     */
    'name'?: string;
    /**
     * company name in Chinese
     * @type {string}
     * @memberof StocksInner
     */
    'chineseName'?: string;
    /**
     * 
     * @type {string}
     * @memberof StocksInner
     */
    'assetClass'?: string;
    /**
     * array of contracts from different exchanges
     * @type {Array<StocksInnerContractsInner>}
     * @memberof StocksInner
     */
    'contracts'?: Array<StocksInnerContractsInner>;
}
/**
 * 
 * @export
 * @interface StocksInnerContractsInner
 */
export interface StocksInnerContractsInner {
    /**
     * conid of the stock contract
     * @type {number}
     * @memberof StocksInnerContractsInner
     */
    'conid'?: number;
    /**
     * 
     * @type {string}
     * @memberof StocksInnerContractsInner
     */
    'exchange'?: string;
}
/**
 * 
 * @export
 * @interface Summary
 */
export interface Summary {
    /**
     * 
     * @type {number}
     * @memberof Summary
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Summary
     */
    'currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Summary
     */
    'isNull'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Summary
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof Summary
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface SystemError
 */
export interface SystemError {
    /**
     * 
     * @type {string}
     * @memberof SystemError
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface Trade
 */
export interface Trade {
    /**
     * execution identifier for the order
     * @type {string}
     * @memberof Trade
     */
    'execution_id'?: string;
    /**
     * Underlying Symbol
     * @type {string}
     * @memberof Trade
     */
    'symbol'?: string;
    /**
     * The side of the market of the order.   * B - Buy contract near posted ask price   * S - Sell contract near posted bid price   * X - Option expired 
     * @type {string}
     * @memberof Trade
     */
    'side'?: TradeSideEnum;
    /**
     * Formatted description of the order \"%side% %size% @ %price% on %exchange%\".
     * @type {string}
     * @memberof Trade
     */
    'order_description'?: string;
    /**
     * Time of Status update in format \"YYYYMMDD-hh:mm:ss\".
     * @type {string}
     * @memberof Trade
     */
    'trade_time'?: string;
    /**
     * Time of status update in format unix time.
     * @type {number}
     * @memberof Trade
     */
    'trade_time_r'?: number;
    /**
     * Quantity of the order
     * @type {string}
     * @memberof Trade
     */
    'size'?: string;
    /**
     * Average Price
     * @type {string}
     * @memberof Trade
     */
    'price'?: string;
    /**
     * User defined string used to identify the order. Value is set using \"cOID\" field while placing an order.
     * @type {string}
     * @memberof Trade
     */
    'order_ref'?: string;
    /**
     * User that submitted order
     * @type {string}
     * @memberof Trade
     */
    'submitter'?: string;
    /**
     * Exchange or venue of order
     * @type {string}
     * @memberof Trade
     */
    'exchange'?: string;
    /**
     * Commission of the order
     * @type {number}
     * @memberof Trade
     */
    'commission'?: number;
    /**
     * Net cost of the order, including contract multiplier and quantity.
     * @type {number}
     * @memberof Trade
     */
    'net_amount'?: number;
    /**
     * accountCode
     * @type {string}
     * @memberof Trade
     */
    'account'?: string;
    /**
     * Account Number
     * @type {string}
     * @memberof Trade
     */
    'acountCode'?: string;
    /**
     * Contracts company name
     * @type {string}
     * @memberof Trade
     */
    'company_name'?: string;
    /**
     * Format contract name
     * @type {string}
     * @memberof Trade
     */
    'contract_description_1'?: string;
    /**
     * Asset class
     * @type {string}
     * @memberof Trade
     */
    'sec_type'?: string;
    /**
     * IBKR\'s contract identifier
     * @type {string}
     * @memberof Trade
     */
    'conid'?: string;
    /**
     * conid and exchange. Format supports conid or conid@exchange
     * @type {string}
     * @memberof Trade
     */
    'conidex'?: string;
    /**
     * Total quantity owned for this contract
     * @type {string}
     * @memberof Trade
     */
    'position'?: string;
    /**
     * Firm which will settle the trade. For IBExecution customers only.
     * @type {string}
     * @memberof Trade
     */
    'clearing_id'?: string;
    /**
     * Specifies the true beneficiary of the order. For IBExecution customers only.
     * @type {string}
     * @memberof Trade
     */
    'clearing_name'?: string;
    /**
     * If order adds liquidity to the market.
     * @type {number}
     * @memberof Trade
     */
    'liquidation_trade'?: number;
}

export const TradeSideEnum = {
    B: 'B',
    S: 'S',
    X: 'X'
} as const;

export type TradeSideEnum = typeof TradeSideEnum[keyof typeof TradeSideEnum];

/**
 * account transactions
 * @export
 * @interface Transactions
 */
export interface Transactions {
    /**
     * will always be getTransactions
     * @type {string}
     * @memberof Transactions
     */
    'id'?: string;
    /**
     * same as request
     * @type {string}
     * @memberof Transactions
     */
    'currency'?: string;
    /**
     * Indicates whether current day and realtime data is included in the result
     * @type {boolean}
     * @memberof Transactions
     */
    'includesRealTime'?: boolean;
    /**
     * Period start date. Epoch time, GMT
     * @type {number}
     * @memberof Transactions
     */
    'from'?: number;
    /**
     * Period end date. Epoch time, GMT
     * @type {number}
     * @memberof Transactions
     */
    'to'?: number;
    /**
     * Sorted by date descending
     * @type {Array<TransactionsTransactionsInner>}
     * @memberof Transactions
     */
    'transactions'?: Array<TransactionsTransactionsInner>;
}
/**
 * 
 * @export
 * @interface TransactionsTransactionsInner
 */
export interface TransactionsTransactionsInner {
    /**
     * 
     * @type {string}
     * @memberof TransactionsTransactionsInner
     */
    'acctid'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionsTransactionsInner
     */
    'conid'?: number;
    /**
     * currency code
     * @type {string}
     * @memberof TransactionsTransactionsInner
     */
    'cur'?: string;
    /**
     * Conversion rate from asset currency to response currency
     * @type {number}
     * @memberof TransactionsTransactionsInner
     */
    'fxRate'?: number;
    /**
     * Transaction description
     * @type {string}
     * @memberof TransactionsTransactionsInner
     */
    'desc'?: string;
    /**
     * Date of transaction.  Epoch time, GMT
     * @type {string}
     * @memberof TransactionsTransactionsInner
     */
    'date'?: string;
    /**
     * Transaction Type Name: Examples: \"Sell\", \"Buy\", \"Corporate Action\", \"Dividend Payment\", \"Transfer\", \"Payment in Lieu\" Dividends and Transfers do not have price and quantity in response 
     * @type {string}
     * @memberof TransactionsTransactionsInner
     */
    'type'?: string;
    /**
     * Not applicable for all transaction types
     * @type {number}
     * @memberof TransactionsTransactionsInner
     */
    'qty'?: number;
    /**
     * In asset currency. Not be applicable for all transaction types.
     * @type {number}
     * @memberof TransactionsTransactionsInner
     */
    'pr'?: number;
    /**
     * Raw value, no formatting. Net transaction amount (may include commission, tax). In asset currency
     * @type {number}
     * @memberof TransactionsTransactionsInner
     */
    'amt'?: number;
}
/**
 * 
 * @export
 * @interface TrsrvFuturesGet200Response
 */
export interface TrsrvFuturesGet200Response {
    /**
     * 
     * @type {Array<FuturesInner>}
     * @memberof TrsrvFuturesGet200Response
     */
    'symbol'?: Array<FuturesInner>;
}
/**
 * 
 * @export
 * @interface TrsrvFuturesGet500Response
 */
export interface TrsrvFuturesGet500Response {
    /**
     * 
     * @type {string}
     * @memberof TrsrvFuturesGet500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface TrsrvSecdefPostRequest
 */
export interface TrsrvSecdefPostRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof TrsrvSecdefPostRequest
     */
    'conids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface TrsrvSecdefScheduleGet200Response
 */
export interface TrsrvSecdefScheduleGet200Response {
    /**
     * Exchange parameter id
     * @type {string}
     * @memberof TrsrvSecdefScheduleGet200Response
     */
    'id'?: string;
    /**
     * Reference on a trade venue of given exchange parameter
     * @type {string}
     * @memberof TrsrvSecdefScheduleGet200Response
     */
    'tradeVenueId'?: string;
    /**
     * Always contains at least one \'tradingTime\'  and zero or more \'sessionTime\' tags
     * @type {Array<TrsrvSecdefScheduleGet200ResponseSchedulesInner>}
     * @memberof TrsrvSecdefScheduleGet200Response
     */
    'schedules'?: Array<TrsrvSecdefScheduleGet200ResponseSchedulesInner>;
}
/**
 * 
 * @export
 * @interface TrsrvSecdefScheduleGet200ResponseSchedulesInner
 */
export interface TrsrvSecdefScheduleGet200ResponseSchedulesInner {
    /**
     * 
     * @type {number}
     * @memberof TrsrvSecdefScheduleGet200ResponseSchedulesInner
     */
    'clearingCycleEndTime'?: number;
    /**
     * 20000101 stands for any Sat, 20000102 stands for any Sun, ... 20000107 stands for any Fri. Any other date stands for itself.
     * @type {number}
     * @memberof TrsrvSecdefScheduleGet200ResponseSchedulesInner
     */
    'tradingScheduleDate'?: number;
    /**
     * 
     * @type {TrsrvSecdefScheduleGet200ResponseSchedulesInnerSessions}
     * @memberof TrsrvSecdefScheduleGet200ResponseSchedulesInner
     */
    'sessions'?: TrsrvSecdefScheduleGet200ResponseSchedulesInnerSessions;
    /**
     * 
     * @type {TrsrvSecdefScheduleGet200ResponseSchedulesInnerTradingTimes}
     * @memberof TrsrvSecdefScheduleGet200ResponseSchedulesInner
     */
    'tradingTimes'?: TrsrvSecdefScheduleGet200ResponseSchedulesInnerTradingTimes;
}
/**
 * If the LIQUID hours differs from the total trading day then a separate \'session\' tag is returned.
 * @export
 * @interface TrsrvSecdefScheduleGet200ResponseSchedulesInnerSessions
 */
export interface TrsrvSecdefScheduleGet200ResponseSchedulesInnerSessions {
    /**
     * 
     * @type {number}
     * @memberof TrsrvSecdefScheduleGet200ResponseSchedulesInnerSessions
     */
    'openingTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof TrsrvSecdefScheduleGet200ResponseSchedulesInnerSessions
     */
    'closingTime'?: number;
    /**
     * If the whole trading day is considered LIQUID then the value \'LIQUID\' is returned.
     * @type {string}
     * @memberof TrsrvSecdefScheduleGet200ResponseSchedulesInnerSessions
     */
    'prop'?: string;
}
/**
 * Returns tradingTime in exchange time zone.
 * @export
 * @interface TrsrvSecdefScheduleGet200ResponseSchedulesInnerTradingTimes
 */
export interface TrsrvSecdefScheduleGet200ResponseSchedulesInnerTradingTimes {
    /**
     * 
     * @type {number}
     * @memberof TrsrvSecdefScheduleGet200ResponseSchedulesInnerTradingTimes
     */
    'openingTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof TrsrvSecdefScheduleGet200ResponseSchedulesInnerTradingTimes
     */
    'closingTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof TrsrvSecdefScheduleGet200ResponseSchedulesInnerTradingTimes
     */
    'cancelDayOrders'?: string;
}
/**
 * 
 * @export
 * @interface TrsrvStocksGet200Response
 */
export interface TrsrvStocksGet200Response {
    /**
     * This is an array of object(s), there could be multiple results under same symbol 
     * @type {Array<StocksInner>}
     * @memberof TrsrvStocksGet200Response
     */
    'symbol'?: Array<StocksInner>;
}
/**
 * List of wagers
 * @export
 * @interface WagersInner
 */
export interface WagersInner {
    /**
     * 
     * @type {number}
     * @memberof WagersInner
     */
    'conid'?: number;
    /**
     * 
     * @type {string}
     * @memberof WagersInner
     */
    'curr'?: string;
    /**
     * 
     * @type {string}
     * @memberof WagersInner
     */
    'desc'?: string;
    /**
     * 
     * @type {string}
     * @memberof WagersInner
     */
    'part'?: string;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary PnL for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPnlPartitionedGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iserver/account/pnl/partitioned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If an user has multiple accounts, and user wants to get orders, trades, etc. of an account other than currently selected account, then user can update the currently selected account using this API and then can fetch required information for the newly updated account.
         * @summary Switch Account
         * @param {SetAccount} body account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPost: async (body: SetAccount, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('iserverAccountPost', 'body', body)
            const localVarPath = `/iserver/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders.
         * @summary Brokerage Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iserver/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
         * @summary Account Ledger
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdLedgerGet: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('portfolioAccountIdLedgerGet', 'accountId', accountId)
            const localVarPath = `/portfolio/{accountId}/ledger`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Information
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdMetaGet: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('portfolioAccountIdMetaGet', 'accountId', accountId)
            const localVarPath = `/portfolio/{accountId}/meta`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Summary
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdSummaryGet: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('portfolioAccountIdSummaryGet', 'accountId', accountId)
            const localVarPath = `/portfolio/{accountId}/summary`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior to calling other /portfolio endpoints for those accounts. For querying a list of accounts which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
         * @summary Portfolio Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of sub-accounts, paginated up to 20 accounts per page, for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have less than 100 sub-accounts use /portfolio/subaccounts. To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts (Large Accounts)
         * @param {string} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioSubaccounts2Get: async (page: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('portfolioSubaccounts2Get', 'page', page)
            const localVarPath = `/portfolio/subaccounts2`
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of up to 100 sub-accounts for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have more than 100 sub-accounts use /portfolio/subaccounts2. To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioSubaccountsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/subaccounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary PnL for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountPnlPartitionedGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverAccountPnlPartitionedGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountPnlPartitionedGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If an user has multiple accounts, and user wants to get orders, trades, etc. of an account other than currently selected account, then user can update the currently selected account using this API and then can fetch required information for the newly updated account.
         * @summary Switch Account
         * @param {SetAccount} body account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountPost(body: SetAccount, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverAccountPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders.
         * @summary Brokerage Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverAccountsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
         * @summary Account Ledger
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioAccountIdLedgerGet(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioAccountIdLedgerGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioAccountIdLedgerGet(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Information
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioAccountIdMetaGet(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioAccountIdMetaGet(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Summary
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioAccountIdSummaryGet(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioAccountIdSummaryGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioAccountIdSummaryGet(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior to calling other /portfolio endpoints for those accounts. For querying a list of accounts which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
         * @summary Portfolio Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioAccountsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioAccountsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of sub-accounts, paginated up to 20 accounts per page, for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have less than 100 sub-accounts use /portfolio/subaccounts. To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts (Large Accounts)
         * @param {string} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioSubaccounts2Get(page: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioSubaccounts2Get200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioSubaccounts2Get(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of up to 100 sub-accounts for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have more than 100 sub-accounts use /portfolio/subaccounts2. To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioSubaccountsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioSubaccountsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary PnL for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPnlPartitionedGet(options?: any): AxiosPromise<IserverAccountPnlPartitionedGet200Response> {
            return localVarFp.iserverAccountPnlPartitionedGet(options).then((request) => request(axios, basePath));
        },
        /**
         * If an user has multiple accounts, and user wants to get orders, trades, etc. of an account other than currently selected account, then user can update the currently selected account using this API and then can fetch required information for the newly updated account.
         * @summary Switch Account
         * @param {SetAccount} body account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPost(body: SetAccount, options?: any): AxiosPromise<IserverAccountPost200Response> {
            return localVarFp.iserverAccountPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders.
         * @summary Brokerage Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountsGet(options?: any): AxiosPromise<IserverAccountsGet200Response> {
            return localVarFp.iserverAccountsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
         * @summary Account Ledger
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdLedgerGet(accountId: string, options?: any): AxiosPromise<PortfolioAccountIdLedgerGet200Response> {
            return localVarFp.portfolioAccountIdLedgerGet(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Information
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdMetaGet(accountId: string, options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.portfolioAccountIdMetaGet(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Summary
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdSummaryGet(accountId: string, options?: any): AxiosPromise<PortfolioAccountIdSummaryGet200Response> {
            return localVarFp.portfolioAccountIdSummaryGet(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior to calling other /portfolio endpoints for those accounts. For querying a list of accounts which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
         * @summary Portfolio Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountsGet(options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.portfolioAccountsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of sub-accounts, paginated up to 20 accounts per page, for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have less than 100 sub-accounts use /portfolio/subaccounts. To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts (Large Accounts)
         * @param {string} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioSubaccounts2Get(page: string, options?: any): AxiosPromise<PortfolioSubaccounts2Get200Response> {
            return localVarFp.portfolioSubaccounts2Get(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of up to 100 sub-accounts for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have more than 100 sub-accounts use /portfolio/subaccounts2. To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioSubaccountsGet(options?: any): AxiosPromise<Account> {
            return localVarFp.portfolioSubaccountsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
     * @summary PnL for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public iserverAccountPnlPartitionedGet(options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).iserverAccountPnlPartitionedGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If an user has multiple accounts, and user wants to get orders, trades, etc. of an account other than currently selected account, then user can update the currently selected account using this API and then can fetch required information for the newly updated account.
     * @summary Switch Account
     * @param {SetAccount} body account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public iserverAccountPost(body: SetAccount, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).iserverAccountPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders.
     * @summary Brokerage Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public iserverAccountsGet(options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).iserverAccountsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
     * @summary Account Ledger
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public portfolioAccountIdLedgerGet(accountId: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).portfolioAccountIdLedgerGet(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Information
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public portfolioAccountIdMetaGet(accountId: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).portfolioAccountIdMetaGet(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Summary
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public portfolioAccountIdSummaryGet(accountId: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).portfolioAccountIdSummaryGet(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior to calling other /portfolio endpoints for those accounts. For querying a list of accounts which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
     * @summary Portfolio Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public portfolioAccountsGet(options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).portfolioAccountsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of sub-accounts, paginated up to 20 accounts per page, for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have less than 100 sub-accounts use /portfolio/subaccounts. To query a list of accounts the user can trade, see /iserver/accounts.
     * @summary List of Sub-Accounts (Large Accounts)
     * @param {string} page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public portfolioSubaccounts2Get(page: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).portfolioSubaccounts2Get(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of up to 100 sub-accounts for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have more than 100 sub-accounts use /portfolio/subaccounts2. To query a list of accounts the user can trade, see /iserver/accounts.
     * @summary List of Sub-Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public portfolioSubaccountsGet(options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).portfolioSubaccountsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlertApi - axios parameter creator
 * @export
 */
export const AlertApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Please note, if alertId is 0, it will activate/deactivate all alerts
         * @summary Activate or deactivate an alert
         * @param {string} accountId account id
         * @param {IserverAccountAccountIdAlertActivatePostRequest} body order request info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertActivatePost: async (accountId: string, body: IserverAccountAccountIdAlertActivatePostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('iserverAccountAccountIdAlertActivatePost', 'accountId', accountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('iserverAccountAccountIdAlertActivatePost', 'body', body)
            const localVarPath = `/iserver/account/:accountId/alert/activate`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Please be careful, if alertId is 0, it will delete all alerts
         * @summary Delete an alert
         * @param {string} accountId account id
         * @param {string} alertId alert id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertAlertIdDelete: async (accountId: string, alertId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('iserverAccountAccountIdAlertAlertIdDelete', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('iserverAccountAccountIdAlertAlertIdDelete', 'alertId', alertId)
            const localVarPath = `/iserver/account/:accountId/alert/:alertId`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Please note here, DO NOT pass orderId when creating a new alert, toolId is only required for MTA alert 
         * @summary Create or modify alert
         * @param {string} accountId account id
         * @param {AlertRequest} body alert info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertPost: async (accountId: string, body: AlertRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('iserverAccountAccountIdAlertPost', 'accountId', accountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('iserverAccountAccountIdAlertPost', 'body', body)
            const localVarPath = `/iserver/account/{accountId}/alert`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The response will contain both active and inactive alerts, but it won\'t have MTA alert
         * @summary Get a list of available alerts
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertsGet: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('iserverAccountAccountIdAlertsGet', 'accountId', accountId)
            const localVarPath = `/iserver/account/:accountId/alerts`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use the endpoint /iserver/account/:accountId/alerts to receive the alert id. The order_id in the response is the alert id. 
         * @summary Get details of an alert
         * @param {string} id alert id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAlertIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('iserverAccountAlertIdGet', 'id', id)
            const localVarPath = `/iserver/account/alert/:id`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Each login user only has one mobile trading assistant (MTA) alert with it\'s own unique tool id. The tool id cannot be changed. When modified a new order Id is generated. MTA alerts can not be created or deleted. If you call delete /iserver/account/:accountId/alert/:alertId, it will reset MTA to default. See [here](https://www.interactivebrokers.com/en/software/mobileiphonemobile/mobileiphone.htm#monitor/trading-assistant.htm) for more information on MTA alerts. 
         * @summary Get MTA alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountMtaGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iserver/account/mta`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertApi - functional programming interface
 * @export
 */
export const AlertApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertApiAxiosParamCreator(configuration)
    return {
        /**
         * Please note, if alertId is 0, it will activate/deactivate all alerts
         * @summary Activate or deactivate an alert
         * @param {string} accountId account id
         * @param {IserverAccountAccountIdAlertActivatePostRequest} body order request info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountAccountIdAlertActivatePost(accountId: string, body: IserverAccountAccountIdAlertActivatePostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverAccountAccountIdAlertActivatePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountAccountIdAlertActivatePost(accountId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Please be careful, if alertId is 0, it will delete all alerts
         * @summary Delete an alert
         * @param {string} accountId account id
         * @param {string} alertId alert id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountAccountIdAlertAlertIdDelete(accountId: string, alertId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverAccountAccountIdAlertActivatePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountAccountIdAlertAlertIdDelete(accountId, alertId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Please note here, DO NOT pass orderId when creating a new alert, toolId is only required for MTA alert 
         * @summary Create or modify alert
         * @param {string} accountId account id
         * @param {AlertRequest} body alert info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountAccountIdAlertPost(accountId: string, body: AlertRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverAccountAccountIdAlertPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountAccountIdAlertPost(accountId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The response will contain both active and inactive alerts, but it won\'t have MTA alert
         * @summary Get a list of available alerts
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountAccountIdAlertsGet(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IserverAccountAccountIdAlertsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountAccountIdAlertsGet(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use the endpoint /iserver/account/:accountId/alerts to receive the alert id. The order_id in the response is the alert id. 
         * @summary Get details of an alert
         * @param {string} id alert id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountAlertIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountAlertIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Each login user only has one mobile trading assistant (MTA) alert with it\'s own unique tool id. The tool id cannot be changed. When modified a new order Id is generated. MTA alerts can not be created or deleted. If you call delete /iserver/account/:accountId/alert/:alertId, it will reset MTA to default. See [here](https://www.interactivebrokers.com/en/software/mobileiphonemobile/mobileiphone.htm#monitor/trading-assistant.htm) for more information on MTA alerts. 
         * @summary Get MTA alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountMtaGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountMtaGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlertApi - factory interface
 * @export
 */
export const AlertApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertApiFp(configuration)
    return {
        /**
         * Please note, if alertId is 0, it will activate/deactivate all alerts
         * @summary Activate or deactivate an alert
         * @param {string} accountId account id
         * @param {IserverAccountAccountIdAlertActivatePostRequest} body order request info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertActivatePost(accountId: string, body: IserverAccountAccountIdAlertActivatePostRequest, options?: any): AxiosPromise<IserverAccountAccountIdAlertActivatePost200Response> {
            return localVarFp.iserverAccountAccountIdAlertActivatePost(accountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Please be careful, if alertId is 0, it will delete all alerts
         * @summary Delete an alert
         * @param {string} accountId account id
         * @param {string} alertId alert id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertAlertIdDelete(accountId: string, alertId: string, options?: any): AxiosPromise<IserverAccountAccountIdAlertActivatePost200Response> {
            return localVarFp.iserverAccountAccountIdAlertAlertIdDelete(accountId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Please note here, DO NOT pass orderId when creating a new alert, toolId is only required for MTA alert 
         * @summary Create or modify alert
         * @param {string} accountId account id
         * @param {AlertRequest} body alert info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertPost(accountId: string, body: AlertRequest, options?: any): AxiosPromise<IserverAccountAccountIdAlertPost200Response> {
            return localVarFp.iserverAccountAccountIdAlertPost(accountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * The response will contain both active and inactive alerts, but it won\'t have MTA alert
         * @summary Get a list of available alerts
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertsGet(accountId: string, options?: any): AxiosPromise<Array<IserverAccountAccountIdAlertsGet200ResponseInner>> {
            return localVarFp.iserverAccountAccountIdAlertsGet(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use the endpoint /iserver/account/:accountId/alerts to receive the alert id. The order_id in the response is the alert id. 
         * @summary Get details of an alert
         * @param {string} id alert id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAlertIdGet(id: string, options?: any): AxiosPromise<AlertResponse> {
            return localVarFp.iserverAccountAlertIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Each login user only has one mobile trading assistant (MTA) alert with it\'s own unique tool id. The tool id cannot be changed. When modified a new order Id is generated. MTA alerts can not be created or deleted. If you call delete /iserver/account/:accountId/alert/:alertId, it will reset MTA to default. See [here](https://www.interactivebrokers.com/en/software/mobileiphonemobile/mobileiphone.htm#monitor/trading-assistant.htm) for more information on MTA alerts. 
         * @summary Get MTA alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountMtaGet(options?: any): AxiosPromise<AlertResponse> {
            return localVarFp.iserverAccountMtaGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertApi - object-oriented interface
 * @export
 * @class AlertApi
 * @extends {BaseAPI}
 */
export class AlertApi extends BaseAPI {
    /**
     * Please note, if alertId is 0, it will activate/deactivate all alerts
     * @summary Activate or deactivate an alert
     * @param {string} accountId account id
     * @param {IserverAccountAccountIdAlertActivatePostRequest} body order request info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public iserverAccountAccountIdAlertActivatePost(accountId: string, body: IserverAccountAccountIdAlertActivatePostRequest, options?: AxiosRequestConfig) {
        return AlertApiFp(this.configuration).iserverAccountAccountIdAlertActivatePost(accountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Please be careful, if alertId is 0, it will delete all alerts
     * @summary Delete an alert
     * @param {string} accountId account id
     * @param {string} alertId alert id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public iserverAccountAccountIdAlertAlertIdDelete(accountId: string, alertId: string, options?: AxiosRequestConfig) {
        return AlertApiFp(this.configuration).iserverAccountAccountIdAlertAlertIdDelete(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Please note here, DO NOT pass orderId when creating a new alert, toolId is only required for MTA alert 
     * @summary Create or modify alert
     * @param {string} accountId account id
     * @param {AlertRequest} body alert info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public iserverAccountAccountIdAlertPost(accountId: string, body: AlertRequest, options?: AxiosRequestConfig) {
        return AlertApiFp(this.configuration).iserverAccountAccountIdAlertPost(accountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The response will contain both active and inactive alerts, but it won\'t have MTA alert
     * @summary Get a list of available alerts
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public iserverAccountAccountIdAlertsGet(accountId: string, options?: AxiosRequestConfig) {
        return AlertApiFp(this.configuration).iserverAccountAccountIdAlertsGet(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use the endpoint /iserver/account/:accountId/alerts to receive the alert id. The order_id in the response is the alert id. 
     * @summary Get details of an alert
     * @param {string} id alert id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public iserverAccountAlertIdGet(id: string, options?: AxiosRequestConfig) {
        return AlertApiFp(this.configuration).iserverAccountAlertIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Each login user only has one mobile trading assistant (MTA) alert with it\'s own unique tool id. The tool id cannot be changed. When modified a new order Id is generated. MTA alerts can not be created or deleted. If you call delete /iserver/account/:accountId/alert/:alertId, it will reset MTA to default. See [here](https://www.interactivebrokers.com/en/software/mobileiphonemobile/mobileiphone.htm#monitor/trading-assistant.htm) for more information on MTA alerts. 
     * @summary Get MTA alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public iserverAccountMtaGet(options?: AxiosRequestConfig) {
        return AlertApiFp(this.configuration).iserverAccountMtaGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CCPBetaApi - axios parameter creator
 * @export
 */
export const CCPBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides the list of tradeable accounts
         * @summary Brokerage Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAccountGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ccp/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
         * @summary Start CCP Session
         * @param {boolean} [compete] Allow competing CCP session to run
         * @param {string} [locale] Concatenate value for language and region, set to \\\&quot;en_US\\\&quot;
         * @param {string} [mac] Local MAC Address
         * @param {string} [machineId] Local machine ID
         * @param {string} [username] Login user, set to dash \\\&quot;-\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAuthInitPost: async (compete?: boolean, locale?: string, mac?: string, machineId?: string, username?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ccp/auth/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (compete !== undefined) { 
                localVarFormParams.set('compete', compete as any);
            }
    
            if (locale !== undefined) { 
                localVarFormParams.set('locale', locale as any);
            }
    
            if (mac !== undefined) { 
                localVarFormParams.set('mac', mac as any);
            }
    
            if (machineId !== undefined) { 
                localVarFormParams.set('machineId', machineId as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Session Token Authentication
         * @summary Complete CCP Session
         * @param {CcpAuthResponsePostRequest} [auth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAuthResponsePost: async (auth?: CcpAuthResponsePostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ccp/auth/response`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(auth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only) 
         * @summary Delete Order
         * @param {string} acct Account Number
         * @param {number} id Order Identifier of original submit order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderDelete: async (acct: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acct' is not null or undefined
            assertParamExists('ccpOrderDelete', 'acct', acct)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ccpOrderDelete', 'id', id)
            const localVarPath = `/ccp/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acct !== undefined) {
                localVarQueryParameter['acct'] = acct;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits an Order. 
         * @summary Submit Order
         * @param {string} acct User Account
         * @param {number} conid Contract identifier from IBKR\&#39;s database.
         * @param {'USD' | 'GBP' | 'EUR'} ccy Contract Currency
         * @param {'NYSE' | 'CBOE' | 'NYMEX'} exchange Exchange
         * @param {number} qty Order Quantity
         * @param {'limit' | 'market'} [type] Order Price; required if order type is limit
         * @param {'sell' | 'buy'} [side] Side
         * @param {number} [price] Order Price; required if order type is limit
         * @param {'IOC' | 'GTC'} [tif] Time in Force
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderPost: async (acct: string, conid: number, ccy: 'USD' | 'GBP' | 'EUR', exchange: 'NYSE' | 'CBOE' | 'NYMEX', qty: number, type?: 'limit' | 'market', side?: 'sell' | 'buy', price?: number, tif?: 'IOC' | 'GTC', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acct' is not null or undefined
            assertParamExists('ccpOrderPost', 'acct', acct)
            // verify required parameter 'conid' is not null or undefined
            assertParamExists('ccpOrderPost', 'conid', conid)
            // verify required parameter 'ccy' is not null or undefined
            assertParamExists('ccpOrderPost', 'ccy', ccy)
            // verify required parameter 'exchange' is not null or undefined
            assertParamExists('ccpOrderPost', 'exchange', exchange)
            // verify required parameter 'qty' is not null or undefined
            assertParamExists('ccpOrderPost', 'qty', qty)
            const localVarPath = `/ccp/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acct !== undefined) {
                localVarQueryParameter['acct'] = acct;
            }

            if (conid !== undefined) {
                localVarQueryParameter['conid'] = conid;
            }

            if (ccy !== undefined) {
                localVarQueryParameter['ccy'] = ccy;
            }

            if (exchange !== undefined) {
                localVarQueryParameter['exchange'] = exchange;
            }

            if (qty !== undefined) {
                localVarQueryParameter['qty'] = qty;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (side !== undefined) {
                localVarQueryParameter['side'] = side;
            }

            if (price !== undefined) {
                localVarQueryParameter['price'] = price;
            }

            if (tif !== undefined) {
                localVarQueryParameter['tif'] = tif;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order. 
         * @summary Update Order
         * @param {string} acct User Account
         * @param {number} id Order ID to be modified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderPut: async (acct: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acct' is not null or undefined
            assertParamExists('ccpOrderPut', 'acct', acct)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ccpOrderPut', 'id', id)
            const localVarPath = `/ccp/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acct !== undefined) {
                localVarQueryParameter['acct'] = acct;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status for all orders
         * @summary Order Status
         * @param {string} acct User Account
         * @param {boolean} [cancelled] Return only Rejected or Cancelled orders since today midnight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrdersGet: async (acct: string, cancelled?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acct' is not null or undefined
            assertParamExists('ccpOrdersGet', 'acct', acct)
            const localVarPath = `/ccp/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acct !== undefined) {
                localVarQueryParameter['acct'] = acct;
            }

            if (cancelled !== undefined) {
                localVarQueryParameter['cancelled'] = cancelled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of positions
         * @summary Positions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpPositionsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ccp/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.
         * @summary CCP Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpStatusGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ccp/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Trades, by default, the list is from today midnight to Date.now(). 
         * @summary Trades
         * @param {string} [from] From Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..)
         * @param {string} [to] To Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..). To value should be bigger than from value. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpTradesGet: async (from?: string, to?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ccp/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CCPBetaApi - functional programming interface
 * @export
 */
export const CCPBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CCPBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Provides the list of tradeable accounts
         * @summary Brokerage Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ccpAccountGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CcpAccountGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ccpAccountGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
         * @summary Start CCP Session
         * @param {boolean} [compete] Allow competing CCP session to run
         * @param {string} [locale] Concatenate value for language and region, set to \\\&quot;en_US\\\&quot;
         * @param {string} [mac] Local MAC Address
         * @param {string} [machineId] Local machine ID
         * @param {string} [username] Login user, set to dash \\\&quot;-\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ccpAuthInitPost(compete?: boolean, locale?: string, mac?: string, machineId?: string, username?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CcpAuthInitPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ccpAuthInitPost(compete, locale, mac, machineId, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Session Token Authentication
         * @summary Complete CCP Session
         * @param {CcpAuthResponsePostRequest} [auth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ccpAuthResponsePost(auth?: CcpAuthResponsePostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CcpAuthResponsePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ccpAuthResponsePost(auth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only) 
         * @summary Delete Order
         * @param {string} acct Account Number
         * @param {number} id Order Identifier of original submit order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ccpOrderDelete(acct: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ccpOrderDelete(acct, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submits an Order. 
         * @summary Submit Order
         * @param {string} acct User Account
         * @param {number} conid Contract identifier from IBKR\&#39;s database.
         * @param {'USD' | 'GBP' | 'EUR'} ccy Contract Currency
         * @param {'NYSE' | 'CBOE' | 'NYMEX'} exchange Exchange
         * @param {number} qty Order Quantity
         * @param {'limit' | 'market'} [type] Order Price; required if order type is limit
         * @param {'sell' | 'buy'} [side] Side
         * @param {number} [price] Order Price; required if order type is limit
         * @param {'IOC' | 'GTC'} [tif] Time in Force
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ccpOrderPost(acct: string, conid: number, ccy: 'USD' | 'GBP' | 'EUR', exchange: 'NYSE' | 'CBOE' | 'NYMEX', qty: number, type?: 'limit' | 'market', side?: 'sell' | 'buy', price?: number, tif?: 'IOC' | 'GTC', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ccpOrderPost(acct, conid, ccy, exchange, qty, type, side, price, tif, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order. 
         * @summary Update Order
         * @param {string} acct User Account
         * @param {number} id Order ID to be modified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ccpOrderPut(acct: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ccpOrderPut(acct, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get status for all orders
         * @summary Order Status
         * @param {string} acct User Account
         * @param {boolean} [cancelled] Return only Rejected or Cancelled orders since today midnight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ccpOrdersGet(acct: string, cancelled?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CcpOrdersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ccpOrdersGet(acct, cancelled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List of positions
         * @summary Positions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ccpPositionsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ccpPositionsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.
         * @summary CCP Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ccpStatusGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CcpStatusGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ccpStatusGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of Trades, by default, the list is from today midnight to Date.now(). 
         * @summary Trades
         * @param {string} [from] From Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..)
         * @param {string} [to] To Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..). To value should be bigger than from value. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ccpTradesGet(from?: string, to?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CcpOrdersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ccpTradesGet(from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CCPBetaApi - factory interface
 * @export
 */
export const CCPBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CCPBetaApiFp(configuration)
    return {
        /**
         * Provides the list of tradeable accounts
         * @summary Brokerage Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAccountGet(options?: any): AxiosPromise<CcpAccountGet200Response> {
            return localVarFp.ccpAccountGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
         * @summary Start CCP Session
         * @param {boolean} [compete] Allow competing CCP session to run
         * @param {string} [locale] Concatenate value for language and region, set to \\\&quot;en_US\\\&quot;
         * @param {string} [mac] Local MAC Address
         * @param {string} [machineId] Local machine ID
         * @param {string} [username] Login user, set to dash \\\&quot;-\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAuthInitPost(compete?: boolean, locale?: string, mac?: string, machineId?: string, username?: string, options?: any): AxiosPromise<CcpAuthInitPost200Response> {
            return localVarFp.ccpAuthInitPost(compete, locale, mac, machineId, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Session Token Authentication
         * @summary Complete CCP Session
         * @param {CcpAuthResponsePostRequest} [auth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAuthResponsePost(auth?: CcpAuthResponsePostRequest, options?: any): AxiosPromise<CcpAuthResponsePost200Response> {
            return localVarFp.ccpAuthResponsePost(auth, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only) 
         * @summary Delete Order
         * @param {string} acct Account Number
         * @param {number} id Order Identifier of original submit order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderDelete(acct: string, id: number, options?: any): AxiosPromise<OrderData> {
            return localVarFp.ccpOrderDelete(acct, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits an Order. 
         * @summary Submit Order
         * @param {string} acct User Account
         * @param {number} conid Contract identifier from IBKR\&#39;s database.
         * @param {'USD' | 'GBP' | 'EUR'} ccy Contract Currency
         * @param {'NYSE' | 'CBOE' | 'NYMEX'} exchange Exchange
         * @param {number} qty Order Quantity
         * @param {'limit' | 'market'} [type] Order Price; required if order type is limit
         * @param {'sell' | 'buy'} [side] Side
         * @param {number} [price] Order Price; required if order type is limit
         * @param {'IOC' | 'GTC'} [tif] Time in Force
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderPost(acct: string, conid: number, ccy: 'USD' | 'GBP' | 'EUR', exchange: 'NYSE' | 'CBOE' | 'NYMEX', qty: number, type?: 'limit' | 'market', side?: 'sell' | 'buy', price?: number, tif?: 'IOC' | 'GTC', options?: any): AxiosPromise<OrderData> {
            return localVarFp.ccpOrderPost(acct, conid, ccy, exchange, qty, type, side, price, tif, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order. 
         * @summary Update Order
         * @param {string} acct User Account
         * @param {number} id Order ID to be modified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderPut(acct: string, id: number, options?: any): AxiosPromise<OrderData> {
            return localVarFp.ccpOrderPut(acct, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status for all orders
         * @summary Order Status
         * @param {string} acct User Account
         * @param {boolean} [cancelled] Return only Rejected or Cancelled orders since today midnight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrdersGet(acct: string, cancelled?: boolean, options?: any): AxiosPromise<CcpOrdersGet200Response> {
            return localVarFp.ccpOrdersGet(acct, cancelled, options).then((request) => request(axios, basePath));
        },
        /**
         * List of positions
         * @summary Positions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpPositionsGet(options?: any): AxiosPromise<PositionData> {
            return localVarFp.ccpPositionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.
         * @summary CCP Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpStatusGet(options?: any): AxiosPromise<CcpStatusGet200Response> {
            return localVarFp.ccpStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of Trades, by default, the list is from today midnight to Date.now(). 
         * @summary Trades
         * @param {string} [from] From Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..)
         * @param {string} [to] To Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..). To value should be bigger than from value. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpTradesGet(from?: string, to?: string, options?: any): AxiosPromise<CcpOrdersGet200Response> {
            return localVarFp.ccpTradesGet(from, to, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CCPBetaApi - object-oriented interface
 * @export
 * @class CCPBetaApi
 * @extends {BaseAPI}
 */
export class CCPBetaApi extends BaseAPI {
    /**
     * Provides the list of tradeable accounts
     * @summary Brokerage Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    public ccpAccountGet(options?: AxiosRequestConfig) {
        return CCPBetaApiFp(this.configuration).ccpAccountGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
     * @summary Start CCP Session
     * @param {boolean} [compete] Allow competing CCP session to run
     * @param {string} [locale] Concatenate value for language and region, set to \\\&quot;en_US\\\&quot;
     * @param {string} [mac] Local MAC Address
     * @param {string} [machineId] Local machine ID
     * @param {string} [username] Login user, set to dash \\\&quot;-\\\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    public ccpAuthInitPost(compete?: boolean, locale?: string, mac?: string, machineId?: string, username?: string, options?: AxiosRequestConfig) {
        return CCPBetaApiFp(this.configuration).ccpAuthInitPost(compete, locale, mac, machineId, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Session Token Authentication
     * @summary Complete CCP Session
     * @param {CcpAuthResponsePostRequest} [auth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    public ccpAuthResponsePost(auth?: CcpAuthResponsePostRequest, options?: AxiosRequestConfig) {
        return CCPBetaApiFp(this.configuration).ccpAuthResponsePost(auth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only) 
     * @summary Delete Order
     * @param {string} acct Account Number
     * @param {number} id Order Identifier of original submit order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    public ccpOrderDelete(acct: string, id: number, options?: AxiosRequestConfig) {
        return CCPBetaApiFp(this.configuration).ccpOrderDelete(acct, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits an Order. 
     * @summary Submit Order
     * @param {string} acct User Account
     * @param {number} conid Contract identifier from IBKR\&#39;s database.
     * @param {'USD' | 'GBP' | 'EUR'} ccy Contract Currency
     * @param {'NYSE' | 'CBOE' | 'NYMEX'} exchange Exchange
     * @param {number} qty Order Quantity
     * @param {'limit' | 'market'} [type] Order Price; required if order type is limit
     * @param {'sell' | 'buy'} [side] Side
     * @param {number} [price] Order Price; required if order type is limit
     * @param {'IOC' | 'GTC'} [tif] Time in Force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    public ccpOrderPost(acct: string, conid: number, ccy: 'USD' | 'GBP' | 'EUR', exchange: 'NYSE' | 'CBOE' | 'NYMEX', qty: number, type?: 'limit' | 'market', side?: 'sell' | 'buy', price?: number, tif?: 'IOC' | 'GTC', options?: AxiosRequestConfig) {
        return CCPBetaApiFp(this.configuration).ccpOrderPost(acct, conid, ccy, exchange, qty, type, side, price, tif, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order. 
     * @summary Update Order
     * @param {string} acct User Account
     * @param {number} id Order ID to be modified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    public ccpOrderPut(acct: string, id: number, options?: AxiosRequestConfig) {
        return CCPBetaApiFp(this.configuration).ccpOrderPut(acct, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status for all orders
     * @summary Order Status
     * @param {string} acct User Account
     * @param {boolean} [cancelled] Return only Rejected or Cancelled orders since today midnight
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    public ccpOrdersGet(acct: string, cancelled?: boolean, options?: AxiosRequestConfig) {
        return CCPBetaApiFp(this.configuration).ccpOrdersGet(acct, cancelled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of positions
     * @summary Positions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    public ccpPositionsGet(options?: AxiosRequestConfig) {
        return CCPBetaApiFp(this.configuration).ccpPositionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.
     * @summary CCP Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    public ccpStatusGet(options?: AxiosRequestConfig) {
        return CCPBetaApiFp(this.configuration).ccpStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of Trades, by default, the list is from today midnight to Date.now(). 
     * @summary Trades
     * @param {string} [from] From Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..)
     * @param {string} [to] To Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..). To value should be bigger than from value. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    public ccpTradesGet(from?: string, to?: string, options?: AxiosRequestConfig) {
        return CCPBetaApiFp(this.configuration).ccpTradesGet(from, to, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractApi - axios parameter creator
 * @export
 */
export const ContractApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns supported IB Algos for contract. Must be called a second time to query the list of available parameters.
         * @summary IB Algo Params
         * @param {string} conid IBKR contract identifier
         * @param {string} [algos] List of algo ids delimited by \&quot;;\&quot; to filter by. Max of 8 algos ids can be specified.
         * @param {string} [addDescription] Whether or not to add algo descriptions to response. Set to 1 for yes, 0 for no.
         * @param {string} [addParams] Whether or not to show algo parameters.  Set to 1 for yes, 0 for no.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidAlgosGet: async (conid: string, algos?: string, addDescription?: string, addParams?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conid' is not null or undefined
            assertParamExists('iserverContractConidAlgosGet', 'conid', conid)
            const localVarPath = `/iserver/contract/{conid}/algos`
                .replace(`{${"conid"}}`, encodeURIComponent(String(conid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (algos !== undefined) {
                localVarQueryParameter['algos'] = algos;
            }

            if (addDescription !== undefined) {
                localVarQueryParameter['addDescription'] = addDescription;
            }

            if (addParams !== undefined) {
                localVarQueryParameter['addParams'] = addParams;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns both contract info and rules from a single endpoint. For only contract rules, use the endpoint /iserver/contract/rules. For only contract info, use the endpoint /iserver/contract/{conid}/info.  
         * @summary Info and Rules
         * @param {string} conid IBKR contract identifier
         * @param {boolean} isBuy Side of the market rules apply too. Set to **true** for Buy Orders, set to **false** for Sell Orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidInfoAndRulesGet: async (conid: string, isBuy: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conid' is not null or undefined
            assertParamExists('iserverContractConidInfoAndRulesGet', 'conid', conid)
            // verify required parameter 'isBuy' is not null or undefined
            assertParamExists('iserverContractConidInfoAndRulesGet', 'isBuy', isBuy)
            const localVarPath = `/iserver/contract/{conid}/info-and-rules`
                .replace(`{${"conid"}}`, encodeURIComponent(String(conid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isBuy !== undefined) {
                localVarQueryParameter['isBuy'] = isBuy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Using the Contract Identifier get contract info. You can use this to prefill your order before you submit an order
         * @summary Contract Details
         * @param {string} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidInfoGet: async (conid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conid' is not null or undefined
            assertParamExists('iserverContractConidInfoGet', 'conid', conid)
            const localVarPath = `/iserver/contract/{conid}/info`
                .replace(`{${"conid"}}`, encodeURIComponent(String(conid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns trading related rules for a specific contract and side. For both contract info and rules use the endpoint /iserver/contract/{conid}/info-and-rules.
         * @summary Contract Rules
         * @param {IserverContractRulesPostRequest} conid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractRulesPost: async (conid: IserverContractRulesPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conid' is not null or undefined
            assertParamExists('iserverContractRulesPost', 'conid', conid)
            const localVarPath = `/iserver/contract/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conid, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides Contract Details of Futures, Options, Warrants, Cash and CFDs based on conid. To get the strike price for Options/Warrants use \"/iserver/secdef/strikes\" endpoint. Must call /secdef/search for the underlying contract first.
         * @summary Secdef Info
         * @param {string} conid underlying contract id
         * @param {string} sectype FUT/OPT/WAR/CASH/CFD
         * @param {string} [month] contract month, only required for FUT/OPT/WAR in the format MMMYY, example JAN00
         * @param {string} [exchange] optional, default is SMART
         * @param {number} [strike] optional, only required for OPT/WAR
         * @param {string} [right] C for call, P for put
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefInfoGet: async (conid: string, sectype: string, month?: string, exchange?: string, strike?: number, right?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conid' is not null or undefined
            assertParamExists('iserverSecdefInfoGet', 'conid', conid)
            // verify required parameter 'sectype' is not null or undefined
            assertParamExists('iserverSecdefInfoGet', 'sectype', sectype)
            const localVarPath = `/iserver/secdef/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (conid !== undefined) {
                localVarQueryParameter['conid'] = conid;
            }

            if (sectype !== undefined) {
                localVarQueryParameter['sectype'] = sectype;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (exchange !== undefined) {
                localVarQueryParameter['exchange'] = exchange;
            }

            if (strike !== undefined) {
                localVarQueryParameter['strike'] = strike;
            }

            if (right !== undefined) {
                localVarQueryParameter['right'] = right;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search by underlying symbol or company name. Relays back what derivative contract(s) it has. This endpoint must be called before using /secdef/info. If company name is specified will only receive limited response: conid, companyName, companyHeader and symbol. 
         * @summary Search by Symbol or Name
         * @param {IserverSecdefSearchPostRequest} symbol Symbol or Company Name to be searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefSearchPost: async (symbol: IserverSecdefSearchPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('iserverSecdefSearchPost', 'symbol', symbol)
            const localVarPath = `/iserver/secdef/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(symbol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query strikes for Options/Warrants. For the conid of the underlying contract, available contract months and exchanges use \"/iserver/secdef/search\"
         * @summary Search Strikes
         * @param {string} conid contract id of the underlying contract
         * @param {string} sectype OPT/WAR
         * @param {string} month contract month
         * @param {string} [exchange] optional, default is SMART
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefStrikesGet: async (conid: string, sectype: string, month: string, exchange?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conid' is not null or undefined
            assertParamExists('iserverSecdefStrikesGet', 'conid', conid)
            // verify required parameter 'sectype' is not null or undefined
            assertParamExists('iserverSecdefStrikesGet', 'sectype', sectype)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('iserverSecdefStrikesGet', 'month', month)
            const localVarPath = `/iserver/secdef/strikes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (conid !== undefined) {
                localVarQueryParameter['conid'] = conid;
            }

            if (sectype !== undefined) {
                localVarQueryParameter['sectype'] = sectype;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (exchange !== undefined) {
                localVarQueryParameter['exchange'] = exchange;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of non-expired future contracts for given symbol(s)
         * @summary Security Futures by Symbol
         * @param {string} symbols list of case-sensitive symbols separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvFuturesGet: async (symbols: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbols' is not null or undefined
            assertParamExists('trsrvFuturesGet', 'symbols', symbols)
            const localVarPath = `/trsrv/futures`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of security definitions for the given conids
         * @summary Secdef by Conid
         * @param {TrsrvSecdefPostRequest} body request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvSecdefPost: async (body: TrsrvSecdefPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('trsrvSecdefPost', 'body', body)
            const localVarPath = `/trsrv/secdef`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the trading schedule up to a month for the requested contract
         * @summary Get trading schedule for symbol
         * @param {string} assetClass specify the asset class of the contract. Available values-- Stock: STK, Option: OPT, Future: FUT, Contract For Difference: CFD, Warrant: WAR, Forex: SWP, Mutual Fund: FND, Bond: BND, Inter-Commodity Spreads: ICS 
         * @param {string} symbol Underlying Symbol for specified contract, for example \&#39;AAPL\&#39; for US Stock - Apple Inc.
         * @param {string} [exchange] Native exchange for contract, for example \&#39;NASDAQ\&#39; for US Stock - Apple Inc.
         * @param {string} [exchangeFilter] Response only returns trading schedule for specified exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvSecdefScheduleGet: async (assetClass: string, symbol: string, exchange?: string, exchangeFilter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetClass' is not null or undefined
            assertParamExists('trsrvSecdefScheduleGet', 'assetClass', assetClass)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('trsrvSecdefScheduleGet', 'symbol', symbol)
            const localVarPath = `/trsrv/secdef/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (assetClass !== undefined) {
                localVarQueryParameter['assetClass'] = assetClass;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (exchange !== undefined) {
                localVarQueryParameter['exchange'] = exchange;
            }

            if (exchangeFilter !== undefined) {
                localVarQueryParameter['exchangeFilter'] = exchangeFilter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object contains all stock contracts for given symbol(s)
         * @summary Security Stocks by Symbol
         * @param {string} symbols list of upper-sensitive symbols separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvStocksGet: async (symbols: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbols' is not null or undefined
            assertParamExists('trsrvStocksGet', 'symbols', symbols)
            const localVarPath = `/trsrv/stocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractApi - functional programming interface
 * @export
 */
export const ContractApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns supported IB Algos for contract. Must be called a second time to query the list of available parameters.
         * @summary IB Algo Params
         * @param {string} conid IBKR contract identifier
         * @param {string} [algos] List of algo ids delimited by \&quot;;\&quot; to filter by. Max of 8 algos ids can be specified.
         * @param {string} [addDescription] Whether or not to add algo descriptions to response. Set to 1 for yes, 0 for no.
         * @param {string} [addParams] Whether or not to show algo parameters.  Set to 1 for yes, 0 for no.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverContractConidAlgosGet(conid: string, algos?: string, addDescription?: string, addParams?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IserverContractConidAlgosGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverContractConidAlgosGet(conid, algos, addDescription, addParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns both contract info and rules from a single endpoint. For only contract rules, use the endpoint /iserver/contract/rules. For only contract info, use the endpoint /iserver/contract/{conid}/info.  
         * @summary Info and Rules
         * @param {string} conid IBKR contract identifier
         * @param {boolean} isBuy Side of the market rules apply too. Set to **true** for Buy Orders, set to **false** for Sell Orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverContractConidInfoAndRulesGet(conid: string, isBuy: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverContractConidInfoAndRulesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverContractConidInfoAndRulesGet(conid, isBuy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Using the Contract Identifier get contract info. You can use this to prefill your order before you submit an order
         * @summary Contract Details
         * @param {string} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverContractConidInfoGet(conid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverContractConidInfoGet(conid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns trading related rules for a specific contract and side. For both contract info and rules use the endpoint /iserver/contract/{conid}/info-and-rules.
         * @summary Contract Rules
         * @param {IserverContractRulesPostRequest} conid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverContractRulesPost(conid: IserverContractRulesPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverContractRulesPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverContractRulesPost(conid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides Contract Details of Futures, Options, Warrants, Cash and CFDs based on conid. To get the strike price for Options/Warrants use \"/iserver/secdef/strikes\" endpoint. Must call /secdef/search for the underlying contract first.
         * @summary Secdef Info
         * @param {string} conid underlying contract id
         * @param {string} sectype FUT/OPT/WAR/CASH/CFD
         * @param {string} [month] contract month, only required for FUT/OPT/WAR in the format MMMYY, example JAN00
         * @param {string} [exchange] optional, default is SMART
         * @param {number} [strike] optional, only required for OPT/WAR
         * @param {string} [right] C for call, P for put
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverSecdefInfoGet(conid: string, sectype: string, month?: string, exchange?: string, strike?: number, right?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SecdefInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverSecdefInfoGet(conid, sectype, month, exchange, strike, right, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search by underlying symbol or company name. Relays back what derivative contract(s) it has. This endpoint must be called before using /secdef/info. If company name is specified will only receive limited response: conid, companyName, companyHeader and symbol. 
         * @summary Search by Symbol or Name
         * @param {IserverSecdefSearchPostRequest} symbol Symbol or Company Name to be searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverSecdefSearchPost(symbol: IserverSecdefSearchPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IserverSecdefSearchPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverSecdefSearchPost(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query strikes for Options/Warrants. For the conid of the underlying contract, available contract months and exchanges use \"/iserver/secdef/search\"
         * @summary Search Strikes
         * @param {string} conid contract id of the underlying contract
         * @param {string} sectype OPT/WAR
         * @param {string} month contract month
         * @param {string} [exchange] optional, default is SMART
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverSecdefStrikesGet(conid: string, sectype: string, month: string, exchange?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverSecdefStrikesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverSecdefStrikesGet(conid, sectype, month, exchange, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of non-expired future contracts for given symbol(s)
         * @summary Security Futures by Symbol
         * @param {string} symbols list of case-sensitive symbols separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trsrvFuturesGet(symbols: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrsrvFuturesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trsrvFuturesGet(symbols, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of security definitions for the given conids
         * @summary Secdef by Conid
         * @param {TrsrvSecdefPostRequest} body request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trsrvSecdefPost(body: TrsrvSecdefPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SecdefInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trsrvSecdefPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the trading schedule up to a month for the requested contract
         * @summary Get trading schedule for symbol
         * @param {string} assetClass specify the asset class of the contract. Available values-- Stock: STK, Option: OPT, Future: FUT, Contract For Difference: CFD, Warrant: WAR, Forex: SWP, Mutual Fund: FND, Bond: BND, Inter-Commodity Spreads: ICS 
         * @param {string} symbol Underlying Symbol for specified contract, for example \&#39;AAPL\&#39; for US Stock - Apple Inc.
         * @param {string} [exchange] Native exchange for contract, for example \&#39;NASDAQ\&#39; for US Stock - Apple Inc.
         * @param {string} [exchangeFilter] Response only returns trading schedule for specified exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trsrvSecdefScheduleGet(assetClass: string, symbol: string, exchange?: string, exchangeFilter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrsrvSecdefScheduleGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trsrvSecdefScheduleGet(assetClass, symbol, exchange, exchangeFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object contains all stock contracts for given symbol(s)
         * @summary Security Stocks by Symbol
         * @param {string} symbols list of upper-sensitive symbols separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trsrvStocksGet(symbols: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrsrvStocksGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trsrvStocksGet(symbols, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractApi - factory interface
 * @export
 */
export const ContractApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractApiFp(configuration)
    return {
        /**
         * Returns supported IB Algos for contract. Must be called a second time to query the list of available parameters.
         * @summary IB Algo Params
         * @param {string} conid IBKR contract identifier
         * @param {string} [algos] List of algo ids delimited by \&quot;;\&quot; to filter by. Max of 8 algos ids can be specified.
         * @param {string} [addDescription] Whether or not to add algo descriptions to response. Set to 1 for yes, 0 for no.
         * @param {string} [addParams] Whether or not to show algo parameters.  Set to 1 for yes, 0 for no.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidAlgosGet(conid: string, algos?: string, addDescription?: string, addParams?: string, options?: any): AxiosPromise<Array<IserverContractConidAlgosGet200ResponseInner>> {
            return localVarFp.iserverContractConidAlgosGet(conid, algos, addDescription, addParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns both contract info and rules from a single endpoint. For only contract rules, use the endpoint /iserver/contract/rules. For only contract info, use the endpoint /iserver/contract/{conid}/info.  
         * @summary Info and Rules
         * @param {string} conid IBKR contract identifier
         * @param {boolean} isBuy Side of the market rules apply too. Set to **true** for Buy Orders, set to **false** for Sell Orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidInfoAndRulesGet(conid: string, isBuy: boolean, options?: any): AxiosPromise<IserverContractConidInfoAndRulesGet200Response> {
            return localVarFp.iserverContractConidInfoAndRulesGet(conid, isBuy, options).then((request) => request(axios, basePath));
        },
        /**
         * Using the Contract Identifier get contract info. You can use this to prefill your order before you submit an order
         * @summary Contract Details
         * @param {string} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidInfoGet(conid: string, options?: any): AxiosPromise<Contract> {
            return localVarFp.iserverContractConidInfoGet(conid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns trading related rules for a specific contract and side. For both contract info and rules use the endpoint /iserver/contract/{conid}/info-and-rules.
         * @summary Contract Rules
         * @param {IserverContractRulesPostRequest} conid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractRulesPost(conid: IserverContractRulesPostRequest, options?: any): AxiosPromise<IserverContractRulesPost200Response> {
            return localVarFp.iserverContractRulesPost(conid, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides Contract Details of Futures, Options, Warrants, Cash and CFDs based on conid. To get the strike price for Options/Warrants use \"/iserver/secdef/strikes\" endpoint. Must call /secdef/search for the underlying contract first.
         * @summary Secdef Info
         * @param {string} conid underlying contract id
         * @param {string} sectype FUT/OPT/WAR/CASH/CFD
         * @param {string} [month] contract month, only required for FUT/OPT/WAR in the format MMMYY, example JAN00
         * @param {string} [exchange] optional, default is SMART
         * @param {number} [strike] optional, only required for OPT/WAR
         * @param {string} [right] C for call, P for put
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefInfoGet(conid: string, sectype: string, month?: string, exchange?: string, strike?: number, right?: string, options?: any): AxiosPromise<Array<SecdefInfo>> {
            return localVarFp.iserverSecdefInfoGet(conid, sectype, month, exchange, strike, right, options).then((request) => request(axios, basePath));
        },
        /**
         * Search by underlying symbol or company name. Relays back what derivative contract(s) it has. This endpoint must be called before using /secdef/info. If company name is specified will only receive limited response: conid, companyName, companyHeader and symbol. 
         * @summary Search by Symbol or Name
         * @param {IserverSecdefSearchPostRequest} symbol Symbol or Company Name to be searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefSearchPost(symbol: IserverSecdefSearchPostRequest, options?: any): AxiosPromise<Array<IserverSecdefSearchPost200ResponseInner>> {
            return localVarFp.iserverSecdefSearchPost(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Query strikes for Options/Warrants. For the conid of the underlying contract, available contract months and exchanges use \"/iserver/secdef/search\"
         * @summary Search Strikes
         * @param {string} conid contract id of the underlying contract
         * @param {string} sectype OPT/WAR
         * @param {string} month contract month
         * @param {string} [exchange] optional, default is SMART
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefStrikesGet(conid: string, sectype: string, month: string, exchange?: string, options?: any): AxiosPromise<IserverSecdefStrikesGet200Response> {
            return localVarFp.iserverSecdefStrikesGet(conid, sectype, month, exchange, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of non-expired future contracts for given symbol(s)
         * @summary Security Futures by Symbol
         * @param {string} symbols list of case-sensitive symbols separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvFuturesGet(symbols: string, options?: any): AxiosPromise<TrsrvFuturesGet200Response> {
            return localVarFp.trsrvFuturesGet(symbols, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of security definitions for the given conids
         * @summary Secdef by Conid
         * @param {TrsrvSecdefPostRequest} body request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvSecdefPost(body: TrsrvSecdefPostRequest, options?: any): AxiosPromise<Array<SecdefInner>> {
            return localVarFp.trsrvSecdefPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the trading schedule up to a month for the requested contract
         * @summary Get trading schedule for symbol
         * @param {string} assetClass specify the asset class of the contract. Available values-- Stock: STK, Option: OPT, Future: FUT, Contract For Difference: CFD, Warrant: WAR, Forex: SWP, Mutual Fund: FND, Bond: BND, Inter-Commodity Spreads: ICS 
         * @param {string} symbol Underlying Symbol for specified contract, for example \&#39;AAPL\&#39; for US Stock - Apple Inc.
         * @param {string} [exchange] Native exchange for contract, for example \&#39;NASDAQ\&#39; for US Stock - Apple Inc.
         * @param {string} [exchangeFilter] Response only returns trading schedule for specified exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvSecdefScheduleGet(assetClass: string, symbol: string, exchange?: string, exchangeFilter?: string, options?: any): AxiosPromise<TrsrvSecdefScheduleGet200Response> {
            return localVarFp.trsrvSecdefScheduleGet(assetClass, symbol, exchange, exchangeFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object contains all stock contracts for given symbol(s)
         * @summary Security Stocks by Symbol
         * @param {string} symbols list of upper-sensitive symbols separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvStocksGet(symbols: string, options?: any): AxiosPromise<TrsrvStocksGet200Response> {
            return localVarFp.trsrvStocksGet(symbols, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractApi - object-oriented interface
 * @export
 * @class ContractApi
 * @extends {BaseAPI}
 */
export class ContractApi extends BaseAPI {
    /**
     * Returns supported IB Algos for contract. Must be called a second time to query the list of available parameters.
     * @summary IB Algo Params
     * @param {string} conid IBKR contract identifier
     * @param {string} [algos] List of algo ids delimited by \&quot;;\&quot; to filter by. Max of 8 algos ids can be specified.
     * @param {string} [addDescription] Whether or not to add algo descriptions to response. Set to 1 for yes, 0 for no.
     * @param {string} [addParams] Whether or not to show algo parameters.  Set to 1 for yes, 0 for no.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public iserverContractConidAlgosGet(conid: string, algos?: string, addDescription?: string, addParams?: string, options?: AxiosRequestConfig) {
        return ContractApiFp(this.configuration).iserverContractConidAlgosGet(conid, algos, addDescription, addParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns both contract info and rules from a single endpoint. For only contract rules, use the endpoint /iserver/contract/rules. For only contract info, use the endpoint /iserver/contract/{conid}/info.  
     * @summary Info and Rules
     * @param {string} conid IBKR contract identifier
     * @param {boolean} isBuy Side of the market rules apply too. Set to **true** for Buy Orders, set to **false** for Sell Orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public iserverContractConidInfoAndRulesGet(conid: string, isBuy: boolean, options?: AxiosRequestConfig) {
        return ContractApiFp(this.configuration).iserverContractConidInfoAndRulesGet(conid, isBuy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Using the Contract Identifier get contract info. You can use this to prefill your order before you submit an order
     * @summary Contract Details
     * @param {string} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public iserverContractConidInfoGet(conid: string, options?: AxiosRequestConfig) {
        return ContractApiFp(this.configuration).iserverContractConidInfoGet(conid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns trading related rules for a specific contract and side. For both contract info and rules use the endpoint /iserver/contract/{conid}/info-and-rules.
     * @summary Contract Rules
     * @param {IserverContractRulesPostRequest} conid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public iserverContractRulesPost(conid: IserverContractRulesPostRequest, options?: AxiosRequestConfig) {
        return ContractApiFp(this.configuration).iserverContractRulesPost(conid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides Contract Details of Futures, Options, Warrants, Cash and CFDs based on conid. To get the strike price for Options/Warrants use \"/iserver/secdef/strikes\" endpoint. Must call /secdef/search for the underlying contract first.
     * @summary Secdef Info
     * @param {string} conid underlying contract id
     * @param {string} sectype FUT/OPT/WAR/CASH/CFD
     * @param {string} [month] contract month, only required for FUT/OPT/WAR in the format MMMYY, example JAN00
     * @param {string} [exchange] optional, default is SMART
     * @param {number} [strike] optional, only required for OPT/WAR
     * @param {string} [right] C for call, P for put
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public iserverSecdefInfoGet(conid: string, sectype: string, month?: string, exchange?: string, strike?: number, right?: string, options?: AxiosRequestConfig) {
        return ContractApiFp(this.configuration).iserverSecdefInfoGet(conid, sectype, month, exchange, strike, right, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search by underlying symbol or company name. Relays back what derivative contract(s) it has. This endpoint must be called before using /secdef/info. If company name is specified will only receive limited response: conid, companyName, companyHeader and symbol. 
     * @summary Search by Symbol or Name
     * @param {IserverSecdefSearchPostRequest} symbol Symbol or Company Name to be searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public iserverSecdefSearchPost(symbol: IserverSecdefSearchPostRequest, options?: AxiosRequestConfig) {
        return ContractApiFp(this.configuration).iserverSecdefSearchPost(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query strikes for Options/Warrants. For the conid of the underlying contract, available contract months and exchanges use \"/iserver/secdef/search\"
     * @summary Search Strikes
     * @param {string} conid contract id of the underlying contract
     * @param {string} sectype OPT/WAR
     * @param {string} month contract month
     * @param {string} [exchange] optional, default is SMART
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public iserverSecdefStrikesGet(conid: string, sectype: string, month: string, exchange?: string, options?: AxiosRequestConfig) {
        return ContractApiFp(this.configuration).iserverSecdefStrikesGet(conid, sectype, month, exchange, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of non-expired future contracts for given symbol(s)
     * @summary Security Futures by Symbol
     * @param {string} symbols list of case-sensitive symbols separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public trsrvFuturesGet(symbols: string, options?: AxiosRequestConfig) {
        return ContractApiFp(this.configuration).trsrvFuturesGet(symbols, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of security definitions for the given conids
     * @summary Secdef by Conid
     * @param {TrsrvSecdefPostRequest} body request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public trsrvSecdefPost(body: TrsrvSecdefPostRequest, options?: AxiosRequestConfig) {
        return ContractApiFp(this.configuration).trsrvSecdefPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the trading schedule up to a month for the requested contract
     * @summary Get trading schedule for symbol
     * @param {string} assetClass specify the asset class of the contract. Available values-- Stock: STK, Option: OPT, Future: FUT, Contract For Difference: CFD, Warrant: WAR, Forex: SWP, Mutual Fund: FND, Bond: BND, Inter-Commodity Spreads: ICS 
     * @param {string} symbol Underlying Symbol for specified contract, for example \&#39;AAPL\&#39; for US Stock - Apple Inc.
     * @param {string} [exchange] Native exchange for contract, for example \&#39;NASDAQ\&#39; for US Stock - Apple Inc.
     * @param {string} [exchangeFilter] Response only returns trading schedule for specified exchange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public trsrvSecdefScheduleGet(assetClass: string, symbol: string, exchange?: string, exchangeFilter?: string, options?: AxiosRequestConfig) {
        return ContractApiFp(this.configuration).trsrvSecdefScheduleGet(assetClass, symbol, exchange, exchangeFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object contains all stock contracts for given symbol(s)
     * @summary Security Stocks by Symbol
     * @param {string} symbols list of upper-sensitive symbols separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public trsrvStocksGet(symbols: string, options?: AxiosRequestConfig) {
        return ContractApiFp(this.configuration).trsrvStocksGet(symbols, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FYIApi - axios parameter creator
 * @export
 */
export const FYIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a device
         * @param {string} deviceId device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsDeviceIdDelete: async (deviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('fyiDeliveryoptionsDeviceIdDelete', 'deviceId', deviceId)
            const localVarPath = `/fyi/deliveryoptions/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable/Disable device option
         * @param {FyiDeliveryoptionsDevicePostRequest} body device info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsDevicePost: async (body: FyiDeliveryoptionsDevicePostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('fyiDeliveryoptionsDevicePost', 'body', body)
            const localVarPath = `/fyi/deliveryoptions/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable/Disable email option
         * @param {string} enabled true/false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsEmailPut: async (enabled: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enabled' is not null or undefined
            assertParamExists('fyiDeliveryoptionsEmailPut', 'enabled', enabled)
            const localVarPath = `/fyi/deliveryoptions/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * options for sending fyis to email and other devices 
         * @summary Get delivery options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fyi/deliveryoptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get disclaimer for a certain kind of fyi
         * @param {string} typecode fyi code, for example --M8, EA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDisclaimerTypecodeGet: async (typecode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typecode' is not null or undefined
            assertParamExists('fyiDisclaimerTypecodeGet', 'typecode', typecode)
            const localVarPath = `/fyi/disclaimer/{typecode}`
                .replace(`{${"typecode"}}`, encodeURIComponent(String(typecode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark disclaimer read
         * @param {string} typecode fyi code, for example --M8, EA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDisclaimerTypecodePut: async (typecode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typecode' is not null or undefined
            assertParamExists('fyiDisclaimerTypecodePut', 'typecode', typecode)
            const localVarPath = `/fyi/disclaimer/{typecode}`
                .replace(`{${"typecode"}}`, encodeURIComponent(String(typecode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of notifications
         * @param {string} max max number of fyis in response
         * @param {string} [exclude] if set, don\&#39;t set include
         * @param {string} [include] if set, don\&#39;t set exclude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsGet: async (max: string, exclude?: string, include?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'max' is not null or undefined
            assertParamExists('fyiNotificationsGet', 'max', max)
            const localVarPath = `/fyi/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get more notifications based on a certain one
         * @param {string} id id of last notification in the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsMoreGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fyiNotificationsMoreGet', 'id', id)
            const localVarPath = `/fyi/notifications/more`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of notifications
         * @param {string} notificationId mark a notification read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsNotificationIdPut: async (notificationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('fyiNotificationsNotificationIdPut', 'notificationId', notificationId)
            const localVarPath = `/fyi/notifications/{notificationId}`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the current choices of subscriptions, we can toggle the option 
         * @summary Get a list of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiSettingsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fyi/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure which typecode you would like to enable/disable. 
         * @summary Enable/Disable certain subscription
         * @param {string} typecode fyi code
         * @param {FyiSettingsTypecodePostRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiSettingsTypecodePost: async (typecode: string, body: FyiSettingsTypecodePostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typecode' is not null or undefined
            assertParamExists('fyiSettingsTypecodePost', 'typecode', typecode)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('fyiSettingsTypecodePost', 'body', body)
            const localVarPath = `/fyi/settings/{typecode}`
                .replace(`{${"typecode"}}`, encodeURIComponent(String(typecode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the total number of unread fyis 
         * @summary Get unread number of fyis. The HTTP method POST is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiUnreadnumberGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fyi/unreadnumber`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FYIApi - functional programming interface
 * @export
 */
export const FYIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FYIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a device
         * @param {string} deviceId device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fyiDeliveryoptionsDeviceIdDelete(deviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fyiDeliveryoptionsDeviceIdDelete(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Enable/Disable device option
         * @param {FyiDeliveryoptionsDevicePostRequest} body device info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fyiDeliveryoptionsDevicePost(body: FyiDeliveryoptionsDevicePostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FyiDisclaimerTypecodePut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fyiDeliveryoptionsDevicePost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Enable/Disable email option
         * @param {string} enabled true/false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fyiDeliveryoptionsEmailPut(enabled: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FyiDisclaimerTypecodePut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fyiDeliveryoptionsEmailPut(enabled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * options for sending fyis to email and other devices 
         * @summary Get delivery options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fyiDeliveryoptionsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FyiDeliveryoptionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fyiDeliveryoptionsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get disclaimer for a certain kind of fyi
         * @param {string} typecode fyi code, for example --M8, EA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fyiDisclaimerTypecodeGet(typecode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FyiDisclaimerTypecodeGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fyiDisclaimerTypecodeGet(typecode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark disclaimer read
         * @param {string} typecode fyi code, for example --M8, EA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fyiDisclaimerTypecodePut(typecode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FyiDisclaimerTypecodePut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fyiDisclaimerTypecodePut(typecode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of notifications
         * @param {string} max max number of fyis in response
         * @param {string} [exclude] if set, don\&#39;t set include
         * @param {string} [include] if set, don\&#39;t set exclude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fyiNotificationsGet(max: string, exclude?: string, include?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fyiNotificationsGet(max, exclude, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get more notifications based on a certain one
         * @param {string} id id of last notification in the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fyiNotificationsMoreGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fyiNotificationsMoreGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of notifications
         * @param {string} notificationId mark a notification read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fyiNotificationsNotificationIdPut(notificationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fyiNotificationsNotificationIdPut(notificationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return the current choices of subscriptions, we can toggle the option 
         * @summary Get a list of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fyiSettingsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FyiSettingsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fyiSettingsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Configure which typecode you would like to enable/disable. 
         * @summary Enable/Disable certain subscription
         * @param {string} typecode fyi code
         * @param {FyiSettingsTypecodePostRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fyiSettingsTypecodePost(typecode: string, body: FyiSettingsTypecodePostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fyiSettingsTypecodePost(typecode, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the total number of unread fyis 
         * @summary Get unread number of fyis. The HTTP method POST is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fyiUnreadnumberGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FyiUnreadnumberGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fyiUnreadnumberGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FYIApi - factory interface
 * @export
 */
export const FYIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FYIApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a device
         * @param {string} deviceId device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsDeviceIdDelete(deviceId: string, options?: any): AxiosPromise<object> {
            return localVarFp.fyiDeliveryoptionsDeviceIdDelete(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enable/Disable device option
         * @param {FyiDeliveryoptionsDevicePostRequest} body device info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsDevicePost(body: FyiDeliveryoptionsDevicePostRequest, options?: any): AxiosPromise<FyiDisclaimerTypecodePut200Response> {
            return localVarFp.fyiDeliveryoptionsDevicePost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enable/Disable email option
         * @param {string} enabled true/false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsEmailPut(enabled: string, options?: any): AxiosPromise<FyiDisclaimerTypecodePut200Response> {
            return localVarFp.fyiDeliveryoptionsEmailPut(enabled, options).then((request) => request(axios, basePath));
        },
        /**
         * options for sending fyis to email and other devices 
         * @summary Get delivery options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsGet(options?: any): AxiosPromise<FyiDeliveryoptionsGet200Response> {
            return localVarFp.fyiDeliveryoptionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get disclaimer for a certain kind of fyi
         * @param {string} typecode fyi code, for example --M8, EA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDisclaimerTypecodeGet(typecode: string, options?: any): AxiosPromise<FyiDisclaimerTypecodeGet200Response> {
            return localVarFp.fyiDisclaimerTypecodeGet(typecode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark disclaimer read
         * @param {string} typecode fyi code, for example --M8, EA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDisclaimerTypecodePut(typecode: string, options?: any): AxiosPromise<FyiDisclaimerTypecodePut200Response> {
            return localVarFp.fyiDisclaimerTypecodePut(typecode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of notifications
         * @param {string} max max number of fyis in response
         * @param {string} [exclude] if set, don\&#39;t set include
         * @param {string} [include] if set, don\&#39;t set exclude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsGet(max: string, exclude?: string, include?: string, options?: any): AxiosPromise<Array<NotificationsInner>> {
            return localVarFp.fyiNotificationsGet(max, exclude, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get more notifications based on a certain one
         * @param {string} id id of last notification in the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsMoreGet(id: string, options?: any): AxiosPromise<Array<NotificationsInner>> {
            return localVarFp.fyiNotificationsMoreGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of notifications
         * @param {string} notificationId mark a notification read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsNotificationIdPut(notificationId: string, options?: any): AxiosPromise<object> {
            return localVarFp.fyiNotificationsNotificationIdPut(notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the current choices of subscriptions, we can toggle the option 
         * @summary Get a list of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiSettingsGet(options?: any): AxiosPromise<Array<FyiSettingsGet200ResponseInner>> {
            return localVarFp.fyiSettingsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Configure which typecode you would like to enable/disable. 
         * @summary Enable/Disable certain subscription
         * @param {string} typecode fyi code
         * @param {FyiSettingsTypecodePostRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiSettingsTypecodePost(typecode: string, body: FyiSettingsTypecodePostRequest, options?: any): AxiosPromise<object> {
            return localVarFp.fyiSettingsTypecodePost(typecode, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the total number of unread fyis 
         * @summary Get unread number of fyis. The HTTP method POST is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiUnreadnumberGet(options?: any): AxiosPromise<FyiUnreadnumberGet200Response> {
            return localVarFp.fyiUnreadnumberGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FYIApi - object-oriented interface
 * @export
 * @class FYIApi
 * @extends {BaseAPI}
 */
export class FYIApi extends BaseAPI {
    /**
     * 
     * @summary Delete a device
     * @param {string} deviceId device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    public fyiDeliveryoptionsDeviceIdDelete(deviceId: string, options?: AxiosRequestConfig) {
        return FYIApiFp(this.configuration).fyiDeliveryoptionsDeviceIdDelete(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enable/Disable device option
     * @param {FyiDeliveryoptionsDevicePostRequest} body device info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    public fyiDeliveryoptionsDevicePost(body: FyiDeliveryoptionsDevicePostRequest, options?: AxiosRequestConfig) {
        return FYIApiFp(this.configuration).fyiDeliveryoptionsDevicePost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enable/Disable email option
     * @param {string} enabled true/false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    public fyiDeliveryoptionsEmailPut(enabled: string, options?: AxiosRequestConfig) {
        return FYIApiFp(this.configuration).fyiDeliveryoptionsEmailPut(enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * options for sending fyis to email and other devices 
     * @summary Get delivery options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    public fyiDeliveryoptionsGet(options?: AxiosRequestConfig) {
        return FYIApiFp(this.configuration).fyiDeliveryoptionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get disclaimer for a certain kind of fyi
     * @param {string} typecode fyi code, for example --M8, EA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    public fyiDisclaimerTypecodeGet(typecode: string, options?: AxiosRequestConfig) {
        return FYIApiFp(this.configuration).fyiDisclaimerTypecodeGet(typecode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark disclaimer read
     * @param {string} typecode fyi code, for example --M8, EA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    public fyiDisclaimerTypecodePut(typecode: string, options?: AxiosRequestConfig) {
        return FYIApiFp(this.configuration).fyiDisclaimerTypecodePut(typecode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of notifications
     * @param {string} max max number of fyis in response
     * @param {string} [exclude] if set, don\&#39;t set include
     * @param {string} [include] if set, don\&#39;t set exclude
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    public fyiNotificationsGet(max: string, exclude?: string, include?: string, options?: AxiosRequestConfig) {
        return FYIApiFp(this.configuration).fyiNotificationsGet(max, exclude, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get more notifications based on a certain one
     * @param {string} id id of last notification in the list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    public fyiNotificationsMoreGet(id: string, options?: AxiosRequestConfig) {
        return FYIApiFp(this.configuration).fyiNotificationsMoreGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of notifications
     * @param {string} notificationId mark a notification read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    public fyiNotificationsNotificationIdPut(notificationId: string, options?: AxiosRequestConfig) {
        return FYIApiFp(this.configuration).fyiNotificationsNotificationIdPut(notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the current choices of subscriptions, we can toggle the option 
     * @summary Get a list of subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    public fyiSettingsGet(options?: AxiosRequestConfig) {
        return FYIApiFp(this.configuration).fyiSettingsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configure which typecode you would like to enable/disable. 
     * @summary Enable/Disable certain subscription
     * @param {string} typecode fyi code
     * @param {FyiSettingsTypecodePostRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    public fyiSettingsTypecodePost(typecode: string, body: FyiSettingsTypecodePostRequest, options?: AxiosRequestConfig) {
        return FYIApiFp(this.configuration).fyiSettingsTypecodePost(typecode, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the total number of unread fyis 
     * @summary Get unread number of fyis. The HTTP method POST is also supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    public fyiUnreadnumberGet(options?: AxiosRequestConfig) {
        return FYIApiFp(this.configuration).fyiUnreadnumberGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MarketDataApi - axios parameter creator
 * @export
 */
export const MarketDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Using a direct connection to the market data farm, will provide a list of historical market data for given conid.
         * @summary Market Data History (Beta)
         * @param {number} conid contract id
         * @param {'min' | 'h' | 'd' | 'w' | 'm' | 'y'} period Time period for history request.    * min: Minutes   * h: Hours   * d: Days   * w: Weeks   * m: Months   * y: Years 
         * @param {'min' | 'h' | 'd' | 'w' | 'm'} [bar] Duration of time for each candlestick bar.   * min: Minutes   * h: Hours   * d: Days   * w: Weeks   * m: Months 
         * @param {boolean} [outsideRth] For contracts that support it, will determine if history data includes outside of regular trading hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hmdsHistoryGet: async (conid: number, period: 'min' | 'h' | 'd' | 'w' | 'm' | 'y', bar?: 'min' | 'h' | 'd' | 'w' | 'm', outsideRth?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conid' is not null or undefined
            assertParamExists('hmdsHistoryGet', 'conid', conid)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('hmdsHistoryGet', 'period', period)
            const localVarPath = `/hmds/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (conid !== undefined) {
                localVarQueryParameter['conid'] = conid;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (bar !== undefined) {
                localVarQueryParameter['bar'] = bar;
            }

            if (outsideRth !== undefined) {
                localVarQueryParameter['outsideRth'] = outsideRth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel market data for given conid. To cancel all market data request(s), see /iserver/marketdata/unsubscribeall. 
         * @summary Market Data Cancel (Single)
         * @param {string} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataConidUnsubscribeGet: async (conid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conid' is not null or undefined
            assertParamExists('iserverMarketdataConidUnsubscribeGet', 'conid', conid)
            const localVarPath = `/iserver/marketdata/{conid}/unsubscribe`
                .replace(`{${"conid"}}`, encodeURIComponent(String(conid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historical market Data for given conid, length of data is controlled by \'period\' and \'bar\'. Formatted as: min=minute, h=hour, d=day, w=week, m=month, y=year e.g. period =1y with bar =1w returns 52 data points (Max of 1000 data points supported). **Note**: There\'s a limit of 5 concurrent requests. Excessive requests will return a \'Too many requests\' status 429 response. 
         * @summary Market Data History
         * @param {string} conid contract id
         * @param {string} period available time period-- {1-30}min, {1-8}h, {1-1000}d, {1-792}w, {1-182}m, {1-15}y
         * @param {string} [exchange] Exchange of the conid (e.g. ISLAND, NYSE, etc.). Default value is empty which corresponds to primary exchange of the conid.
         * @param {string} [bar] possible value-- 1min, 2min, 3min, 5min, 10min, 15min, 30min, 1h, 2h, 3h, 4h, 8h, 1d, 1w, 1m
         * @param {boolean} [outsideRth] For contracts that support it, will determine if historical data includes outside of regular trading hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataHistoryGet: async (conid: string, period: string, exchange?: string, bar?: string, outsideRth?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conid' is not null or undefined
            assertParamExists('iserverMarketdataHistoryGet', 'conid', conid)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('iserverMarketdataHistoryGet', 'period', period)
            const localVarPath = `/iserver/marketdata/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (conid !== undefined) {
                localVarQueryParameter['conid'] = conid;
            }

            if (exchange !== undefined) {
                localVarQueryParameter['exchange'] = exchange;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (bar !== undefined) {
                localVarQueryParameter['bar'] = bar;
            }

            if (outsideRth !== undefined) {
                localVarQueryParameter['outsideRth'] = outsideRth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Market Data for the given conid(s). The endpoint will return by default bid, ask, last, change, change pct, close, listing exchange. See response fields for a list of available fields that can be request via fields argument. The endpoint /iserver/accounts must be called prior to /iserver/marketdata/snapshot. For derivative contracts the endpoint /iserver/secdef/search must be called first. First /snapshot endpoint call for given conid will initiate the market data request.  To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary Market Data
         * @param {string} conids list of conids separated by comma
         * @param {number} [since] time period since which updates are required. uses epoch time with milliseconds.
         * @param {string} [fields] list of fields separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataSnapshotGet: async (conids: string, since?: number, fields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conids' is not null or undefined
            assertParamExists('iserverMarketdataSnapshotGet', 'conids', conids)
            const localVarPath = `/iserver/marketdata/snapshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (conids !== undefined) {
                localVarQueryParameter['conids'] = conids;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel all market data request(s). To cancel market data for given conid, see /iserver/marketdata/{conid}/unsubscribe. 
         * @summary Market Data Cancel (All)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataUnsubscribeallGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iserver/marketdata/unsubscribeall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a snapshot of Market Data for the given conid(s).See response for a list of available fields that can be requested from the fields argument. Must be connected to a brokerage session before can query snapshot data. First /snapshot endpoint call for given conid(s) will initiate the market data request, make an additional request to receive field values back. To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary Market Data Snapshot (Beta)
         * @param {'conid@exchange:instrType'} conids List of conids comma separated. Optional exchange and instrument type can be specified.   * conid: IBKR Contract Identifier   * exchange: Exchange or venue   * instrType: Instrument Type supported values: CS (Stocks), OPT (Options), FUT (Futures), FOP (Future Options), WAR (Warrants), BOND (Bonds), FUND (Mutual Funds), CASH (Forex), CFD (Contract for difference), IND (Index) 
         * @param {string} [fields] list of fields separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdSnapshotGet: async (conids: 'conid@exchange:instrType', fields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conids' is not null or undefined
            assertParamExists('mdSnapshotGet', 'conids', conids)
            const localVarPath = `/md/snapshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (conids !== undefined) {
                localVarQueryParameter['conids'] = conids;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketDataApi - functional programming interface
 * @export
 */
export const MarketDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Using a direct connection to the market data farm, will provide a list of historical market data for given conid.
         * @summary Market Data History (Beta)
         * @param {number} conid contract id
         * @param {'min' | 'h' | 'd' | 'w' | 'm' | 'y'} period Time period for history request.    * min: Minutes   * h: Hours   * d: Days   * w: Weeks   * m: Months   * y: Years 
         * @param {'min' | 'h' | 'd' | 'w' | 'm'} [bar] Duration of time for each candlestick bar.   * min: Minutes   * h: Hours   * d: Days   * w: Weeks   * m: Months 
         * @param {boolean} [outsideRth] For contracts that support it, will determine if history data includes outside of regular trading hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hmdsHistoryGet(conid: number, period: 'min' | 'h' | 'd' | 'w' | 'm' | 'y', bar?: 'min' | 'h' | 'd' | 'w' | 'm', outsideRth?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HistoryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hmdsHistoryGet(conid, period, bar, outsideRth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel market data for given conid. To cancel all market data request(s), see /iserver/marketdata/unsubscribeall. 
         * @summary Market Data Cancel (Single)
         * @param {string} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverMarketdataConidUnsubscribeGet(conid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverMarketdataConidUnsubscribeGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverMarketdataConidUnsubscribeGet(conid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get historical market Data for given conid, length of data is controlled by \'period\' and \'bar\'. Formatted as: min=minute, h=hour, d=day, w=week, m=month, y=year e.g. period =1y with bar =1w returns 52 data points (Max of 1000 data points supported). **Note**: There\'s a limit of 5 concurrent requests. Excessive requests will return a \'Too many requests\' status 429 response. 
         * @summary Market Data History
         * @param {string} conid contract id
         * @param {string} period available time period-- {1-30}min, {1-8}h, {1-1000}d, {1-792}w, {1-182}m, {1-15}y
         * @param {string} [exchange] Exchange of the conid (e.g. ISLAND, NYSE, etc.). Default value is empty which corresponds to primary exchange of the conid.
         * @param {string} [bar] possible value-- 1min, 2min, 3min, 5min, 10min, 15min, 30min, 1h, 2h, 3h, 4h, 8h, 1d, 1w, 1m
         * @param {boolean} [outsideRth] For contracts that support it, will determine if historical data includes outside of regular trading hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverMarketdataHistoryGet(conid: string, period: string, exchange?: string, bar?: string, outsideRth?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HistoryData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverMarketdataHistoryGet(conid, period, exchange, bar, outsideRth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Market Data for the given conid(s). The endpoint will return by default bid, ask, last, change, change pct, close, listing exchange. See response fields for a list of available fields that can be request via fields argument. The endpoint /iserver/accounts must be called prior to /iserver/marketdata/snapshot. For derivative contracts the endpoint /iserver/secdef/search must be called first. First /snapshot endpoint call for given conid will initiate the market data request.  To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary Market Data
         * @param {string} conids list of conids separated by comma
         * @param {number} [since] time period since which updates are required. uses epoch time with milliseconds.
         * @param {string} [fields] list of fields separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverMarketdataSnapshotGet(conids: string, since?: number, fields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IserverMarketdataSnapshotGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverMarketdataSnapshotGet(conids, since, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel all market data request(s). To cancel market data for given conid, see /iserver/marketdata/{conid}/unsubscribe. 
         * @summary Market Data Cancel (All)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverMarketdataUnsubscribeallGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverMarketdataUnsubscribeallGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverMarketdataUnsubscribeallGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a snapshot of Market Data for the given conid(s).See response for a list of available fields that can be requested from the fields argument. Must be connected to a brokerage session before can query snapshot data. First /snapshot endpoint call for given conid(s) will initiate the market data request, make an additional request to receive field values back. To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary Market Data Snapshot (Beta)
         * @param {'conid@exchange:instrType'} conids List of conids comma separated. Optional exchange and instrument type can be specified.   * conid: IBKR Contract Identifier   * exchange: Exchange or venue   * instrType: Instrument Type supported values: CS (Stocks), OPT (Options), FUT (Futures), FOP (Future Options), WAR (Warrants), BOND (Bonds), FUND (Mutual Funds), CASH (Forex), CFD (Contract for difference), IND (Index) 
         * @param {string} [fields] list of fields separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mdSnapshotGet(conids: 'conid@exchange:instrType', fields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mdSnapshotGet(conids, fields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MarketDataApi - factory interface
 * @export
 */
export const MarketDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketDataApiFp(configuration)
    return {
        /**
         * Using a direct connection to the market data farm, will provide a list of historical market data for given conid.
         * @summary Market Data History (Beta)
         * @param {number} conid contract id
         * @param {'min' | 'h' | 'd' | 'w' | 'm' | 'y'} period Time period for history request.    * min: Minutes   * h: Hours   * d: Days   * w: Weeks   * m: Months   * y: Years 
         * @param {'min' | 'h' | 'd' | 'w' | 'm'} [bar] Duration of time for each candlestick bar.   * min: Minutes   * h: Hours   * d: Days   * w: Weeks   * m: Months 
         * @param {boolean} [outsideRth] For contracts that support it, will determine if history data includes outside of regular trading hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hmdsHistoryGet(conid: number, period: 'min' | 'h' | 'd' | 'w' | 'm' | 'y', bar?: 'min' | 'h' | 'd' | 'w' | 'm', outsideRth?: boolean, options?: any): AxiosPromise<HistoryResult> {
            return localVarFp.hmdsHistoryGet(conid, period, bar, outsideRth, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel market data for given conid. To cancel all market data request(s), see /iserver/marketdata/unsubscribeall. 
         * @summary Market Data Cancel (Single)
         * @param {string} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataConidUnsubscribeGet(conid: string, options?: any): AxiosPromise<IserverMarketdataConidUnsubscribeGet200Response> {
            return localVarFp.iserverMarketdataConidUnsubscribeGet(conid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get historical market Data for given conid, length of data is controlled by \'period\' and \'bar\'. Formatted as: min=minute, h=hour, d=day, w=week, m=month, y=year e.g. period =1y with bar =1w returns 52 data points (Max of 1000 data points supported). **Note**: There\'s a limit of 5 concurrent requests. Excessive requests will return a \'Too many requests\' status 429 response. 
         * @summary Market Data History
         * @param {string} conid contract id
         * @param {string} period available time period-- {1-30}min, {1-8}h, {1-1000}d, {1-792}w, {1-182}m, {1-15}y
         * @param {string} [exchange] Exchange of the conid (e.g. ISLAND, NYSE, etc.). Default value is empty which corresponds to primary exchange of the conid.
         * @param {string} [bar] possible value-- 1min, 2min, 3min, 5min, 10min, 15min, 30min, 1h, 2h, 3h, 4h, 8h, 1d, 1w, 1m
         * @param {boolean} [outsideRth] For contracts that support it, will determine if historical data includes outside of regular trading hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataHistoryGet(conid: string, period: string, exchange?: string, bar?: string, outsideRth?: boolean, options?: any): AxiosPromise<HistoryData> {
            return localVarFp.iserverMarketdataHistoryGet(conid, period, exchange, bar, outsideRth, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Market Data for the given conid(s). The endpoint will return by default bid, ask, last, change, change pct, close, listing exchange. See response fields for a list of available fields that can be request via fields argument. The endpoint /iserver/accounts must be called prior to /iserver/marketdata/snapshot. For derivative contracts the endpoint /iserver/secdef/search must be called first. First /snapshot endpoint call for given conid will initiate the market data request.  To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary Market Data
         * @param {string} conids list of conids separated by comma
         * @param {number} [since] time period since which updates are required. uses epoch time with milliseconds.
         * @param {string} [fields] list of fields separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataSnapshotGet(conids: string, since?: number, fields?: string, options?: any): AxiosPromise<Array<IserverMarketdataSnapshotGet200ResponseInner>> {
            return localVarFp.iserverMarketdataSnapshotGet(conids, since, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel all market data request(s). To cancel market data for given conid, see /iserver/marketdata/{conid}/unsubscribe. 
         * @summary Market Data Cancel (All)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataUnsubscribeallGet(options?: any): AxiosPromise<IserverMarketdataUnsubscribeallGet200Response> {
            return localVarFp.iserverMarketdataUnsubscribeallGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a snapshot of Market Data for the given conid(s).See response for a list of available fields that can be requested from the fields argument. Must be connected to a brokerage session before can query snapshot data. First /snapshot endpoint call for given conid(s) will initiate the market data request, make an additional request to receive field values back. To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary Market Data Snapshot (Beta)
         * @param {'conid@exchange:instrType'} conids List of conids comma separated. Optional exchange and instrument type can be specified.   * conid: IBKR Contract Identifier   * exchange: Exchange or venue   * instrType: Instrument Type supported values: CS (Stocks), OPT (Options), FUT (Futures), FOP (Future Options), WAR (Warrants), BOND (Bonds), FUND (Mutual Funds), CASH (Forex), CFD (Contract for difference), IND (Index) 
         * @param {string} [fields] list of fields separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mdSnapshotGet(conids: 'conid@exchange:instrType', fields?: string, options?: any): AxiosPromise<MarketData> {
            return localVarFp.mdSnapshotGet(conids, fields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketDataApi - object-oriented interface
 * @export
 * @class MarketDataApi
 * @extends {BaseAPI}
 */
export class MarketDataApi extends BaseAPI {
    /**
     * Using a direct connection to the market data farm, will provide a list of historical market data for given conid.
     * @summary Market Data History (Beta)
     * @param {number} conid contract id
     * @param {'min' | 'h' | 'd' | 'w' | 'm' | 'y'} period Time period for history request.    * min: Minutes   * h: Hours   * d: Days   * w: Weeks   * m: Months   * y: Years 
     * @param {'min' | 'h' | 'd' | 'w' | 'm'} [bar] Duration of time for each candlestick bar.   * min: Minutes   * h: Hours   * d: Days   * w: Weeks   * m: Months 
     * @param {boolean} [outsideRth] For contracts that support it, will determine if history data includes outside of regular trading hours.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public hmdsHistoryGet(conid: number, period: 'min' | 'h' | 'd' | 'w' | 'm' | 'y', bar?: 'min' | 'h' | 'd' | 'w' | 'm', outsideRth?: boolean, options?: AxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).hmdsHistoryGet(conid, period, bar, outsideRth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel market data for given conid. To cancel all market data request(s), see /iserver/marketdata/unsubscribeall. 
     * @summary Market Data Cancel (Single)
     * @param {string} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public iserverMarketdataConidUnsubscribeGet(conid: string, options?: AxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).iserverMarketdataConidUnsubscribeGet(conid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get historical market Data for given conid, length of data is controlled by \'period\' and \'bar\'. Formatted as: min=minute, h=hour, d=day, w=week, m=month, y=year e.g. period =1y with bar =1w returns 52 data points (Max of 1000 data points supported). **Note**: There\'s a limit of 5 concurrent requests. Excessive requests will return a \'Too many requests\' status 429 response. 
     * @summary Market Data History
     * @param {string} conid contract id
     * @param {string} period available time period-- {1-30}min, {1-8}h, {1-1000}d, {1-792}w, {1-182}m, {1-15}y
     * @param {string} [exchange] Exchange of the conid (e.g. ISLAND, NYSE, etc.). Default value is empty which corresponds to primary exchange of the conid.
     * @param {string} [bar] possible value-- 1min, 2min, 3min, 5min, 10min, 15min, 30min, 1h, 2h, 3h, 4h, 8h, 1d, 1w, 1m
     * @param {boolean} [outsideRth] For contracts that support it, will determine if historical data includes outside of regular trading hours.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public iserverMarketdataHistoryGet(conid: string, period: string, exchange?: string, bar?: string, outsideRth?: boolean, options?: AxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).iserverMarketdataHistoryGet(conid, period, exchange, bar, outsideRth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Market Data for the given conid(s). The endpoint will return by default bid, ask, last, change, change pct, close, listing exchange. See response fields for a list of available fields that can be request via fields argument. The endpoint /iserver/accounts must be called prior to /iserver/marketdata/snapshot. For derivative contracts the endpoint /iserver/secdef/search must be called first. First /snapshot endpoint call for given conid will initiate the market data request.  To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
     * @summary Market Data
     * @param {string} conids list of conids separated by comma
     * @param {number} [since] time period since which updates are required. uses epoch time with milliseconds.
     * @param {string} [fields] list of fields separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public iserverMarketdataSnapshotGet(conids: string, since?: number, fields?: string, options?: AxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).iserverMarketdataSnapshotGet(conids, since, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel all market data request(s). To cancel market data for given conid, see /iserver/marketdata/{conid}/unsubscribe. 
     * @summary Market Data Cancel (All)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public iserverMarketdataUnsubscribeallGet(options?: AxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).iserverMarketdataUnsubscribeallGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a snapshot of Market Data for the given conid(s).See response for a list of available fields that can be requested from the fields argument. Must be connected to a brokerage session before can query snapshot data. First /snapshot endpoint call for given conid(s) will initiate the market data request, make an additional request to receive field values back. To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
     * @summary Market Data Snapshot (Beta)
     * @param {'conid@exchange:instrType'} conids List of conids comma separated. Optional exchange and instrument type can be specified.   * conid: IBKR Contract Identifier   * exchange: Exchange or venue   * instrType: Instrument Type supported values: CS (Stocks), OPT (Options), FUT (Futures), FOP (Future Options), WAR (Warrants), BOND (Bonds), FUND (Mutual Funds), CASH (Forex), CFD (Contract for difference), IND (Index) 
     * @param {string} [fields] list of fields separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public mdSnapshotGet(conids: 'conid@exchange:instrType', fields?: string, options?: AxiosRequestConfig) {
        return MarketDataApiFp(this.configuration).mdSnapshotGet(conids, fields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels an open order. Must call /iserver/accounts endpoint prior to cancelling an order. Use /iservers/account/orders endpoint to review open-order(s) and get latest order status.
         * @summary Cancel Order
         * @param {string} accountId account id, or fa group if deleting a group order
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderOrderIdDelete: async (accountId: string, orderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('iserverAccountAccountIdOrderOrderIdDelete', 'accountId', accountId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('iserverAccountAccountIdOrderOrderIdDelete', 'orderId', orderId)
            const localVarPath = `/iserver/account/{accountId}/order/{orderId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies an open order. Must call /iserver/accounts endpoint prior to modifying an order. Use /iservers/account/orders endpoint to review open-order(s).
         * @summary Modify Order
         * @param {string} accountId account id, or fa group if modifying a group order
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {ModifyOrder} body modify-order request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderOrderIdPost: async (accountId: string, orderId: string, body: ModifyOrder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('iserverAccountAccountIdOrderOrderIdPost', 'accountId', accountId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('iserverAccountAccountIdOrderOrderIdPost', 'orderId', orderId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('iserverAccountAccountIdOrderOrderIdPost', 'body', body)
            const localVarPath = `/iserver/account/{accountId}/order/{orderId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is going to be deprecated, you can use /iserver/account/{accountId}/orders, just pass one order in the array, the order structure will be same. Please note here, sometimes this endpoint alone can\'t make sure you submit the order successfully, you could receive some questions in the response, you have to to answer them in order to submit the order successfully. You can use \"/iserver/reply/{replyid}\" endpoint to answer questions 
         * @summary Place Order (Deprecated)
         * @param {string} accountId account id
         * @param {OrderRequest} body order request info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderPost: async (accountId: string, body: OrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('iserverAccountAccountIdOrderPost', 'accountId', accountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('iserverAccountAccountIdOrderPost', 'body', body)
            const localVarPath = `/iserver/account/{accountId}/order`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders/whatif, just pass one order in the array, the order structure will be same. This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. 
         * @summary Preview Order (Deprecated)
         * @param {string} accountId account id
         * @param {OrderRequest} body order info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderWhatifPost: async (accountId: string, body: OrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('iserverAccountAccountIdOrderWhatifPost', 'accountId', accountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('iserverAccountAccountIdOrderWhatifPost', 'body', body)
            const localVarPath = `/iserver/account/{accountId}/order/whatif`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When connected to an IServer Brokerage Session, this endpoint will allow you to submit orders.  CP WEB API supports various advanced orderTypes, for additional details and examples refer to [IBKR Quant Blog](https://www.tradersinsight.news/category/ibkr-quant-news/programming_languages/rest-development/).   * Bracket - Attach additional opposite-side order(s) by using a single **cOID** sent with the parent and set the same value for **parentId** in each child order(s).   * Cash Quantity -  Send orders using monetary value by specifying **cashQty** instead of quantity, e.g. cashQty: 200. The endpoint /iserver/contract/rules returns list of valid orderTypes in cqtTypes.   * Currency Conversion - Convert cash from one currency to another by including **isCcyConv** = **true**. To specify the cash quantity use **fxQTY** instead of quantity, e.g. fxQTY: 100.   * Fractional - Contracts that support fractional shares can be traded by specifying **quantity** as a float, e.g. quantity: 0.001. The endpoint /iserver/contract/rules returns a list of valid orderTypes in fraqTypes.   * IB Algos - Attached user-defined settings to your trades by using any of IBKR\'s Algo Orders. Use the endpoint /iserver/contract/{conid}/algos to identify the available strategies for a contract.   * One-Cancels-All (OCA) - Group multiple unrelated orders by passing order request info in an array and including **isSingleGroup = true** for each order. All orders will be assigned the same oca_group_id. 
         * @summary Place Orders
         * @param {string} accountId account id
         * @param {IserverAccountAccountIdOrdersPostRequest} body order request info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrdersPost: async (accountId: string, body: IserverAccountAccountIdOrdersPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('iserverAccountAccountIdOrdersPost', 'accountId', accountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('iserverAccountAccountIdOrdersPost', 'body', body)
            const localVarPath = `/iserver/account/{accountId}/orders`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. Also supports bracket orders. 
         * @summary Preview Orders
         * @param {string} accountId account id
         * @param {IserverAccountAccountIdOrdersPostRequest} body order info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrdersWhatifPost: async (accountId: string, body: IserverAccountAccountIdOrdersPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('iserverAccountAccountIdOrdersWhatifPost', 'accountId', accountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('iserverAccountAccountIdOrdersWhatifPost', 'body', body)
            const localVarPath = `/iserver/account/{accountId}/orders/whatif`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Order Status
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrderStatusOrderIdGet: async (orderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('iserverAccountOrderStatusOrderIdGet', 'orderId', orderId)
            const localVarPath = `/iserver/account/order/status/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Financial Advisors can use this endpoint to place an order for a specified group. To place an order for a specified account use the endpoint /iserver/account/{accountId}/order. More information about groups can be found in the [TWS Users\' Guide:](https://guides.interactivebrokers.com/twsguide/twsguide.htm#usersguidebook/financialadvisors/create_an_account_group_for_share_allocation.htm). 
         * @summary Place Orders for FA
         * @param {string} faGroup financial advisor group
         * @param {OrderRequest} body order request info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrdersFaGroupPost: async (faGroup: string, body: OrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'faGroup' is not null or undefined
            assertParamExists('iserverAccountOrdersFaGroupPost', 'faGroup', faGroup)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('iserverAccountOrdersFaGroupPost', 'body', body)
            const localVarPath = `/iserver/account/orders/{faGroup}`
                .replace(`{${"faGroup"}}`, encodeURIComponent(String(faGroup)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint is meant to be used in polling mode, e.g. requesting every x seconds. The response will contain two objects, one is notification, the other is orders. Orders is the list of live orders (cancelled, filled, submitted). Notifications contains information about execute orders as they happen, see status field. To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary Live Orders
         * @param {string} [filters] list of filters separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrdersGet: async (filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iserver/account/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reply to questions when placing orders and submit orders
         * @summary Place Order Reply
         * @param {string} replyid Please use the \&quot;id\&quot; from the response of \&quot;Place Order\&quot; endpoint
         * @param {IserverReplyReplyidPostRequest} body Answer to question
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverReplyReplyidPost: async (replyid: string, body: IserverReplyReplyidPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'replyid' is not null or undefined
            assertParamExists('iserverReplyReplyidPost', 'replyid', replyid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('iserverReplyReplyidPost', 'body', body)
            const localVarPath = `/iserver/reply/{replyid}`
                .replace(`{${"replyid"}}`, encodeURIComponent(String(replyid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels an open order. Must call /iserver/accounts endpoint prior to cancelling an order. Use /iservers/account/orders endpoint to review open-order(s) and get latest order status.
         * @summary Cancel Order
         * @param {string} accountId account id, or fa group if deleting a group order
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountAccountIdOrderOrderIdDelete(accountId: string, orderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverAccountAccountIdOrderOrderIdDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountAccountIdOrderOrderIdDelete(accountId, orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Modifies an open order. Must call /iserver/accounts endpoint prior to modifying an order. Use /iservers/account/orders endpoint to review open-order(s).
         * @summary Modify Order
         * @param {string} accountId account id, or fa group if modifying a group order
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {ModifyOrder} body modify-order request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountAccountIdOrderOrderIdPost(accountId: string, orderId: string, body: ModifyOrder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IserverAccountAccountIdOrderOrderIdPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountAccountIdOrderOrderIdPost(accountId, orderId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is going to be deprecated, you can use /iserver/account/{accountId}/orders, just pass one order in the array, the order structure will be same. Please note here, sometimes this endpoint alone can\'t make sure you submit the order successfully, you could receive some questions in the response, you have to to answer them in order to submit the order successfully. You can use \"/iserver/reply/{replyid}\" endpoint to answer questions 
         * @summary Place Order (Deprecated)
         * @param {string} accountId account id
         * @param {OrderRequest} body order request info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async iserverAccountAccountIdOrderPost(accountId: string, body: OrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IserverAccountAccountIdOrderPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountAccountIdOrderPost(accountId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders/whatif, just pass one order in the array, the order structure will be same. This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. 
         * @summary Preview Order (Deprecated)
         * @param {string} accountId account id
         * @param {OrderRequest} body order info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async iserverAccountAccountIdOrderWhatifPost(accountId: string, body: OrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverAccountAccountIdOrderWhatifPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountAccountIdOrderWhatifPost(accountId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When connected to an IServer Brokerage Session, this endpoint will allow you to submit orders.  CP WEB API supports various advanced orderTypes, for additional details and examples refer to [IBKR Quant Blog](https://www.tradersinsight.news/category/ibkr-quant-news/programming_languages/rest-development/).   * Bracket - Attach additional opposite-side order(s) by using a single **cOID** sent with the parent and set the same value for **parentId** in each child order(s).   * Cash Quantity -  Send orders using monetary value by specifying **cashQty** instead of quantity, e.g. cashQty: 200. The endpoint /iserver/contract/rules returns list of valid orderTypes in cqtTypes.   * Currency Conversion - Convert cash from one currency to another by including **isCcyConv** = **true**. To specify the cash quantity use **fxQTY** instead of quantity, e.g. fxQTY: 100.   * Fractional - Contracts that support fractional shares can be traded by specifying **quantity** as a float, e.g. quantity: 0.001. The endpoint /iserver/contract/rules returns a list of valid orderTypes in fraqTypes.   * IB Algos - Attached user-defined settings to your trades by using any of IBKR\'s Algo Orders. Use the endpoint /iserver/contract/{conid}/algos to identify the available strategies for a contract.   * One-Cancels-All (OCA) - Group multiple unrelated orders by passing order request info in an array and including **isSingleGroup = true** for each order. All orders will be assigned the same oca_group_id. 
         * @summary Place Orders
         * @param {string} accountId account id
         * @param {IserverAccountAccountIdOrdersPostRequest} body order request info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountAccountIdOrdersPost(accountId: string, body: IserverAccountAccountIdOrdersPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IserverAccountAccountIdOrderPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountAccountIdOrdersPost(accountId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. Also supports bracket orders. 
         * @summary Preview Orders
         * @param {string} accountId account id
         * @param {IserverAccountAccountIdOrdersPostRequest} body order info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountAccountIdOrdersWhatifPost(accountId: string, body: IserverAccountAccountIdOrdersPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverAccountAccountIdOrderWhatifPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountAccountIdOrdersWhatifPost(accountId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Order Status
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountOrderStatusOrderIdGet(orderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountOrderStatusOrderIdGet(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Financial Advisors can use this endpoint to place an order for a specified group. To place an order for a specified account use the endpoint /iserver/account/{accountId}/order. More information about groups can be found in the [TWS Users\' Guide:](https://guides.interactivebrokers.com/twsguide/twsguide.htm#usersguidebook/financialadvisors/create_an_account_group_for_share_allocation.htm). 
         * @summary Place Orders for FA
         * @param {string} faGroup financial advisor group
         * @param {OrderRequest} body order request info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountOrdersFaGroupPost(faGroup: string, body: OrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IserverAccountAccountIdOrderPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountOrdersFaGroupPost(faGroup, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The endpoint is meant to be used in polling mode, e.g. requesting every x seconds. The response will contain two objects, one is notification, the other is orders. Orders is the list of live orders (cancelled, filled, submitted). Notifications contains information about execute orders as they happen, see status field. To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary Live Orders
         * @param {string} [filters] list of filters separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountOrdersGet(filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverAccountOrdersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountOrdersGet(filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reply to questions when placing orders and submit orders
         * @summary Place Order Reply
         * @param {string} replyid Please use the \&quot;id\&quot; from the response of \&quot;Place Order\&quot; endpoint
         * @param {IserverReplyReplyidPostRequest} body Answer to question
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverReplyReplyidPost(replyid: string, body: IserverReplyReplyidPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IserverReplyReplyidPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverReplyReplyidPost(replyid, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * Cancels an open order. Must call /iserver/accounts endpoint prior to cancelling an order. Use /iservers/account/orders endpoint to review open-order(s) and get latest order status.
         * @summary Cancel Order
         * @param {string} accountId account id, or fa group if deleting a group order
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderOrderIdDelete(accountId: string, orderId: string, options?: any): AxiosPromise<IserverAccountAccountIdOrderOrderIdDelete200Response> {
            return localVarFp.iserverAccountAccountIdOrderOrderIdDelete(accountId, orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies an open order. Must call /iserver/accounts endpoint prior to modifying an order. Use /iservers/account/orders endpoint to review open-order(s).
         * @summary Modify Order
         * @param {string} accountId account id, or fa group if modifying a group order
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {ModifyOrder} body modify-order request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderOrderIdPost(accountId: string, orderId: string, body: ModifyOrder, options?: any): AxiosPromise<Array<IserverAccountAccountIdOrderOrderIdPost200ResponseInner>> {
            return localVarFp.iserverAccountAccountIdOrderOrderIdPost(accountId, orderId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is going to be deprecated, you can use /iserver/account/{accountId}/orders, just pass one order in the array, the order structure will be same. Please note here, sometimes this endpoint alone can\'t make sure you submit the order successfully, you could receive some questions in the response, you have to to answer them in order to submit the order successfully. You can use \"/iserver/reply/{replyid}\" endpoint to answer questions 
         * @summary Place Order (Deprecated)
         * @param {string} accountId account id
         * @param {OrderRequest} body order request info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderPost(accountId: string, body: OrderRequest, options?: any): AxiosPromise<Array<IserverAccountAccountIdOrderPost200ResponseInner>> {
            return localVarFp.iserverAccountAccountIdOrderPost(accountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders/whatif, just pass one order in the array, the order structure will be same. This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. 
         * @summary Preview Order (Deprecated)
         * @param {string} accountId account id
         * @param {OrderRequest} body order info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderWhatifPost(accountId: string, body: OrderRequest, options?: any): AxiosPromise<IserverAccountAccountIdOrderWhatifPost200Response> {
            return localVarFp.iserverAccountAccountIdOrderWhatifPost(accountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * When connected to an IServer Brokerage Session, this endpoint will allow you to submit orders.  CP WEB API supports various advanced orderTypes, for additional details and examples refer to [IBKR Quant Blog](https://www.tradersinsight.news/category/ibkr-quant-news/programming_languages/rest-development/).   * Bracket - Attach additional opposite-side order(s) by using a single **cOID** sent with the parent and set the same value for **parentId** in each child order(s).   * Cash Quantity -  Send orders using monetary value by specifying **cashQty** instead of quantity, e.g. cashQty: 200. The endpoint /iserver/contract/rules returns list of valid orderTypes in cqtTypes.   * Currency Conversion - Convert cash from one currency to another by including **isCcyConv** = **true**. To specify the cash quantity use **fxQTY** instead of quantity, e.g. fxQTY: 100.   * Fractional - Contracts that support fractional shares can be traded by specifying **quantity** as a float, e.g. quantity: 0.001. The endpoint /iserver/contract/rules returns a list of valid orderTypes in fraqTypes.   * IB Algos - Attached user-defined settings to your trades by using any of IBKR\'s Algo Orders. Use the endpoint /iserver/contract/{conid}/algos to identify the available strategies for a contract.   * One-Cancels-All (OCA) - Group multiple unrelated orders by passing order request info in an array and including **isSingleGroup = true** for each order. All orders will be assigned the same oca_group_id. 
         * @summary Place Orders
         * @param {string} accountId account id
         * @param {IserverAccountAccountIdOrdersPostRequest} body order request info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrdersPost(accountId: string, body: IserverAccountAccountIdOrdersPostRequest, options?: any): AxiosPromise<Array<IserverAccountAccountIdOrderPost200ResponseInner>> {
            return localVarFp.iserverAccountAccountIdOrdersPost(accountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. Also supports bracket orders. 
         * @summary Preview Orders
         * @param {string} accountId account id
         * @param {IserverAccountAccountIdOrdersPostRequest} body order info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrdersWhatifPost(accountId: string, body: IserverAccountAccountIdOrdersPostRequest, options?: any): AxiosPromise<IserverAccountAccountIdOrderWhatifPost200Response> {
            return localVarFp.iserverAccountAccountIdOrdersWhatifPost(accountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Order Status
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrderStatusOrderIdGet(orderId: string, options?: any): AxiosPromise<OrderStatus> {
            return localVarFp.iserverAccountOrderStatusOrderIdGet(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Financial Advisors can use this endpoint to place an order for a specified group. To place an order for a specified account use the endpoint /iserver/account/{accountId}/order. More information about groups can be found in the [TWS Users\' Guide:](https://guides.interactivebrokers.com/twsguide/twsguide.htm#usersguidebook/financialadvisors/create_an_account_group_for_share_allocation.htm). 
         * @summary Place Orders for FA
         * @param {string} faGroup financial advisor group
         * @param {OrderRequest} body order request info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrdersFaGroupPost(faGroup: string, body: OrderRequest, options?: any): AxiosPromise<Array<IserverAccountAccountIdOrderPost200ResponseInner>> {
            return localVarFp.iserverAccountOrdersFaGroupPost(faGroup, body, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint is meant to be used in polling mode, e.g. requesting every x seconds. The response will contain two objects, one is notification, the other is orders. Orders is the list of live orders (cancelled, filled, submitted). Notifications contains information about execute orders as they happen, see status field. To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary Live Orders
         * @param {string} [filters] list of filters separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrdersGet(filters?: string, options?: any): AxiosPromise<IserverAccountOrdersGet200Response> {
            return localVarFp.iserverAccountOrdersGet(filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Reply to questions when placing orders and submit orders
         * @summary Place Order Reply
         * @param {string} replyid Please use the \&quot;id\&quot; from the response of \&quot;Place Order\&quot; endpoint
         * @param {IserverReplyReplyidPostRequest} body Answer to question
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverReplyReplyidPost(replyid: string, body: IserverReplyReplyidPostRequest, options?: any): AxiosPromise<Array<IserverReplyReplyidPost200ResponseInner>> {
            return localVarFp.iserverReplyReplyidPost(replyid, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * Cancels an open order. Must call /iserver/accounts endpoint prior to cancelling an order. Use /iservers/account/orders endpoint to review open-order(s) and get latest order status.
     * @summary Cancel Order
     * @param {string} accountId account id, or fa group if deleting a group order
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public iserverAccountAccountIdOrderOrderIdDelete(accountId: string, orderId: string, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).iserverAccountAccountIdOrderOrderIdDelete(accountId, orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies an open order. Must call /iserver/accounts endpoint prior to modifying an order. Use /iservers/account/orders endpoint to review open-order(s).
     * @summary Modify Order
     * @param {string} accountId account id, or fa group if modifying a group order
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {ModifyOrder} body modify-order request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public iserverAccountAccountIdOrderOrderIdPost(accountId: string, orderId: string, body: ModifyOrder, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).iserverAccountAccountIdOrderOrderIdPost(accountId, orderId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is going to be deprecated, you can use /iserver/account/{accountId}/orders, just pass one order in the array, the order structure will be same. Please note here, sometimes this endpoint alone can\'t make sure you submit the order successfully, you could receive some questions in the response, you have to to answer them in order to submit the order successfully. You can use \"/iserver/reply/{replyid}\" endpoint to answer questions 
     * @summary Place Order (Deprecated)
     * @param {string} accountId account id
     * @param {OrderRequest} body order request info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public iserverAccountAccountIdOrderPost(accountId: string, body: OrderRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).iserverAccountAccountIdOrderPost(accountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders/whatif, just pass one order in the array, the order structure will be same. This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. 
     * @summary Preview Order (Deprecated)
     * @param {string} accountId account id
     * @param {OrderRequest} body order info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public iserverAccountAccountIdOrderWhatifPost(accountId: string, body: OrderRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).iserverAccountAccountIdOrderWhatifPost(accountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When connected to an IServer Brokerage Session, this endpoint will allow you to submit orders.  CP WEB API supports various advanced orderTypes, for additional details and examples refer to [IBKR Quant Blog](https://www.tradersinsight.news/category/ibkr-quant-news/programming_languages/rest-development/).   * Bracket - Attach additional opposite-side order(s) by using a single **cOID** sent with the parent and set the same value for **parentId** in each child order(s).   * Cash Quantity -  Send orders using monetary value by specifying **cashQty** instead of quantity, e.g. cashQty: 200. The endpoint /iserver/contract/rules returns list of valid orderTypes in cqtTypes.   * Currency Conversion - Convert cash from one currency to another by including **isCcyConv** = **true**. To specify the cash quantity use **fxQTY** instead of quantity, e.g. fxQTY: 100.   * Fractional - Contracts that support fractional shares can be traded by specifying **quantity** as a float, e.g. quantity: 0.001. The endpoint /iserver/contract/rules returns a list of valid orderTypes in fraqTypes.   * IB Algos - Attached user-defined settings to your trades by using any of IBKR\'s Algo Orders. Use the endpoint /iserver/contract/{conid}/algos to identify the available strategies for a contract.   * One-Cancels-All (OCA) - Group multiple unrelated orders by passing order request info in an array and including **isSingleGroup = true** for each order. All orders will be assigned the same oca_group_id. 
     * @summary Place Orders
     * @param {string} accountId account id
     * @param {IserverAccountAccountIdOrdersPostRequest} body order request info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public iserverAccountAccountIdOrdersPost(accountId: string, body: IserverAccountAccountIdOrdersPostRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).iserverAccountAccountIdOrdersPost(accountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. Also supports bracket orders. 
     * @summary Preview Orders
     * @param {string} accountId account id
     * @param {IserverAccountAccountIdOrdersPostRequest} body order info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public iserverAccountAccountIdOrdersWhatifPost(accountId: string, body: IserverAccountAccountIdOrdersPostRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).iserverAccountAccountIdOrdersWhatifPost(accountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Order Status
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public iserverAccountOrderStatusOrderIdGet(orderId: string, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).iserverAccountOrderStatusOrderIdGet(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Financial Advisors can use this endpoint to place an order for a specified group. To place an order for a specified account use the endpoint /iserver/account/{accountId}/order. More information about groups can be found in the [TWS Users\' Guide:](https://guides.interactivebrokers.com/twsguide/twsguide.htm#usersguidebook/financialadvisors/create_an_account_group_for_share_allocation.htm). 
     * @summary Place Orders for FA
     * @param {string} faGroup financial advisor group
     * @param {OrderRequest} body order request info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public iserverAccountOrdersFaGroupPost(faGroup: string, body: OrderRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).iserverAccountOrdersFaGroupPost(faGroup, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint is meant to be used in polling mode, e.g. requesting every x seconds. The response will contain two objects, one is notification, the other is orders. Orders is the list of live orders (cancelled, filled, submitted). Notifications contains information about execute orders as they happen, see status field. To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
     * @summary Live Orders
     * @param {string} [filters] list of filters separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public iserverAccountOrdersGet(filters?: string, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).iserverAccountOrdersGet(filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reply to questions when placing orders and submit orders
     * @summary Place Order Reply
     * @param {string} replyid Please use the \&quot;id\&quot; from the response of \&quot;Place Order\&quot; endpoint
     * @param {IserverReplyReplyidPostRequest} body Answer to question
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public iserverReplyReplyidPost(replyid: string, body: IserverReplyReplyidPostRequest, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).iserverReplyReplyidPost(replyid, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PnLApi - axios parameter creator
 * @export
 */
export const PnLApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary PnL for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPnlPartitionedGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iserver/account/pnl/partitioned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PnLApi - functional programming interface
 * @export
 */
export const PnLApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PnLApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary PnL for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountPnlPartitionedGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverAccountPnlPartitionedGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountPnlPartitionedGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PnLApi - factory interface
 * @export
 */
export const PnLApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PnLApiFp(configuration)
    return {
        /**
         * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
         * @summary PnL for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPnlPartitionedGet(options?: any): AxiosPromise<IserverAccountPnlPartitionedGet200Response> {
            return localVarFp.iserverAccountPnlPartitionedGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PnLApi - object-oriented interface
 * @export
 * @class PnLApi
 * @extends {BaseAPI}
 */
export class PnLApi extends BaseAPI {
    /**
     * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details. 
     * @summary PnL for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PnLApi
     */
    public iserverAccountPnlPartitionedGet(options?: AxiosRequestConfig) {
        return PnLApiFp(this.configuration).iserverAccountPnlPartitionedGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PortfolioApi - axios parameter creator
 * @export
 */
export const PortfolioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Information about the account\'s portfolio allocation by Asset Class, Industry and Category.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Allocation
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdAllocationGet: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('portfolioAccountIdAllocationGet', 'accountId', accountId)
            const localVarPath = `/portfolio/{accountId}/allocation`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
         * @summary Account Ledger
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdLedgerGet: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('portfolioAccountIdLedgerGet', 'accountId', accountId)
            const localVarPath = `/portfolio/{accountId}/ledger`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Information
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdMetaGet: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('portfolioAccountIdMetaGet', 'accountId', accountId)
            const localVarPath = `/portfolio/{accountId}/meta`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all positions matching the conid. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Position by Conid
         * @param {string} accountId account id
         * @param {number} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionConidGet: async (accountId: string, conid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('portfolioAccountIdPositionConidGet', 'accountId', accountId)
            // verify required parameter 'conid' is not null or undefined
            assertParamExists('portfolioAccountIdPositionConidGet', 'conid', conid)
            const localVarPath = `/portfolio/{accountId}/position/{conid}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"conid"}}`, encodeURIComponent(String(conid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidates the backend cache of the Portfolio
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionsInvalidatePost: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('portfolioAccountIdPositionsInvalidatePost', 'accountId', accountId)
            const localVarPath = `/portfolio/{accountId}/positions/invalidate`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of positions for the given account. The endpoint supports paging, page\'s default size is 30 positions. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Portfolio Positions
         * @param {string} accountId account id
         * @param {string} pageId page id
         * @param {string} [model] optional
         * @param {string} [sort] declare the table to be sorted by which column
         * @param {string} [direction] in which order, a means ascending - d means descending
         * @param {string} [period] period for pnl column, can be 1D, 7D, 1M...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionsPageIdGet: async (accountId: string, pageId: string, model?: string, sort?: string, direction?: string, period?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('portfolioAccountIdPositionsPageIdGet', 'accountId', accountId)
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('portfolioAccountIdPositionsPageIdGet', 'pageId', pageId)
            const localVarPath = `/portfolio/{accountId}/positions/{pageId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Summary
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdSummaryGet: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('portfolioAccountIdSummaryGet', 'accountId', accountId)
            const localVarPath = `/portfolio/{accountId}/summary`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior to calling other /portfolio endpoints for those accounts. For querying a list of accounts which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
         * @summary Portfolio Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Similar to /portfolio/{accountId}/allocation but returns a consolidated view of of all the accounts returned by /portfolio/accounts. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Alloction (All Accounts)
         * @param {PaSummaryPostRequest} body accounts info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAllocationPost: async (body: PaSummaryPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('portfolioAllocationPost', 'body', body)
            const localVarPath = `/portfolio/allocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object of all positions matching the conid for all the selected accounts. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Positions by Conid
         * @param {number} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioPositionsConidGet: async (conid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conid' is not null or undefined
            assertParamExists('portfolioPositionsConidGet', 'conid', conid)
            const localVarPath = `/portfolio/positions/{conid}`
                .replace(`{${"conid"}}`, encodeURIComponent(String(conid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of sub-accounts, paginated up to 20 accounts per page, for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have less than 100 sub-accounts use /portfolio/subaccounts. To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts (Large Accounts)
         * @param {string} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioSubaccounts2Get: async (page: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('portfolioSubaccounts2Get', 'page', page)
            const localVarPath = `/portfolio/subaccounts2`
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of up to 100 sub-accounts for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have more than 100 sub-accounts use /portfolio/subaccounts2. To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioSubaccountsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/subaccounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioApi - functional programming interface
 * @export
 */
export const PortfolioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortfolioApiAxiosParamCreator(configuration)
    return {
        /**
         * Information about the account\'s portfolio allocation by Asset Class, Industry and Category.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Allocation
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioAccountIdAllocationGet(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllocationInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioAccountIdAllocationGet(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
         * @summary Account Ledger
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioAccountIdLedgerGet(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioAccountIdLedgerGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioAccountIdLedgerGet(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Information
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioAccountIdMetaGet(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioAccountIdMetaGet(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all positions matching the conid. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Position by Conid
         * @param {string} accountId account id
         * @param {number} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioAccountIdPositionConidGet(accountId: string, conid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PositionInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioAccountIdPositionConidGet(accountId, conid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invalidates the backend cache of the Portfolio
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioAccountIdPositionsInvalidatePost(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioAccountIdPositionsInvalidatePost(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of positions for the given account. The endpoint supports paging, page\'s default size is 30 positions. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Portfolio Positions
         * @param {string} accountId account id
         * @param {string} pageId page id
         * @param {string} [model] optional
         * @param {string} [sort] declare the table to be sorted by which column
         * @param {string} [direction] in which order, a means ascending - d means descending
         * @param {string} [period] period for pnl column, can be 1D, 7D, 1M...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioAccountIdPositionsPageIdGet(accountId: string, pageId: string, model?: string, sort?: string, direction?: string, period?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PositionInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioAccountIdPositionsPageIdGet(accountId, pageId, model, sort, direction, period, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Summary
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioAccountIdSummaryGet(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioAccountIdSummaryGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioAccountIdSummaryGet(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior to calling other /portfolio endpoints for those accounts. For querying a list of accounts which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
         * @summary Portfolio Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioAccountsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioAccountsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Similar to /portfolio/{accountId}/allocation but returns a consolidated view of of all the accounts returned by /portfolio/accounts. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Alloction (All Accounts)
         * @param {PaSummaryPostRequest} body accounts info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioAllocationPost(body: PaSummaryPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllocationInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioAllocationPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object of all positions matching the conid for all the selected accounts. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Positions by Conid
         * @param {number} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioPositionsConidGet(conid: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioPositionsConidGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioPositionsConidGet(conid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of sub-accounts, paginated up to 20 accounts per page, for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have less than 100 sub-accounts use /portfolio/subaccounts. To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts (Large Accounts)
         * @param {string} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioSubaccounts2Get(page: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioSubaccounts2Get200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioSubaccounts2Get(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of up to 100 sub-accounts for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have more than 100 sub-accounts use /portfolio/subaccounts2. To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioSubaccountsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioSubaccountsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PortfolioApi - factory interface
 * @export
 */
export const PortfolioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortfolioApiFp(configuration)
    return {
        /**
         * Information about the account\'s portfolio allocation by Asset Class, Industry and Category.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Allocation
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdAllocationGet(accountId: string, options?: any): AxiosPromise<Array<AllocationInner>> {
            return localVarFp.portfolioAccountIdAllocationGet(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
         * @summary Account Ledger
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdLedgerGet(accountId: string, options?: any): AxiosPromise<PortfolioAccountIdLedgerGet200Response> {
            return localVarFp.portfolioAccountIdLedgerGet(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Information
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdMetaGet(accountId: string, options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.portfolioAccountIdMetaGet(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all positions matching the conid. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Position by Conid
         * @param {string} accountId account id
         * @param {number} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionConidGet(accountId: string, conid: number, options?: any): AxiosPromise<Array<PositionInner>> {
            return localVarFp.portfolioAccountIdPositionConidGet(accountId, conid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invalidates the backend cache of the Portfolio
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionsInvalidatePost(accountId: string, options?: any): AxiosPromise<object> {
            return localVarFp.portfolioAccountIdPositionsInvalidatePost(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of positions for the given account. The endpoint supports paging, page\'s default size is 30 positions. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Portfolio Positions
         * @param {string} accountId account id
         * @param {string} pageId page id
         * @param {string} [model] optional
         * @param {string} [sort] declare the table to be sorted by which column
         * @param {string} [direction] in which order, a means ascending - d means descending
         * @param {string} [period] period for pnl column, can be 1D, 7D, 1M...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionsPageIdGet(accountId: string, pageId: string, model?: string, sort?: string, direction?: string, period?: string, options?: any): AxiosPromise<Array<PositionInner>> {
            return localVarFp.portfolioAccountIdPositionsPageIdGet(accountId, pageId, model, sort, direction, period, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Summary
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdSummaryGet(accountId: string, options?: any): AxiosPromise<PortfolioAccountIdSummaryGet200Response> {
            return localVarFp.portfolioAccountIdSummaryGet(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior to calling other /portfolio endpoints for those accounts. For querying a list of accounts which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
         * @summary Portfolio Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountsGet(options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.portfolioAccountsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to /portfolio/{accountId}/allocation but returns a consolidated view of of all the accounts returned by /portfolio/accounts. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Alloction (All Accounts)
         * @param {PaSummaryPostRequest} body accounts info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAllocationPost(body: PaSummaryPostRequest, options?: any): AxiosPromise<Array<AllocationInner>> {
            return localVarFp.portfolioAllocationPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object of all positions matching the conid for all the selected accounts. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Positions by Conid
         * @param {number} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioPositionsConidGet(conid: number, options?: any): AxiosPromise<PortfolioPositionsConidGet200Response> {
            return localVarFp.portfolioPositionsConidGet(conid, options).then((request) => request(axios, basePath));
        },
        /**
         * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of sub-accounts, paginated up to 20 accounts per page, for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have less than 100 sub-accounts use /portfolio/subaccounts. To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts (Large Accounts)
         * @param {string} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioSubaccounts2Get(page: string, options?: any): AxiosPromise<PortfolioSubaccounts2Get200Response> {
            return localVarFp.portfolioSubaccounts2Get(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of up to 100 sub-accounts for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have more than 100 sub-accounts use /portfolio/subaccounts2. To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioSubaccountsGet(options?: any): AxiosPromise<Account> {
            return localVarFp.portfolioSubaccountsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortfolioApi - object-oriented interface
 * @export
 * @class PortfolioApi
 * @extends {BaseAPI}
 */
export class PortfolioApi extends BaseAPI {
    /**
     * Information about the account\'s portfolio allocation by Asset Class, Industry and Category.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Allocation
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public portfolioAccountIdAllocationGet(accountId: string, options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).portfolioAccountIdAllocationGet(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
     * @summary Account Ledger
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public portfolioAccountIdLedgerGet(accountId: string, options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).portfolioAccountIdLedgerGet(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Information
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public portfolioAccountIdMetaGet(accountId: string, options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).portfolioAccountIdMetaGet(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all positions matching the conid. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Position by Conid
     * @param {string} accountId account id
     * @param {number} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public portfolioAccountIdPositionConidGet(accountId: string, conid: number, options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).portfolioAccountIdPositionConidGet(accountId, conid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invalidates the backend cache of the Portfolio
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public portfolioAccountIdPositionsInvalidatePost(accountId: string, options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).portfolioAccountIdPositionsInvalidatePost(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of positions for the given account. The endpoint supports paging, page\'s default size is 30 positions. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Portfolio Positions
     * @param {string} accountId account id
     * @param {string} pageId page id
     * @param {string} [model] optional
     * @param {string} [sort] declare the table to be sorted by which column
     * @param {string} [direction] in which order, a means ascending - d means descending
     * @param {string} [period] period for pnl column, can be 1D, 7D, 1M...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public portfolioAccountIdPositionsPageIdGet(accountId: string, pageId: string, model?: string, sort?: string, direction?: string, period?: string, options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).portfolioAccountIdPositionsPageIdGet(accountId, pageId, model, sort, direction, period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Summary
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public portfolioAccountIdSummaryGet(accountId: string, options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).portfolioAccountIdSummaryGet(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior to calling other /portfolio endpoints for those accounts. For querying a list of accounts which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
     * @summary Portfolio Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public portfolioAccountsGet(options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).portfolioAccountsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Similar to /portfolio/{accountId}/allocation but returns a consolidated view of of all the accounts returned by /portfolio/accounts. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Alloction (All Accounts)
     * @param {PaSummaryPostRequest} body accounts info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public portfolioAllocationPost(body: PaSummaryPostRequest, options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).portfolioAllocationPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object of all positions matching the conid for all the selected accounts. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Positions by Conid
     * @param {number} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public portfolioPositionsConidGet(conid: number, options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).portfolioPositionsConidGet(conid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of sub-accounts, paginated up to 20 accounts per page, for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have less than 100 sub-accounts use /portfolio/subaccounts. To query a list of accounts the user can trade, see /iserver/accounts.
     * @summary List of Sub-Accounts (Large Accounts)
     * @param {string} page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public portfolioSubaccounts2Get(page: string, options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).portfolioSubaccounts2Get(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used in tiered account structures (such as Financial Advisor and IBroker Accounts) to return a list of up to 100 sub-accounts for which the user can view position and account-related information. This endpoint must be called prior to calling other /portfolio endpoints for those sub-accounts. If you have more than 100 sub-accounts use /portfolio/subaccounts2. To query a list of accounts the user can trade, see /iserver/accounts.
     * @summary List of Sub-Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public portfolioSubaccountsGet(options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).portfolioSubaccountsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PortfolioAnalystApi - axios parameter creator
 * @export
 */
export const PortfolioAnalystApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the performance (MTM) for the given accounts, if more than one account is passed, the result is consolidated.
         * @summary Account Performance
         * @param {PaPerformancePostRequest} body an array of account ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paPerformancePost: async (body: PaPerformancePostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('paPerformancePost', 'body', body)
            const localVarPath = `/pa/performance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is going to be deprecated. Please use /pa/performance instead. Returns a summary of all account balances for the given accounts, if more than one account is passe, the result is consolidated.
         * @summary Account Balance\'s Summary (Deprecated)
         * @param {PaSummaryPostRequest} body an array of account ids
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        paSummaryPost: async (body: PaSummaryPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('paSummaryPost', 'body', body)
            const localVarPath = `/pa/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * transaction history for a given number of conids and accounts. Types of transactions include dividend payments, buy and sell transactions, transfers. 
         * @summary Position\'s Transaction History
         * @param {PaTransactionsPostRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paTransactionsPost: async (body: PaTransactionsPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('paTransactionsPost', 'body', body)
            const localVarPath = `/pa/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioAnalystApi - functional programming interface
 * @export
 */
export const PortfolioAnalystApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortfolioAnalystApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the performance (MTM) for the given accounts, if more than one account is passed, the result is consolidated.
         * @summary Account Performance
         * @param {PaPerformancePostRequest} body an array of account ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paPerformancePost(body: PaPerformancePostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Performance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paPerformancePost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is going to be deprecated. Please use /pa/performance instead. Returns a summary of all account balances for the given accounts, if more than one account is passe, the result is consolidated.
         * @summary Account Balance\'s Summary (Deprecated)
         * @param {PaSummaryPostRequest} body an array of account ids
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async paSummaryPost(body: PaSummaryPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Summary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paSummaryPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * transaction history for a given number of conids and accounts. Types of transactions include dividend payments, buy and sell transactions, transfers. 
         * @summary Position\'s Transaction History
         * @param {PaTransactionsPostRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paTransactionsPost(body: PaTransactionsPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transactions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paTransactionsPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PortfolioAnalystApi - factory interface
 * @export
 */
export const PortfolioAnalystApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortfolioAnalystApiFp(configuration)
    return {
        /**
         * Returns the performance (MTM) for the given accounts, if more than one account is passed, the result is consolidated.
         * @summary Account Performance
         * @param {PaPerformancePostRequest} body an array of account ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paPerformancePost(body: PaPerformancePostRequest, options?: any): AxiosPromise<Performance> {
            return localVarFp.paPerformancePost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is going to be deprecated. Please use /pa/performance instead. Returns a summary of all account balances for the given accounts, if more than one account is passe, the result is consolidated.
         * @summary Account Balance\'s Summary (Deprecated)
         * @param {PaSummaryPostRequest} body an array of account ids
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        paSummaryPost(body: PaSummaryPostRequest, options?: any): AxiosPromise<Summary> {
            return localVarFp.paSummaryPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * transaction history for a given number of conids and accounts. Types of transactions include dividend payments, buy and sell transactions, transfers. 
         * @summary Position\'s Transaction History
         * @param {PaTransactionsPostRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paTransactionsPost(body: PaTransactionsPostRequest, options?: any): AxiosPromise<Transactions> {
            return localVarFp.paTransactionsPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortfolioAnalystApi - object-oriented interface
 * @export
 * @class PortfolioAnalystApi
 * @extends {BaseAPI}
 */
export class PortfolioAnalystApi extends BaseAPI {
    /**
     * Returns the performance (MTM) for the given accounts, if more than one account is passed, the result is consolidated.
     * @summary Account Performance
     * @param {PaPerformancePostRequest} body an array of account ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioAnalystApi
     */
    public paPerformancePost(body: PaPerformancePostRequest, options?: AxiosRequestConfig) {
        return PortfolioAnalystApiFp(this.configuration).paPerformancePost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is going to be deprecated. Please use /pa/performance instead. Returns a summary of all account balances for the given accounts, if more than one account is passe, the result is consolidated.
     * @summary Account Balance\'s Summary (Deprecated)
     * @param {PaSummaryPostRequest} body an array of account ids
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PortfolioAnalystApi
     */
    public paSummaryPost(body: PaSummaryPostRequest, options?: AxiosRequestConfig) {
        return PortfolioAnalystApiFp(this.configuration).paSummaryPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * transaction history for a given number of conids and accounts. Types of transactions include dividend payments, buy and sell transactions, transfers. 
     * @summary Position\'s Transaction History
     * @param {PaTransactionsPostRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioAnalystApi
     */
    public paTransactionsPost(body: PaTransactionsPostRequest, options?: AxiosRequestConfig) {
        return PortfolioAnalystApiFp(this.configuration).paTransactionsPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScannerApi - axios parameter creator
 * @export
 */
export const ScannerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Using a direct connection to the market data farm, will provide results to the requested scanner.
         * @summary Run Scanner (Beta)
         * @param {HmdsScannerPostRequest} body request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hmdsScannerPost: async (body: HmdsScannerPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('hmdsScannerPost', 'body', body)
            const localVarPath = `/hmds/scanner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object contains four lists contain all parameters for scanners
         * @summary Scanner Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverScannerParamsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iserver/scanner/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for contracts according to the filters specified in scanner/params endpoint
         * @summary Scanner Run
         * @param {ScannerParams} body scanner-params request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverScannerRunPost: async (body: ScannerParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('iserverScannerRunPost', 'body', body)
            const localVarPath = `/iserver/scanner/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScannerApi - functional programming interface
 * @export
 */
export const ScannerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScannerApiAxiosParamCreator(configuration)
    return {
        /**
         * Using a direct connection to the market data farm, will provide results to the requested scanner.
         * @summary Run Scanner (Beta)
         * @param {HmdsScannerPostRequest} body request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hmdsScannerPost(body: HmdsScannerPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScannerResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hmdsScannerPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object contains four lists contain all parameters for scanners
         * @summary Scanner Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverScannerParamsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IserverScannerParamsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverScannerParamsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches for contracts according to the filters specified in scanner/params endpoint
         * @summary Scanner Run
         * @param {ScannerParams} body scanner-params request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverScannerRunPost(body: ScannerParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IserverScannerRunPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverScannerRunPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScannerApi - factory interface
 * @export
 */
export const ScannerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScannerApiFp(configuration)
    return {
        /**
         * Using a direct connection to the market data farm, will provide results to the requested scanner.
         * @summary Run Scanner (Beta)
         * @param {HmdsScannerPostRequest} body request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hmdsScannerPost(body: HmdsScannerPostRequest, options?: any): AxiosPromise<ScannerResult> {
            return localVarFp.hmdsScannerPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object contains four lists contain all parameters for scanners
         * @summary Scanner Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverScannerParamsGet(options?: any): AxiosPromise<IserverScannerParamsGet200Response> {
            return localVarFp.iserverScannerParamsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for contracts according to the filters specified in scanner/params endpoint
         * @summary Scanner Run
         * @param {ScannerParams} body scanner-params request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverScannerRunPost(body: ScannerParams, options?: any): AxiosPromise<Array<IserverScannerRunPost200ResponseInner>> {
            return localVarFp.iserverScannerRunPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScannerApi - object-oriented interface
 * @export
 * @class ScannerApi
 * @extends {BaseAPI}
 */
export class ScannerApi extends BaseAPI {
    /**
     * Using a direct connection to the market data farm, will provide results to the requested scanner.
     * @summary Run Scanner (Beta)
     * @param {HmdsScannerPostRequest} body request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScannerApi
     */
    public hmdsScannerPost(body: HmdsScannerPostRequest, options?: AxiosRequestConfig) {
        return ScannerApiFp(this.configuration).hmdsScannerPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object contains four lists contain all parameters for scanners
     * @summary Scanner Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScannerApi
     */
    public iserverScannerParamsGet(options?: AxiosRequestConfig) {
        return ScannerApiFp(this.configuration).iserverScannerParamsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for contracts according to the filters specified in scanner/params endpoint
     * @summary Scanner Run
     * @param {ScannerParams} body scanner-params request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScannerApi
     */
    public iserverScannerRunPost(body: ScannerParams, options?: AxiosRequestConfig) {
        return ScannerApiFp(this.configuration).iserverScannerRunPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Current Authentication status to the Brokerage system. Market Data and Trading is not possible if not authenticated, e.g. authenticated shows false
         * @summary Authentication Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAuthStatusPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iserver/auth/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When using the CP Gateway, this endpoint provides a way to reauthenticate to the Brokerage system as long as there is a valid SSO session, see /sso/validate. 
         * @summary Tries to re-authenticate to Brokerage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverReauthenticatePost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iserver/reauthenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs the user out of the gateway session. Any further activity requires re-authentication.
         * @summary Ends the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates the current session for the SSO user
         * @summary Validate SSO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoValidateGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sso/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the gateway has not received any requests for several minutes an open session will automatically timeout. The tickle endpoint pings the server to prevent the session from ending.
         * @summary Ping the server to keep the session open
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticklePost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tickle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * Current Authentication status to the Brokerage system. Market Data and Trading is not possible if not authenticated, e.g. authenticated shows false
         * @summary Authentication Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAuthStatusPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAuthStatusPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When using the CP Gateway, this endpoint provides a way to reauthenticate to the Brokerage system as long as there is a valid SSO session, see /sso/validate. 
         * @summary Tries to re-authenticate to Brokerage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverReauthenticatePost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverReauthenticatePost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Logs the user out of the gateway session. Any further activity requires re-authentication.
         * @summary Ends the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validates the current session for the SSO user
         * @summary Validate SSO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoValidateGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoValidateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoValidateGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If the gateway has not received any requests for several minutes an open session will automatically timeout. The tickle endpoint pings the server to prevent the session from ending.
         * @summary Ping the server to keep the session open
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ticklePost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ticklePost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * Current Authentication status to the Brokerage system. Market Data and Trading is not possible if not authenticated, e.g. authenticated shows false
         * @summary Authentication Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAuthStatusPost(options?: any): AxiosPromise<AuthStatus> {
            return localVarFp.iserverAuthStatusPost(options).then((request) => request(axios, basePath));
        },
        /**
         * When using the CP Gateway, this endpoint provides a way to reauthenticate to the Brokerage system as long as there is a valid SSO session, see /sso/validate. 
         * @summary Tries to re-authenticate to Brokerage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverReauthenticatePost(options?: any): AxiosPromise<AuthStatus> {
            return localVarFp.iserverReauthenticatePost(options).then((request) => request(axios, basePath));
        },
        /**
         * Logs the user out of the gateway session. Any further activity requires re-authentication.
         * @summary Ends the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutPost(options?: any): AxiosPromise<LogoutPost200Response> {
            return localVarFp.logoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Validates the current session for the SSO user
         * @summary Validate SSO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoValidateGet(options?: any): AxiosPromise<SsoValidateGet200Response> {
            return localVarFp.ssoValidateGet(options).then((request) => request(axios, basePath));
        },
        /**
         * If the gateway has not received any requests for several minutes an open session will automatically timeout. The tickle endpoint pings the server to prevent the session from ending.
         * @summary Ping the server to keep the session open
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticklePost(options?: any): AxiosPromise<void> {
            return localVarFp.ticklePost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * Current Authentication status to the Brokerage system. Market Data and Trading is not possible if not authenticated, e.g. authenticated shows false
     * @summary Authentication Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public iserverAuthStatusPost(options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).iserverAuthStatusPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When using the CP Gateway, this endpoint provides a way to reauthenticate to the Brokerage system as long as there is a valid SSO session, see /sso/validate. 
     * @summary Tries to re-authenticate to Brokerage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public iserverReauthenticatePost(options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).iserverReauthenticatePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logs the user out of the gateway session. Any further activity requires re-authentication.
     * @summary Ends the current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public logoutPost(options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).logoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates the current session for the SSO user
     * @summary Validate SSO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public ssoValidateGet(options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).ssoValidateGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If the gateway has not received any requests for several minutes an open session will automatically timeout. The tickle endpoint pings the server to prevent the session from ending.
     * @summary Ping the server to keep the session open
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public ticklePost(options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).ticklePost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StreamingApi - axios parameter creator
 * @export
 */
export const StreamingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The streaming API is documented under [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary Websocket Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StreamingApi - functional programming interface
 * @export
 */
export const StreamingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StreamingApiAxiosParamCreator(configuration)
    return {
        /**
         * The streaming API is documented under [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary Websocket Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async wsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.wsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StreamingApi - factory interface
 * @export
 */
export const StreamingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StreamingApiFp(configuration)
    return {
        /**
         * The streaming API is documented under [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary Websocket Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wsPost(options?: any): AxiosPromise<void> {
            return localVarFp.wsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StreamingApi - object-oriented interface
 * @export
 * @class StreamingApi
 * @extends {BaseAPI}
 */
export class StreamingApi extends BaseAPI {
    /**
     * The streaming API is documented under [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary Websocket Endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamingApi
     */
    public wsPost(options?: AxiosRequestConfig) {
        return StreamingApiFp(this.configuration).wsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TradesApi - axios parameter creator
 * @export
 */
export const TradesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of trades for the currently selected account for current day and six previous days. It is advised to call this endpoint once per session. 
         * @summary List of Trades for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountTradesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iserver/account/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradesApi - functional programming interface
 * @export
 */
export const TradesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of trades for the currently selected account for current day and six previous days. It is advised to call this endpoint once per session. 
         * @summary List of Trades for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iserverAccountTradesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Trade>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iserverAccountTradesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TradesApi - factory interface
 * @export
 */
export const TradesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradesApiFp(configuration)
    return {
        /**
         * Returns a list of trades for the currently selected account for current day and six previous days. It is advised to call this endpoint once per session. 
         * @summary List of Trades for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountTradesGet(options?: any): AxiosPromise<Array<Trade>> {
            return localVarFp.iserverAccountTradesGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradesApi - object-oriented interface
 * @export
 * @class TradesApi
 * @extends {BaseAPI}
 */
export class TradesApi extends BaseAPI {
    /**
     * Returns a list of trades for the currently selected account for current day and six previous days. It is advised to call this endpoint once per session. 
     * @summary List of Trades for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    public iserverAccountTradesGet(options?: AxiosRequestConfig) {
        return TradesApiFp(this.configuration).iserverAccountTradesGet(options).then((request) => request(this.axios, this.basePath));
    }
}


